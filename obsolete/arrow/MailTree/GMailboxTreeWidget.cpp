/******************************************************************************
 GMailboxTreeWidget.cc

	<Description>

	BASE CLASS = public JXNamedTreeListWidget

	Copyright (C) 1997 by Glenn W. Bach.  All rights reserved.

	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include <GMailboxTreeWidget.h>
#include <GMailboxTreeDir.h>
#include <GMailFileTreeNode.h>
#include <GMessageHeader.h>
#include <GMFileTree.h>
#include <GMailboxTreeDir.h>
#include <GMailboxChooseSaveFile.h>
#include <GMGlobals.h>
#include "envelopes_cursor.h"
#include "GMApp.h"
#include "GInboxMgr.h"
#include "gMailUtils.h"
#include "GMailboxDragData.h"

#include "envelopes.xpm"
#include "tall_envelopes.xpm"
#include "locked_envelopes.xpm"
#include "selected_envelopes.xpm"
#include "selectedfolderIcon.xpm"
#include "gm_folderIcon.xpm"
#include "gm_tall_folderIcon.xpm"
#include "unlock.xpm"

#include <JNamedTreeNode.h>
#include <JNamedTreeList.h>

#include <JXApplication.h>
#include <JXChooseSaveFile.h>
#include <JXColormap.h>
#include <JXDirector.h>
#include <JXDisplay.h>
#include <JXDNDManager.h>
#include <JXImage.h>
#include <JXInputField.h>
#include <JXMenuBar.h>
#include <JXSelectionManager.h>
#include <JXTextMenu.h>
#include <JXTimerTask.h>
#include <JXToolBar.h>
#include <JXUserNotification.h>
#include <JXWindow.h>
#include <JXWindowPainter.h>

#include <JOrderedSetIterator.h>
#include <JTableSelection.h>
#include <JDirInfo.h>

#include <jASCIIConstants.h>
#include <jDirUtil.h>
#include <jErrno.h>
#include <jFileUtil.h>
#include <jMouseUtil.h>
#include <jProcessUtil.h>
#include <jStreamUtil.h>

#include <GMailboxUtils.h>

#include <X11/keysym.h>
#include <jFStreamUtil.h>
#include <strstream>
#include <jAssert.h>


static const JCharacter* kGMailboxMenuTitleStr = "Mailboxes";
static const JCharacter* kGMailboxMenuStr =
	"New mailbox %k Meta-N  %i NewMailbox::Arrow"
	"|New directory %k Meta-Shift-N %i NewDir::Arrow"
	"|Add mailbox %i AddMailbox::Arrow"
	"|Add directory %k Meta-D  %i AddDir::Arrow"
	"|Open selected mailboxes %k Return.  %i OpenSelected::Arrow"
	"%l| Remove from list %i Remove::Arrow"
	"| Delete from file system %i Delete::Arrow"
	"|Unlock %i Unlock::Arrow";

enum
{
	kNewMBoxCmd = 1,
	kNewDirCmd,
	kAddMBoxCmd,
	kAddDirCmd,
	kOpenSelMBoxCmd,
	kRemoveCmd,
	kDeleteCmd,
	kUnlockCmd
};

const JCoordinate kDragBeginBuffer		= 5;
const JCoordinate kCurrentPrefsVersion	= 0;
const JCoordinate kMinRowHeight			= 18;
const JFloat kRowHeightFactor			= 1.2;

const Time kWaitForEditDelay			= 1000; // 2 seconds before editing

static const JCharacter* kDragMessagesXAtomName  = "GMailMessages";
static const JCharacter* kDragMailboxesXAtomName = "GMailBoxes";

static const JCharacter* kDNDClassID				= "GMailboxTreeWidget";

/******************************************************************************
 Constructor

 *****************************************************************************/

GMailboxTreeWidget::GMailboxTreeWidget
	(
	GMFileTree*			tree,
	JNamedTreeList*	treeList,
	JXMenuBar*			menuBar,
	JXScrollbarSet*	scrollbarSet,
	JXContainer*		enclosure,
	const HSizingOption	hSizing,
	const VSizingOption vSizing,
	const JCoordinate	x,
	const JCoordinate	y,
	const JCoordinate	w,
	const JCoordinate	h
	)
	:
   JXNamedTreeListWidget(treeList, scrollbarSet,
							enclosure, hSizing, vSizing, x, y, w, h)
{
	itsTree	= tree;
	itsEditTask	= NULL;

	itsMailboxMenu = menuBar->AppendTextMenu(kGMailboxMenuTitleStr);
	itsMailboxMenu->SetMenuItems(kGMailboxMenuStr);
	itsMailboxMenu->SetUpdateAction(JXMenu::kDisableNone);
	ListenTo(itsMailboxMenu);
	ListenTo(GMGetApplication());

	JFSFileTreeNode* base =
		dynamic_cast<JFSFileTreeNode*>(itsTree->GetRoot());

	itsCurrentDndHereIndex	= 0;
	itsDraggingFiles		= kJFalse;
	itsOutsideRoot			= kJFalse;
	itsWaitingToEdit		= kJFalse;

	const Atom dndName		= GetDNDManager()->GetDNDSelectionName();
	itsMessageXAtom		= GetDisplay()->RegisterXAtom(kDragMessagesXAtomName);
	itsMailboxXAtom		= GetDisplay()->RegisterXAtom(kDragMailboxesXAtomName);

	itsMailIcon = new JXImage(GetDisplay(), tall_envelopes);
	assert( itsMailIcon != NULL );
	itsMailIcon->ConvertToRemoteStorage();

	itsSelectedMailIcon = new JXImage(GetDisplay(), selected_envelopes);
	assert( itsSelectedMailIcon != NULL );
	itsSelectedMailIcon->ConvertToRemoteStorage();

	itsLockedMailIcon = new JXImage(GetDisplay(), locked_envelopes);
	assert( itsLockedMailIcon != NULL );
	itsLockedMailIcon->ConvertToRemoteStorage();

	itsSelectedFolderIcon = new JXImage(GetDisplay(), selectedfolderIcon_xpm);
	assert( itsSelectedFolderIcon != NULL );
	itsSelectedFolderIcon->ConvertToRemoteStorage();

	itsFolderIcon = new JXImage(GetDisplay(), tall_folder_xpm);
	assert( itsFolderIcon != NULL );
	itsFolderIcon->ConvertToRemoteStorage();

	if (!GetDisplay()->GetCursor(kEnvelopesCursorName, &itsDNDCursor))
		{
		itsDNDCursor =
			GetDisplay()->CreateCustomCursor(kEnvelopesCursorName, kEnvelopesCursor);
		}

	itsMailboxMenu->SetItemImage(kNewMBoxCmd, JXPM(envelopes));
	itsMailboxMenu->SetItemImage(kNewDirCmd, JXPM(folder_xpm));
	itsMailboxMenu->SetItemImage(kUnlockCmd, JXPM(unlock_xpm));

	JCoordinate height = GetDefaultRowHeight();
	height = JMax(JCoordinate(height*kRowHeightFactor), kMinRowHeight);
	SetDefaultRowHeight(height);

	ListenTo(itsTree);
}

/******************************************************************************
 Destructor

 *****************************************************************************/

GMailboxTreeWidget::~GMailboxTreeWidget()
{
	delete itsSelectedMailIcon;
	delete itsLockedMailIcon;
	delete itsSelectedFolderIcon;
	delete itsFolderIcon;
	delete itsMailIcon;
}

/******************************************************************************
 Draw (virtual protected)


 ******************************************************************************/

void
GMailboxTreeWidget::Draw
	(
	JXWindowPainter& p,
	const JRect& rect
	)
{
	JXNamedTreeListWidget::Draw(p, rect);
	if (itsOutsideRoot && itsDraggingFiles)
		{
		p.ResetClipRect();
		if (itsCurrentDndHereIndex == 0)
			{
			JRect crect = GetCellRect(JPoint(2, GetRowCount()));
			crect.bottom -= 2;
			p.Line(0, crect.bottom, crect.right, crect.bottom);
			}
		else
			{
			JRect crect = GetCellRect(JPoint(2, itsCurrentDndHereIndex));
			crect.top++;
			p.Line(0, crect.top, crect.right, crect.top);
			}
		}
}

/******************************************************************************
 Receive (virtual protected)


 ******************************************************************************/

void
GMailboxTreeWidget::Receive
	(
	JBroadcaster*	sender,
	const Message&	message
	)
{
	if (sender == itsMailboxMenu && message.Is(JXMenu::kItemSelected))
		{
		 const JXMenu::ItemSelected* selection =
			dynamic_cast<const JXMenu::ItemSelected*>(&message);
		assert( selection != NULL );
		HandleGMailboxMenu(selection->GetIndex());
		}
	else if (sender == itsMailboxMenu && message.Is(JXMenu::kNeedsUpdate))
		{
		UpdateGMailboxMenu();
		}
	else if (sender == itsEditTask && message.Is(JXTimerTask::kTimerWentOff))
		{
		GetTableSelection().ClearSelection();
		BeginEditing(itsEditCell);
		itsEditTask = NULL;
		}
	else if (sender == GMGetApplication() && message.Is(GMApp::kMailboxOpened))
		{
		// get tree and loop through all children
		// if any match the mailbox name, set their update state to false
		AdjustToTree();
		}
	else if (sender == itsTree && message.Is(GMFileTree::kNodeHasNewMail))
		{
		const GMFileTree::NodeHasNewMail* info =
			dynamic_cast<const GMFileTree::NodeHasNewMail*>(&message);
		assert(info != NULL);
		const JTreeNode* jnode    = info->GetNode();
		const JBoolean hasNewMail = info->HasNewMail();
		JIndex findex;
		if (GetNamedTreeList()->FindNode(jnode, &findex))
			{
			if (hasNewMail)
				{
				SetCellStyle(JPoint(2, findex),
							 JFontStyle(kJTrue, kJFalse, 0, kJFalse));
				}
			else
				{
				SetCellStyle(JPoint(2, findex), JFontStyle());
				}
			}
		}
	JXNamedTreeListWidget::Receive(sender, message);
}

/******************************************************************************
 HandleKeyPress

 ******************************************************************************/

void
GMailboxTreeWidget::HandleKeyPress
	(
	const int key,
	const JXKeyModifiers&   modifiers
	)
{
	JPoint topSelCell;
	JTableSelection& s          = GetTableSelection();
	const JBoolean hadSelection	= s.GetFirstSelectedCell(&topSelCell);
	JPoint oldBoat				= s.GetBoat();

	if (key == kJReturnKey && IsEditing())
		{
		JPoint cell;
		GetEditedCell(&cell);
		JTreeNode* node	= GetTreeList()->GetNode(cell.y);
		JIndex findex;
		if (EndEditing() && GetTreeList()->FindNode(node, &findex))
			{
			s.ClearSelection();
			s.SelectCell(findex, 2);
			TableScrollToCell(JPoint(1, findex));
			}
		ClearIncrementalSearchBuffer();
		}
	else if (key == kJReturnKey && !IsEditing())
		{
		HandleReturn();
		}

	else if (key == kJForwardDeleteKey || key == kJDeleteKey)
		{
		JBoolean okDir;
		JBoolean okFile;
		JBoolean unLock;
		CheckSelectionForMenus(&okDir, &okFile, &unLock);
		if (okDir)
			{
			DeleteSelected();
			}
		}

	else if ((key == kJEscapeKey) &&
			 !IsEditing())
		{
		GetWindow()->GetDirector()->Deactivate();
		}

	else if ((key == kJUpArrow) && !IsEditing())
		{
		if (hadSelection)
			{
			if (modifiers.shift())
				{
				if (s.OKToExtendSelection())
					{
					if (oldBoat.y > 1)
						{
						s.ExtendSelection(JPoint(2, oldBoat.y - 1));
						TableScrollToCell(JPoint(1, oldBoat.y - 1));
						GetWindow()->Update();
						}
					}
				}
			else
				{
				s.ClearSelection();
				JIndex index = topSelCell.y;
				if (index > 1)
					{
					index -= 1;
					}
				s.SelectCell(index, 2);
				s.SetBoat(JPoint(2, index));
				s.SetAnchor(JPoint(2, index));
				TableScrollToCell(JPoint(1, index));
				GetWindow()->Update();
				}
			}
		else
			{
			if (GetRowCount() > 0)
				{
				s.SelectCell(GetRowCount(), 2);
				s.SetBoat(JPoint(2, GetRowCount()));
				s.SetAnchor(JPoint(2, GetRowCount()));
				TableScrollToCell(JPoint(1, GetRowCount()));
				GetWindow()->Update();
				}
			}
		}
	else if ((key == kJDownArrow) && !IsEditing())
		{
		if (hadSelection)
			{
			if (modifiers.shift())
				{
				if (s.OKToExtendSelection())
					{
					if (oldBoat.y < (JCoordinate)GetRowCount())
						{
						s.ExtendSelection(JPoint(2, oldBoat.y + 1));
						GetWindow()->Update();
						TableScrollToCell(JPoint(1, oldBoat.y + 1));
						}
					}
				}
			else
				{
				s.ClearSelection();
				JIndex index = topSelCell.y;
				if (index < GetRowCount())
					{
					index += 1;
					}
				s.SelectCell(index, 2);
				s.SetBoat(JPoint(2, index));
				s.SetAnchor(JPoint(2, index));
				TableScrollToCell(JPoint(1, index));
				GetWindow()->Update();
				}
			}
		else
			{
			if (GetRowCount() > 0)
				{
				s.SelectCell(1, 2);
				s.SetBoat(JPoint(2, 1));
				s.SetAnchor(JPoint(2, 1));
				TableScrollToCell(JPoint(1, 1));
				GetWindow()->Update();
				}
			}
		}
	else
		{
		JXNamedTreeListWidget::HandleKeyPress(key, modifiers);
		}
}

/******************************************************************************
 UpdateGMailboxMenu


 ******************************************************************************/

void
GMailboxTreeWidget::UpdateGMailboxMenu()
{
	JTableSelection& s = GetTableSelection();
	JSize count = s.GetSelectedCellCount();
	if (count == 0)
		{
		itsMailboxMenu->DisableItem(kDeleteCmd);
		itsMailboxMenu->DisableItem(kRemoveCmd);
		itsMailboxMenu->DisableItem(kUnlockCmd);
		itsMailboxMenu->DisableItem(kOpenSelMBoxCmd);
		return;
		}
	itsMailboxMenu->EnableItem(kOpenSelMBoxCmd);
	JBoolean okDir;
	JBoolean okFile;
	JBoolean unLock;
	CheckSelectionForMenus(&okDir, &okFile, &unLock);
	if (okFile)
		{
		itsMailboxMenu->EnableItem(kDeleteCmd);
		}
	else
		{
		itsMailboxMenu->DisableItem(kDeleteCmd);
		}
	if (okDir)
		{
		itsMailboxMenu->EnableItem(kRemoveCmd);
		}
	else
		{
		itsMailboxMenu->DisableItem(kRemoveCmd);
		}
	if (unLock && okFile)
		{
		itsMailboxMenu->EnableItem(kUnlockCmd);
		}
	else
		{
		itsMailboxMenu->DisableItem(kUnlockCmd);
		}
}

/******************************************************************************
 HandleGMailboxMenu

 ******************************************************************************/

void
GMailboxTreeWidget::HandleGMailboxMenu
	(
	const JIndex index
	)
{
	if (index == kNewMBoxCmd)
		{
		CreateMailBox();
		}
	else if (index == kNewDirCmd)
		{
		CreateDirectory();
		}
	else if (index == kAddMBoxCmd)
		{
		JPtrArray<JString> fullNameList(JPtrArrayT::kForgetAll);
		if (GMGetMailboxCSF()->ChooseFiles("Select the mailboxes to add", "", &fullNameList))
			{
			JSize count = fullNameList.GetElementCount();
			for (JSize i = 1; i <= count; i++)
				{
				AddFile(*(fullNameList.NthElement(i)));
				}

//			JTreeNode* base = itsTree->GetRoot();
//			JNamedTreeNode* parent =
//				dynamic_cast<JNamedTreeNode*>(base);
//			assert(parent != NULL);
//			JSize count = fullNameList.GetElementCount();
//			for (JSize i = 1; i <= count; i++)
//				{
//				JDirEntry* entry = new JDirEntry(*(fullNameList.NthElement(i)));
//				assert(entry != NULL);
//				GMailFileTreeNode* node =
//					new GMailFileTreeNode(itsTree, entry, parent, entry->GetName(),kJFalse);
//				assert(node != NULL);
//				}
			}
		}
	else if (index == kAddDirCmd)
		{
		JString fullname;
		JBoolean ok = JXGetChooseSaveFile()->ChooseRPath("Select directory to add:", "", "", &fullname);
		if (ok)
			{
			AddDirectory(fullname);
			}
		}
	else if (index == kOpenSelMBoxCmd)
		{
		HandleReturn();
		}
	else if (index == kRemoveCmd)
		{
		DeleteSelected();
		}
	else if (index == kDeleteCmd)
		{
		JTableSelection& s = GetTableSelection();
		JBoolean ok = JGetUserNotification()->AskUserYes("Are you sure you want to delete the selected mailboxes from the file system?");
		if (ok)
			{
			JTableSelectionIterator iter(&s);
			JPoint cell;
			iter.MoveTo(kJIteratorStartAtEnd, cell);
			while(iter.Prev(&cell))
				{
				JTreeNode* jnode		= GetNamedTreeList()->GetNode(cell.y);
				JFSFileTreeNode* node	= dynamic_cast<JFSFileTreeNode*>(jnode);
				JDirEntry* entry		= node->GetDirEntry();
				JError err = JRemoveFile(entry->GetFullName());
				if (err.OK())
					{
					delete node;
					}
				else
					{
					JGetUserNotification()->ReportError("Unable to delete file.");
					}
				}
			}
		}
	else if (index == kUnlockCmd)
		{
		JTableSelection& s = GetTableSelection();
		JBoolean ok = JGetUserNotification()->AskUserYes("Are you sure you want to unlock the selected mailboxes?");
		if (ok)
			{
			JTableSelectionIterator iter(&s);
			JPoint cell;
			iter.MoveTo(kJIteratorStartAtEnd, cell);
			while(iter.Prev(&cell))
				{
				JTreeNode* jnode		= GetNamedTreeList()->GetNode(cell.y);
				JFSFileTreeNode* node	= dynamic_cast<JFSFileTreeNode*>(jnode);
				JDirEntry* entry		= node->GetDirEntry();
				GUnlockFile(entry->GetFullName());
				}
			}
		}
}

/******************************************************************************
 HandleMouseHere (virtual protected)

 ******************************************************************************/

void
GMailboxTreeWidget::HandleMouseHere
	(
	const JPoint&			pt,
	const JXKeyModifiers&	modifiers
	)
{
	if (itsEditTask != NULL && JMouseMoved(itsDownPt, pt))
		{
		GetTableSelection().ClearSelection();
		BeginEditing(itsEditCell);
		delete itsEditTask;
		itsEditTask = NULL;
		}
}

/******************************************************************************
 HandleMouseDown

 ******************************************************************************/

void
GMailboxTreeWidget::HandleMouseDown
	(
	const JPoint&			pt,
	const JXMouseButton	button,
	const JSize			clickCount,
	const JXButtonStates&	buttonStates,
	const JXKeyModifiers&	modifiers
	)
{
	if (itsEditTask != NULL)
		{
		delete itsEditTask;
		itsEditTask	= NULL;
		}
	ClearIncrementalSearchBuffer();

	if (IsEditing())
		{
		EndEditing();
		}
	itsDownInCell		= kJFalse;
	itsWaitingToEdit	= kJFalse;
	itsDownPt			= pt;
	itsWaitingToEdit	= kJFalse;
	JTableSelection& s = GetTableSelection();

	JPoint cell;
	JXNamedTreeListWidget::NodePart part;
	if (GetNode(pt, &cell, &part))
		{
		JIndex index			= cell.y;
		const JPoint newBoat	= JPoint(2, index);
		const JPoint newAnchor	= JPoint(2, index);
		if (part == JXNamedTreeListWidget::kInText &&
			!modifiers.shift() &&
			!modifiers.meta() && !modifiers.control() &&
			button == kJXLeftButton && clickCount == 1)
			{
			itsWaitingToEdit	= kJTrue;
			itsEditCell			= cell;
			}

		if ((part == JXNamedTreeListWidget::kInImage))
			{
			itsDownInCell = kJTrue;
			}
		if (clickCount == 2 && !IsEditing() &&
			(part == JXNamedTreeListWidget::kInText ||
			 part == JXNamedTreeListWidget::kInImage ||
			 part == JXNamedTreeListWidget::kAfterText))
			{
			if (button == kJXLeftButton)
				{
				s.ClearSelection();
				s.SelectCell(index, 2);
				s.SetBoat(newBoat);
				s.SetAnchor(newAnchor);
				GetWindow()->Update();
				OpenMailbox(index);
				}
			}
		else if (part == JXNamedTreeListWidget::kInImage ||
				 part == JXNamedTreeListWidget::kInText ||
				 part == JXNamedTreeListWidget::kAfterText)
			{
			if ((button == kJXLeftButton && modifiers.shift()) ||
				(button == kJXRightButton))
				{
				if (s.OKToExtendSelection())
					{
					s.ExtendSelection(newBoat);
					GetWindow()->Update();
					}
				}
			else if (button == kJXLeftButton)
				{
				if (modifiers.control())
					{
					if (s.IsSelected(index, 2))
						{
						s.SelectCell(index, 2, kJFalse);
						s.ClearBoat();
						s.ClearAnchor();
						GetWindow()->Update();
						}
					else
						{
						s.SelectCell(index, 2, kJTrue);
						s.SetBoat(newBoat);
						s.SetAnchor(newAnchor);
						GetWindow()->Update();
						}
					}
				else if (!s.IsSelected(index, 2))
					{
					s.ClearSelection();
					s.SelectCell(index, 2);
					s.SetBoat(newBoat);
					s.SetAnchor(newAnchor);
					GetWindow()->Update();
					}
				}
			}
		else
			{
			s.ClearSelection();
			}
		}
	else
		{
		itsDownInCell = kJFalse;
		s.ClearSelection();
		}
	JXNamedTreeListWidget::HandleMouseDown(pt, button,
		clickCount, buttonStates, modifiers);
}

/******************************************************************************
 HandleMouseDrag (virtual protected)

 ******************************************************************************/

void
GMailboxTreeWidget::HandleMouseDrag
	(
	const JPoint&			pt,
	const JXButtonStates&	buttonStates,
	const JXKeyModifiers&	modifiers
	)
{
	JPoint cell;
	JXNamedTreeListWidget::NodePart part;
	if (GetNode(pt, &cell, &part) && itsDownInCell)
		{
		JPoint p = itsDownPt - pt;
		if (JMouseMoved(itsDownPt, pt))
			{
			itsWaitingToEdit = kJFalse;
			if (OkToDND())
				{
				GMailboxDragData* data =
					new GMailboxDragData(this, kDNDClassID);
				assert(data != NULL);
				BeginDND(pt, buttonStates, modifiers, data);
				}
			}
		}

	JXNamedTreeListWidget::HandleMouseDrag(pt,buttonStates,modifiers);
}

/******************************************************************************
 HandleMouseUp (virtual protected)

 ******************************************************************************/

void
GMailboxTreeWidget::HandleMouseUp
	(
	const JPoint& pt,
	const JXMouseButton button,
	const JXButtonStates& buttonStates,
	const JXKeyModifiers& modifiers
	)
{
	JPoint cell;
	if (GetCell(pt, &cell) && (itsWaitingToEdit))
		{
		JXNamedTreeListWidget::HandleMouseUp(pt, button, buttonStates, modifiers);
//		GetTableSelection().ClearSelection();
//		BeginEditing(cell);
		if (cell == itsEditCell)
			{
			itsEditTask = new JXTimerTask(kWaitForEditDelay, kJTrue);
			assert(itsEditTask != NULL);
			itsEditTask->Start();
			ListenTo(itsEditTask);
			}
		}
	else
		{
		JXNamedTreeListWidget::HandleMouseUp(pt, button, buttonStates, modifiers);
		}
}

/******************************************************************************
 HandleDNDResponse (virtual protected)

 ******************************************************************************/

void
GMailboxTreeWidget::HandleDNDResponse
	(
	const JXContainer*  target,
	const JBoolean		dropAccepted,
	const Atom			action
	)
{
	DisplayCursor(itsDNDCursor);
}

/******************************************************************************
 HandleDNDHere

 ******************************************************************************/

void
GMailboxTreeWidget::HandleDNDHere
	(
	const JPoint&	pt,
	const JXWidget* source
	)
{
	JIndex oldIndex = itsCurrentDndHereIndex;
	if (oldIndex != 0)
		{
		JTreeNode* jnode = GetNamedTreeList()->GetNode(oldIndex);
		GMailFileTreeNode* node =
			dynamic_cast<GMailFileTreeNode*>(jnode);
		GUnlockFile(node->GetDirEntry()->GetFullName());
		TableRefreshRow(oldIndex);
		}
	else if (itsOutsideRoot)
		{
		TableRefreshRow(GetRowCount());
		}

	JPoint cell;
	JXNamedTreeListWidget::NodePart part;
	if (GetNode(pt, &cell, &part))
		{
		itsCurrentDndHereIndex = ClosestSelection(pt, cell.y, part);
		TableRefreshRow(itsCurrentDndHereIndex);
		}
	else
		{
		itsCurrentDndHereIndex = ClosestSelection(pt, 0, part);
		if (itsCurrentDndHereIndex == 0)
			{
			JSize count = GetRowCount();
			if (count > 0)
				{
				TableRefreshRow(count);
				}
			}
		}
}

/******************************************************************************
 HandleDNDLeave

 ******************************************************************************/

void
GMailboxTreeWidget::HandleDNDLeave()
{
	JIndex oldIndex		= itsCurrentDndHereIndex;
	itsCurrentDndHereIndex	= 0;
	if (oldIndex != 0)
		{
		JTreeNode* jnode = GetNamedTreeList()->GetNode(oldIndex);
		GMailFileTreeNode* node =
			dynamic_cast<GMailFileTreeNode*>(jnode);
		GUnlockFile(node->GetDirEntry()->GetFullName());
		TableRefreshRow(oldIndex);
		}
	else if (itsOutsideRoot)
		{
		TableRefreshRow(GetRowCount());
		}
	itsDraggingFiles		= kJFalse;
	itsOutsideRoot			= kJFalse;
}

/******************************************************************************
 HandleDNDDrop

 ******************************************************************************/

void
GMailboxTreeWidget::HandleDNDDrop
	(
	const JPoint&		pt,
	const JArray<Atom>& typeList,
	const Atom			action,
	const Time			time,
	const JXWidget*	source
	)
{
	JBoolean dropOnSelf = JI2B(source == this);

	Atom realAction = action;
	JXDNDManager* dndMgr  = GetDNDManager();
	if (action == dndMgr->GetDNDActionAskXAtom())
		{
		JArray<Atom> actionList;
		JPtrArray<JString> descriptionList(JPtrArrayT::kDeleteAll);
		if (!dndMgr->GetAskActions(&actionList, &descriptionList))
			{
			realAction = dndMgr->GetDNDActionMoveXAtom();;
			}
		else if (!dndMgr->ChooseDropAction(actionList, descriptionList,
										   &realAction))
			{
			return;
			}
		}
	JPoint cell;
	JIndex oldIndex = itsCurrentDndHereIndex;
	itsCurrentDndHereIndex = 0;
	if (oldIndex != 0)
		{
		TableRefreshRow(oldIndex);
		}
//	else if (!dropOnSelf)
//		{
//		return;
//		}
	if (GetNamedTreeList()->GetElementCount() < oldIndex)
		{
		return;
		}

	if (source != this)
		{
		dropOnSelf = kJFalse;
		}

	if (dropOnSelf)
		{
		JTableSelection& s = GetTableSelection();
		JTableSelectionIterator iter(&s);
		if (itsOutsideRoot)
			{
			JTreeNode* base = itsTree->GetRoot();
			JTreeNode* beforenode = NULL;
			if (oldIndex != 0)
				{
				beforenode = GetNamedTreeList()->GetNode(oldIndex);
				}
			while (iter.Next(&cell))
				{
				JTreeNode* jnode = GetNamedTreeList()->GetNode(cell.y);
				GMailFileTreeNode* dnode =
					dynamic_cast<GMailFileTreeNode*>(jnode);
				assert(dnode != NULL);
				if (oldIndex == 0)
					{
					if (dnode->GetDepth() == 1)
						{
						base->Append(jnode);
						}
					else
						{
						if (dnode->IsOpenable())
							{
							AddDirectory(dnode->GetDirEntry()->GetFullName());
							}
						else
							{
							AddFile(dnode->GetDirEntry()->GetFullName());
							}
						}
					}
				else
					{
					if (beforenode != jnode)
						{
						if (dnode->GetDepth() == 1)
							{
							base->InsertBefore(beforenode, jnode);
							}
						else
							{
							JDirEntry* entry = new JDirEntry(*(dnode->GetDirEntry()));
							assert(entry != NULL);
							GMailFileTreeNode* newnode =
								new GMailFileTreeNode(entry);
							assert(newnode != NULL);
							base->InsertBefore(beforenode, newnode);
							}
						}
					}
				}
			}
		else
			{
			JTreeNode* node = GetNamedTreeList()->GetNode(oldIndex);
			GMailFileTreeNode* mnode =
				dynamic_cast<GMailFileTreeNode*>(node);
			assert(mnode != NULL);
			if (mnode->IsOpenable())
				{
				JString dir = mnode->GetDirEntry()->GetFullName();
				JAppendDirSeparator(&dir);
				JBoolean dropsuccess = kJTrue;
				while (iter.Next(&cell))
					{
					JTreeNode* jnode = GetNamedTreeList()->GetNode(cell.y);
					GMailFileTreeNode* dnode =
						dynamic_cast<GMailFileTreeNode*>(jnode);
					assert(dnode != NULL);
					JString fullname = dnode->GetDirEntry()->GetFullName();
					JString newname;
					if (fullname != "/")
						{
						if (fullname.EndsWith("/"))
							{
							fullname.RemoveSubstring(fullname.GetLength(), fullname.GetLength());
							}
						JString path;
						JString name;
						JSplitPathAndName(fullname, &path, &name);
						newname = dir + name;
						if (newname != fullname)
							{
							JError err = JRenameFile(fullname, newname);
							if (err.OK())
								{
								delete dnode;
								}
							else
								{
								dropsuccess = kJFalse;
								}
							}
						}
					}
				if (!dropsuccess)
					{
					JGetUserNotification()->ReportError("Some of the files could not be moved.");
					}
				}
			else
				{
				cout << "This shouldn't have happened!" << endl;
				}
			}
		}
	else
		{
		JString mailfile;
		GMailFileTreeNode* mnode;
		JBoolean mailboxOk		= kJTrue;
		JBoolean newMail		= kJFalse;
		JBoolean createAndAdd	= kJFalse;

		if (oldIndex == 0)
			{
			newMail		= kJTrue;
			createAndAdd	= kJTrue;
			}
		else
			{
			JTreeNode* node = GetNamedTreeList()->GetNode(oldIndex);
			mnode = dynamic_cast<GMailFileTreeNode*>(node);
			assert(mnode != NULL);
			mailfile = mnode->GetDirEntry()->GetFullName();
			if (node->IsOpenable())
				{
				GetTreeList()->Open(node);
				newMail = kJTrue;
				JAppendDirSeparator(&mailfile);
				}
			}

		if (newMail)
			{
			if (createAndAdd)
				{
				mailfile += "Untitled";
				JString newfile;
				if (JXGetChooseSaveFile()->SaveFile("Select a mailbox name", "", mailfile, &newfile))
					{
					mailfile = newfile;
					if (GMGetApplication()->NewMailbox(mailfile, kJFalse))
						{
						AddFile(mailfile);
						}
					else
						{
						mailboxOk = kJFalse;
						}
					}
				else
					{
					mailboxOk = kJFalse;
					}
				}
			else
				{
				JString tempName = mailfile + "Untitled";
				JIndex number = 1;
				while (JNameUsed(tempName))
					{
					tempName = mailfile + "Untitled" + JString(number, JString::kBase10);
					number++;
					}
				mailfile	= tempName;
				if (GMGetApplication()->NewMailbox(mailfile, kJFalse))
					{
					JDirEntry* entry = new JDirEntry(mailfile);
					assert(entry != NULL);
					GMailFileTreeNode* fnode =
						new GMailFileTreeNode(entry);
					assert(fnode != NULL);
					InsertNewNode(mnode, fnode);
					}
				else
					{
					mailboxOk = kJFalse;
					}
				}
			}

		unsigned char* data = NULL;
		JSize dataLength;
		Atom returnType;
		JXSelectionManager* selManager = GetSelectionManager();
		JXSelectionManager::DeleteMethod delMethod;
		const Atom dndName = GetDNDManager()->GetDNDSelectionName();
		if (mailboxOk &&
			selManager->GetData(dndName, time, itsMessageXAtom,
								&returnType, &data, &dataLength, &delMethod))
			{
			std::istrstream selis(reinterpret_cast<char*>(data), dataLength);
			JPtrArray<GMessageHeader> list(JPtrArrayT::kDeleteAll);
			JString mbox;
			selis >> mbox;
			int count;
			selis >> count;
			for (int index = 1; index <= count; index++)
				{
				GMessageHeader* header = new GMessageHeader();
				assert(header != NULL);
				selis >> *header;
				list.Append(header);
				}
//			GBlockUntilFileUnlocked(mailfile);
//			if (!GLockFile(mailfile))
//				{
//				selManager->DeleteData(&data, delMethod);
//				return;
//				}

			JBoolean okToMove = kJTrue;

			JString path, name;
			JSplitPathAndName(mailfile, &path, &name);
			JString tempname;
			JError err = JCreateTempFile(path, NULL, &tempname);
			if (!err.OK())
				{
				okToMove = kJFalse;
				err      = JCreateTempFile(&tempname);
				}

			if (!err.OK())
				{
				err.ReportIfError();
				}
			else
				{
				JBoolean first = kJTrue;
				mode_t perms, perms2;

				if (!(JGetPermissions(mailfile, &perms)).OK())
					{
					perms = 0600;
					}
				if (!(JGetPermissions(mbox, &perms2)).OK())
					{
					perms2 = 0600;
					}
				ifstream is(mailfile);
				ifstream mboxis(mbox);
				ofstream os(tempname);

				JSize lcount = list.GetElementCount();
				JSize index;
				JString temp;
				JDirEntry entry(mailfile);
				JSize size = entry.GetSize();
				temp.Read(is, size);
//				JReadAll(is, &temp);
				if (size > 0 && !temp.EndsWith("\n\n"))
					{
					temp.Append("\n\n");
					}
				temp.Print(os);
				for (index = 1; index <= lcount; index++)
					{
					GMessageHeader* header = list.NthElement(index);
					GSaveMessage(mboxis, os, header, kJTrue, kJFalse);
					}
				is.close();
				os.close();
				mboxis.close();

				JString cmd;
				if (okToMove)
					{
					cmd = "mv -f \"" + tempname + "\" \"" + mailfile + "\"";
					}
				else
					{
					cmd = "cp -f \"" + tempname + "\" \"" + mailfile + "\"";
					}
				JExecute(cmd, NULL);
				if (!okToMove)
					{
					JRemoveFile(tempname);
					}
				// open the mailbox to set its access time
				ifstream accIs(mailfile);
				accIs.close();
				}

			GUnlockFile(mailfile);
			GUnlockFile(mbox);
			selManager->DeleteData(&data, delMethod);
			if (err.OK() && realAction == dndMgr->GetDNDActionMoveXAtom())
				{
				selManager->SendDeleteRequest(dndName, time);
				}
			}
		}
	itsDraggingFiles	= kJFalse;
	itsOutsideRoot		= kJFalse;
}

/******************************************************************************
 WillAcceptDrop

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::WillAcceptDrop
	(
	const JArray<Atom>& typeList,
	Atom*				action,
	const JPoint&		pt,
	const Time			time,
	const JXWidget*		source
	)
{
	JBoolean found				= kJFalse;
	const JSize typeCount		= typeList.GetElementCount();
	for (JSize i=1; i<=typeCount; i++)
		{
		Atom type				= typeList.GetElement(i);
		if (type == itsMessageXAtom)
			{
			found				= kJTrue;
			itsDraggingFiles	= kJFalse;
			}
		else if (type == itsMailboxXAtom && source == this)
			{
			found				= kJTrue;
			itsDraggingFiles	= kJTrue;
			}
		}
	return found;
}

/******************************************************************************
 ConvertSelection

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::ConvertSelection
	(
	const Atom		name,
	const Atom		requestType,
	Atom*			returnType,
	unsigned char**	data,
	JSize*			dataLength,
	JSize*			bitsPerBlock
	)
{
/*	*bitsPerBlock = 8;
	ostrstream os;

	JTableSelection& selection = GetTableSelection();
	JTableSelectionIterator* iter =
		new JTableSelectionIterator(&selection);

	JPoint cell;
	if (itsDraggingBranch)
		{
		JSize count = 0;
		while(iter->Next(&cell))
			{
			JTreeNode* jnode = GetNamedTreeList()->GetNode(cell.y);
			count += jnode->GetChildCount();
			}
		os << count;
		iter->MoveTo(kIteratorStartAtBeginning, cell);
		while(iter->Next(&cell))
			{
			JTreeNode* jnode = GetNamedTreeList()->GetNode(cell.y);
			JSize count = jnode->GetChildCount();
			for (JSize j = 1; j <= count; j++)
				{
				JTreeNode* child = jnode->GetChild(j);
				GSimpleFileTreeNode* node = dynamic_cast<GSimpleFileTreeNode*>(child);
				assert(node != NULL);
				node->WriteFileName(os);
				}

			}
		}
	else
		{
		os << selection.GetSelectedCellCount();
		while(iter->Next(&cell))
			{
			JTreeNode* jnode = GetNamedTreeList()->GetNode(cell.y);
			GMailboxTreeNode* node = dynamic_cast<GMailboxTreeNode*>(jnode);
			assert(node != NULL);
			node->WriteFileName(os);
			}
		}

	os << ends;
	delete iter;
	*dataLength = strlen(os.str());
	*data = new unsigned char[ *dataLength ];
	assert (*data != NULL);
	memcpy(*data, os.str(), *dataLength);
	return kJTrue;
*/
	return kJFalse;
}

/******************************************************************************
 AddFile

 ******************************************************************************/

void
GMailboxTreeWidget::AddFile
	(
	const JString& path,
	const JString& file
	)
{
	AddFile(JCombinePathAndName(path, file));
}

/******************************************************************************
 AddFile

 ******************************************************************************/

void
GMailboxTreeWidget::AddFile
	(
	const JCharacter* fullname
	)
{
	if (AlreadyPresent(fullname))
		{
		return;
		}
		
	JTreeNode* base = itsTree->GetRoot();
	JNamedTreeNode* parent =
		dynamic_cast<JNamedTreeNode*>(base);
	assert(parent != NULL);
	JDirEntry* entry = new JDirEntry(fullname);
	assert(entry != NULL);
	JString pattern(GMGetMailRegexStr());
	if (MatchesCookie(pattern, *entry))
		{
		GMailFileTreeNode* node =
			new GMailFileTreeNode(entry);
		assert(node != NULL);
		parent->Append(node);
		GMailboxTreeDir* dir =
			dynamic_cast<GMailboxTreeDir*>(GetWindow()->GetDirector());
		assert(dir != NULL);
		dir->BroadcastMailTreeChanged();
		}
	ClearIncrementalSearchBuffer();
}


/******************************************************************************
 AddDirectory

 ******************************************************************************/

void
GMailboxTreeWidget::AddDirectory
	(
	const JCharacter* 	path,
	const JBoolean 		openDir
	)
{
	if (AlreadyPresent(path))
		{
		return;
		}

	JTreeNode* base = itsTree->GetRoot();
	JNamedTreeNode* parent =
		dynamic_cast<JNamedTreeNode*>(base);
	assert(parent != NULL);
	JDirEntry* entry = new JDirEntry(path);
	assert(entry != NULL);
	GMailFileTreeNode* node =
		new GMailFileTreeNode(entry);
	assert(node != NULL);
	parent->Append(node);
	GMailboxTreeDir* dir =
		dynamic_cast<GMailboxTreeDir*>(GetWindow()->GetDirector());
	assert(dir != NULL);

	GetTreeList()->Open(node);
	
	dir->BroadcastMailTreeChanged();
	if (openDir)
		{
		dir->Activate();
		}	
	ClearIncrementalSearchBuffer();
}

/******************************************************************************
 GetImage

******************************************************************************/

JBoolean
GMailboxTreeWidget::GetImage
	(
	const JIndex	index,
	const JXImage** image
	)
	const
{
	const JTreeNode* jnode = GetNamedTreeList()->GetNode(index);
	if (jnode->IsOpenable())
		{
		if (index == itsCurrentDndHereIndex && !itsOutsideRoot)
			{
			*image = itsSelectedFolderIcon;
			return kJTrue;
			}
		*image = itsFolderIcon;
		return kJTrue;
		}
	if (index == itsCurrentDndHereIndex && !itsOutsideRoot)
		{
		*image = itsSelectedMailIcon;
		return kJTrue;
		}
	const GMailFileTreeNode* node =
		dynamic_cast<const GMailFileTreeNode*>(jnode);
	if (GFileLocked(node->GetDirEntry()->GetFullName()))
		{
		*image = itsLockedMailIcon;
		return kJTrue;
		}
	*image = itsMailIcon;
	return kJTrue;
}

/******************************************************************************
 ReadPrefs (public)

 ******************************************************************************/

void
GMailboxTreeWidget::ReadPrefs
	(
	istream& input
	)
{
	JCoordinate id;
	input >> id;
	assert(id <= kCurrentPrefsVersion);
	JSize count;
	input >> count;
	for (JSize i = 1; i <= count; i++)
		{
		JString dir;
		input >> dir;
		if (JDirectoryExists(dir))
			{
			AddDirectory(dir, kJFalse);
			}
		else if (JFileExists(dir))
			{
			AddFile(dir);
			}
		}
	input >> count;
	for (JSize i = 1; i <= count; i++)
		{
		JString dir;
		input >> dir;
		JBoolean found = kJFalse;
		JSize count = GetNamedTreeList()->GetElementCount();
		JIndex index = 1;
		while (!found && (index <= count))
			{
			JTreeNode* jnode = GetNamedTreeList()->GetNode(index);
			GMailFileTreeNode* node = dynamic_cast<GMailFileTreeNode*>(jnode);
			assert(node != NULL);
			if (node->GetDirEntry()->GetFullName() == dir)
				{
				found = kJTrue;
				if (jnode->IsOpenable())
					{
					GetNamedTreeList()->Open(index);
					}
				}
			index ++;
			}
		}
}

/******************************************************************************
 WritePrefs (public)

 ******************************************************************************/

void
GMailboxTreeWidget::WritePrefs
	(
	ostream& output
	)
	const
{
	output << kCurrentPrefsVersion << ' ';
	JTreeNode* base = itsTree->GetRoot();
	JSize count = base->GetChildCount();
	output << count << ' ';
	for (JSize i = 1; i <= count; i++)
		{
		JTreeNode* child = base->GetChild(i);
		GMailFileTreeNode* node =
		dynamic_cast<GMailFileTreeNode*>(child);
		assert(node != NULL);
		output << node->GetDirEntry()->GetFullName() << ' ';
		}
	count = GetNamedTreeList()->GetElementCount();
	JSize realcount = 0;
	for (JSize i = 1; i <= count; i++)
		{
		if (GetNamedTreeList()->IsOpen(i))
			{
			realcount++;
			}
		}
	output << realcount << ' ';
	for (JSize i = 1; i <= count; i++)
		{
		if (GetNamedTreeList()->IsOpen(i))
			{
			const JTreeNode* child = GetNamedTreeList()->GetNode(i);
			const GMailFileTreeNode* node =
				dynamic_cast<const GMailFileTreeNode*>(child);
			assert(node != NULL);
			output << node->GetDirEntry()->GetFullName() << ' ';
			}
		}

}

/******************************************************************************
 Update (public)

 ******************************************************************************/

void
GMailboxTreeWidget::Update()
{
	JTreeNode* base  = itsTree->GetRoot();
	JSize count	 = base->GetChildCount();
	JBoolean changed = kJFalse;
	for (JSize i = 1; i <= count; i++)
		{
		JTreeNode* jchild = base->GetChild(i);
		GMailFileTreeNode* child	= dynamic_cast<GMailFileTreeNode*>(jchild);
		assert(child != NULL);
		changed		 = child->Update(kJFalse);
		}
//	if (changed)
//		{
		TableRefresh();
//		}
}

/******************************************************************************
 OpenMailbox (private)

 ******************************************************************************/

void
GMailboxTreeWidget::OpenMailbox
	(
	const JIndex index
	)
{
	JTreeNode* node = GetNamedTreeList()->GetNode(index);
	if (!node->IsOpenable())
		{
		GMailFileTreeNode* mnode =
			dynamic_cast<GMailFileTreeNode*>(node);
		assert(mnode != NULL);

		GMGetApplication()->OpenMailbox(mnode->GetDirEntry()->GetFullName());
		}
	ClearIncrementalSearchBuffer();
}

/******************************************************************************
ClosestSelection (private)

 ******************************************************************************/

JIndex
GMailboxTreeWidget::ClosestSelection
	(
	const JPoint&							pt,
	const JIndex							index,
	const JXNamedTreeListWidget::NodePart	part
	)
{
	JBoolean inNode = kJFalse;
	if ((part == JXNamedTreeListWidget::kInText) ||
		(part == JXNamedTreeListWidget::kInImage))
		{
		inNode = kJTrue;
		}
	itsOutsideRoot = kJFalse;
	if (index == 0)
		{
		if (itsDraggingFiles)
			{
			itsOutsideRoot = kJTrue;
			return 0;
			}
		return LastWritableTopLevel();
		}
	JTreeNode* jnode = GetNamedTreeList()->GetNode(index);
	GMailFileTreeNode* node =
		dynamic_cast<GMailFileTreeNode*>(jnode);
	if (itsDraggingFiles)
		{
		if (node->GetDepth() > 1)
			{
			if (inNode && node->IsOpenable() && NodeIsWritable(node))
				{
				return index;
				}
			JIndex tindex = WritableParent(node);
			if (tindex == 0)
				{
				itsOutsideRoot = kJTrue;
				}
			return tindex;
			}
		if (inNode)
			{
			if (node->IsOpenable() && NodeIsWritable(node))
				{
				return index;
				}
			itsOutsideRoot = kJTrue;
			return index;
			}
		itsOutsideRoot = kJTrue;
		return index;
		}
	if (GFileLocked(node->GetDirEntry()->GetFullName()))
		{
		return WritableParent(node);
		}
	if (!inNode)
		{
		if (node->GetDepth() > 1)
			{
			return WritableParent(node);
			}
		if (NodeIsWritable(node) && 
			GLockFile(node->GetDirEntry()->GetFullName()))
			{
			return index;
			}
		return 0;
		}
	if (NodeIsWritable(node) && 
		GLockFile(node->GetDirEntry()->GetFullName()))
		{
		return index;
		}
	return 0;
}

/******************************************************************************
 LastWritableTopLevel (private)

 ******************************************************************************/

JIndex
GMailboxTreeWidget::LastWritableTopLevel()
{
	JTreeNode* base = itsTree->GetRoot();
	JSize count = base->GetChildCount();
	if (count == 0)
		{
		return 0;
		}
	for (JSize i = count; i >=1 ; i--)
		{
		JTreeNode* jnode = base->GetChild(i);
		GMailFileTreeNode* node =
			dynamic_cast<GMailFileTreeNode*>(jnode);
		if (NodeIsWritable(node))
			{
			JIndex findex;
			if (GetNamedTreeList()->FindNode(node, &findex))
				{
				return findex;
				}
			}
		}
	return 0;
}

/******************************************************************************
 WritableParent (private)

 ******************************************************************************/

JIndex
GMailboxTreeWidget::WritableParent
	(
	GMailFileTreeNode* node
	)
{
	if (node->GetDepth() == 1)
		{
		return 0;
		}
	JTreeNode* jparent = node->GetParent();
	GMailFileTreeNode* parent =
		dynamic_cast<GMailFileTreeNode*>(jparent);
	if (JDirectoryWritable(parent->GetDirEntry()->GetFullName()))
		{
			JIndex findex;
			if (GetNamedTreeList()->FindNode(parent, &findex))
				{
				return findex;
				}
			return 0;
		}
	else
		{
		return WritableParent(parent);
		}
}

/******************************************************************************
 NodeIsWritable (private)

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::NodeIsWritable
	(
	GMailFileTreeNode* node
	)
{
	if (node->IsOpenable() && JDirectoryWritable(node->GetDirEntry()->GetFullName()))
		{
		return kJTrue;
		}
	if (!node->IsOpenable() && JFileWritable(node->GetDirEntry()->GetFullName()))
		{
		return kJTrue;
		}
	return kJFalse;
}

/******************************************************************************
 OkToDND (private)

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::OkToDND()
{
	return kJTrue;
}

/******************************************************************************
 NewNameOK (virtual protected)

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::ExtractInputData
	(
	const JPoint& cell
	)
{
	JXInputField* input;
	JBoolean ok = GetXInputField(&input);
	assert(ok);
	JString newName = input->GetText();
	JIndex index = cell.y;
	JTreeNode* jnode = GetNamedTreeList()->GetNode(index);
	GMailFileTreeNode* node =
		dynamic_cast<GMailFileTreeNode*>(jnode);
	assert(node != NULL);
	if (newName == node->GetName())
		{
		return kJTrue;
		}
	JError err = node->Rename(newName);
	if (err.OK())
		{
		if (node->GetDepth() > 1)
			{
			JTreeNode* jparent = node->GetParent();
			GMailFileTreeNode* parent =
				dynamic_cast<GMailFileTreeNode*>(jparent);
			parent->SortChildren();
//			parent->Remove(node);
//			parent->InsertSorted(node);
			}
		return kJTrue;
		}
	else
		{
		err.ReportIfError();
		}
	return kJFalse;
}

/******************************************************************************
 DeleteSelected (private)

 ******************************************************************************/

void
GMailboxTreeWidget::DeleteSelected()
{
	JTableSelection& s = GetTableSelection();
	JTableSelectionIterator iter(&s);
	JPoint cell;
	JTreeNode* base = itsTree->GetRoot();
	while (iter.Next(&cell))
		{
		JTreeNode* node = GetNamedTreeList()->GetNode(cell.y);
		base->Remove(node);
		delete node;
		}
	ClearIncrementalSearchBuffer();
}

/******************************************************************************
 IsEditable (virtual)

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::IsEditable
	(
	const JPoint& cell
	)
	const
{
	const JTreeNode* jnode = GetNamedTreeList()->GetNode(cell.y);
	const JNamedTreeNode* nnode =
		dynamic_cast<const JNamedTreeNode*>(jnode);
	assert(nnode != NULL);
	if (cell.x == 2)
		{
		return kJTrue;
		}
	return kJFalse;

}

/******************************************************************************
 CheckSelectionForMenus (private)

 ******************************************************************************/

void
GMailboxTreeWidget::CheckSelectionForMenus
	(
	JBoolean* okDir,
	JBoolean* okFile,
	JBoolean* unLock
	)
{
	JTableSelection& s = GetTableSelection();
	JTableSelectionIterator iter(&s);
	JPoint cell;
	*okDir	= kJTrue;
	*okFile	= kJTrue;
	*unLock	= kJFalse;
	while (iter.Next(&cell))
		{
		JTreeNode* node = GetNamedTreeList()->GetNode(cell.y);
		if (node->GetDepth() != 1)
			{
			*okDir	= kJFalse;
			}
		if (node->IsOpenable())
			{
			*okFile	= kJFalse;
			}
		GMailFileTreeNode* mnode =
			dynamic_cast<GMailFileTreeNode*>(node);
		if (GFileLocked(mnode->GetDirEntry()->GetFullName()))
			{
			*unLock = kJTrue;
			}
		}
}

/******************************************************************************
 AddDefaultButtcons (public)

 ******************************************************************************/

void
GMailboxTreeWidget::AddDefaultButtcons
	(
	JXToolBar* toolbar
	)
{
	toolbar->AppendButton(itsMailboxMenu, kNewMBoxCmd);
	toolbar->AppendButton(itsMailboxMenu, kNewDirCmd);
	toolbar->NewGroup();
}

/******************************************************************************
 CreateMailBox (private)

 ******************************************************************************/

void
GMailboxTreeWidget::CreateMailBox()
{
	JString dirName;
	GMailFileTreeNode* node;

	if (GetNewName(&node, &dirName))
		{
		if (GMGetApplication()->NewMailbox(dirName, kJFalse))
			{
			JDirEntry* entry = new JDirEntry(dirName);
			assert(entry != NULL);
			GMailFileTreeNode* fnode =
				new GMailFileTreeNode(entry);
			assert(fnode != NULL);
			InsertNewNode(node, fnode);
			}
		}
	else
		{
		JString mbox;
		if (JXGetChooseSaveFile()->SaveFile("Name of new mailbox:", "", "",  &mbox))
			{
			GMGetApplication()->NewMailbox(mbox, kJFalse);
			AddFile(mbox);
			}
		}
}

/******************************************************************************
 CreateDirectory (private)

 ******************************************************************************/

void
GMailboxTreeWidget::CreateDirectory()
{
	JString dirName;
	GMailFileTreeNode* node;

	if (GetNewName(&node, &dirName))
		{
		JError err = JCreateDirectory(dirName);
		if (err.OK())
			{
			JDirEntry* entry = new JDirEntry(dirName);
			assert(entry != NULL);
			GMailFileTreeNode* fnode =
				new GMailFileTreeNode(entry);
			assert(fnode != NULL);
			InsertNewNode(node, fnode);
			}
		else
			{
			if (err.Is(kJAccessDenied))
				{
				JGetUserNotification()->ReportError("The access to create this directory was denied.");
				}
			else if (!err.Is(kJDirEntryAlreadyExists))
				{
				JGetUserNotification()->ReportError("I was unable to create this directory.");
				}
			}
		}
	else
		{
		JString dir;
		if (JXGetChooseSaveFile()->SaveFile("Name of new directory:", "", "",  &dir))
			{
			JError err = JCreateDirectory(dir);
			if (!err.OK())
				{
				if (err.Is(kJAccessDenied))
					{
					JGetUserNotification()->ReportError("The access to create this directory was denied.");
					}
				else if (!err.Is(kJDirEntryAlreadyExists))
					{
					JGetUserNotification()->ReportError("I was unable to create this directory.");
					}
				}
			}
		}
}

/******************************************************************************
 GetNewName (private)

 ******************************************************************************/

JBoolean
GMailboxTreeWidget::GetNewName
	(
	GMailFileTreeNode** parent,
	JString*			name
	)
{
	ClearIncrementalSearchBuffer();
	JTableSelectionIterator iter(&(GetTableSelection()));

	JPoint cell;
	JString dirName;
	GMailFileTreeNode* node;

	if (iter.Next(&cell))
		{
		if (GetTreeList()->GetNode(cell.y)->IsOpenable())
			{
			node = dynamic_cast<GMailFileTreeNode*>(GetTreeList()->GetNode(cell.y));
			assert (node != NULL);
			GetTreeList()->Open(node);
			dirName = node->GetDirEntry()->GetFullName();
			}

		else
			{
			JTreeNode* jnode = GetTreeList()->GetNode(cell.y);
			if (jnode->GetDepth() == 1)
				{
				node = dynamic_cast<GMailFileTreeNode*>(jnode);
				assert (node != NULL);
				dirName = node->GetDirEntry()->GetPath();
				node	= NULL;
				}
			else
				{
				JTreeNode* jparent	= jnode->GetParent();
				node	= dynamic_cast<GMailFileTreeNode*>(jparent);
				assert(node != NULL);
				dirName = node->GetDirEntry()->GetFullName();
				}
			}
		JAppendDirSeparator(&dirName);

		JString tempName = dirName + "Untitled";

		JIndex number = 1;

		while (JNameUsed(tempName))
			{
			tempName = dirName + "Untitled" + JString(number, JString::kBase10);
			number++;
			}

		*parent	= node;
		*name	= tempName;
		return kJTrue;
		}
	return kJFalse;
}

/******************************************************************************
 InsertNewNode (private)

 ******************************************************************************/

void
GMailboxTreeWidget::InsertNewNode
	(
	GMailFileTreeNode* parent,
	GMailFileTreeNode* node
	)
{
	if (parent != NULL)
		{
		parent->InsertSorted(node);
		}
	else
		{
		itsTree->GetRoot()->Append(node);
		}
	JIndex findex;
	if (GetTreeList()->FindNode(node, &findex))
		{
		JTableSelection& s = GetTableSelection();
		s.ClearSelection();
		TableScrollToCell(JPoint(1, findex));
		BeginEditing(JPoint(GetNodeColIndex(), findex));
		}
}

/******************************************************************************
 HandleReturn (private)

 ******************************************************************************/

void
GMailboxTreeWidget::HandleReturn()
{
	JPoint topSelCell;
	JTableSelection& s          = GetTableSelection();
	const JBoolean hadSelection	= s.GetFirstSelectedCell(&topSelCell);

	if (hadSelection)
		{
		if (s.GetSelectedCellCount() == 1 &&
			GetNamedTreeList()->GetNode(topSelCell.y)->IsOpenable())
			{
			if (GetNamedTreeList()->IsOpen(topSelCell.y))
				{
				GetNamedTreeList()->Close(topSelCell.y);
				}
			else
				{
				GetNamedTreeList()->Open(topSelCell.y);
				}
			}
		else
			{
			JTableSelectionIterator iter(&s);
			JPoint cell;
			while (iter.Next(&cell))
				{
				if (!GetNamedTreeList()->GetNode(cell.y)->IsOpenable())
					{
					OpenMailbox(cell.y);
					}
				}
			}
		}
}

/******************************************************************************
 AlreadyPresent

 *****************************************************************************/

JBoolean
GMailboxTreeWidget::AlreadyPresent
	(
	const JCharacter* fullname
	)
{
	JTreeNode* base = itsTree->GetRoot();
	JNamedTreeNode* parent =
		dynamic_cast<JNamedTreeNode*>(base);
	assert(parent != NULL);
	const JSize count	= parent->GetChildCount();
	for (JIndex i = 1; i <= count; i++)
		{
		JTreeNode* jchild	= parent->GetChild(i);
		GMailFileTreeNode* child	= dynamic_cast<GMailFileTreeNode*>(jchild);
		assert(child != NULL);
		if (child->GetDirEntry()->GetFullName() == fullname)
			{
			return kJTrue;
			}
		}
	return kJFalse;
}
