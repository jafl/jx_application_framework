/******************************************************************************
 JTextEditor.cc

	Class to edit styled text.

	Only public and protected functions are required to call NewUndo(),
	and only if the action to be performed changes the text or styles.
	Private functions must -not- call NewUndo(), because several manipulations
	may be required to perform one user command, and only the user command
	as a whole is undoable.  (Otherwise, the user may get confused.)

	Because of this convention, public functions that affect undo should only
	be a public interface to a private function.  The public function calls
	NewUndo() and then calls the private function.  The private function
	does all the work, but doesn't modify the undo information.  This allows other
	private functions to use the routine (private version) without modifying the
	undo information.

	In order to guarantee that the TextChanged message means "text has already
	changed", NewUndo() must be called -after- making the modification.
	(even though the Undo object has to be created before the modifications)

	TextSet is different from TextChanged because documents will typically
	use only the latter for setting their "unsaved" flag.

	When the text ends with a newline, we have to draw the caret on the
	next line.  This is a special case because (charIndex == bufLength+1)
	would normally catch this.  The code required to handle this special
	case is marked with "ends with newline".  (Most, but not all, such
	code calls EndsWithNewline().)

	Derived classes must implement the following routines:

		TERefresh
			Put an update event in the queue to redraw the text.

		TERefreshRect
			Put an update event in the queue to redraw part of the text.

		TEUpdateDisplay
			Redraw whatever was requested by TERefresh() and TERefreshRect().

		TERedraw
			Redraw the text immediately.

		TESetGUIBounds
			Set the bounds of the GUI object to match our size.

		TEScrollToRect
			Scroll the text to make the given rectangle visible, possibly
			centering it in the middle of the display.  Return kTrue
			if scrolling was necessary.

		TEScrollForDrag
			Scroll the text to make the given point visible.  Return kTrue
			if scrolling was necessary.

		TESetVertScrollStep
			Set the vertical step size and page context used when scrolling
			the text.

		TEClipboardChanged
			Do whatever is appropriate to update the system clipboard
			after a Copy or Cut operation.

		TEGetExternalClipboard
			Returns kTrue if there is something pasteable on the system clipboard.

		TEBeginDND
			Returns kTrue if it is able to start a Drag-And-Drop session
			with the OS.  From then on, the derived class should call the
			TEHandleDND*() functions.  If it returns kFalse, then we will
			manage an internal DND session.  In this case, the derived class
			should continue to call the usual TEHandleMouse*() functions.

		TEPasteDropData
			Get the data that was dropped and use Paste(text,style)
			to insert it.  (Before this is called, the insertion point
			is set so that Paste() will work correctly.)

	To draw page headers and footers while printing, override the
	following routines:

		GetPrintHeaderHeight
			Return the height required for the page header.

		DrawPrintHeader
			Draw the page header.  JTable will lock the header afterwards.

		GetPrintFooterHeight
			Return the height required for the page footer.

		DrawPrintFooter
			Draw the page footer.  JTable will lock the footer afterwards.

	The default implementation of tabs rounds the location up to the nearest
	multiple of itsDefTabWidth.  To implement non-uniform tabs or tabs on a
	line-by-line basis, override the following function:

		GetTabWidth
			Given the index of the tab character (charIndex) and the horizontal
			position on the line (in pixels) where the tab character starts (x),
			return the width of the tab character.

	Functionality yet to be implemented:

		Search & replace for text and styles
		Allow caret to blink via idle function

	BASE CLASS = virtual JBroadcaster

	Copyright (C) 1996-97 by John Lindal. All rights reserved.

 ******************************************************************************/

#include <JTextEditor.h>
#include <JTEUndoTyping.h>
#include <JTEUndoPaste.h>
#include <JTEUndoDrop.h>
#include <JTEUndoStyle.h>
#include <JTEUndoTabShift.h>
#include <JPrinter.h>
#include <JFontManager.h>
#include <JColormap.h>
#include <JOrderedSetUtil.h>
#include <JRunArrayIterator.h>
#include <JPtrStack.h>
#include <JRegex.h>
#include <JMinMax.h>
#include <jASCIIConstants.h>
#include <jFStreamUtil.h>
#include <jStreamUtil.h>
#include <jStrStreamUtil.h>
#include <jTime.h>
#include <ctype.h>
#include <jGlobals.h>
#include <jAssert.h>

const JCoordinate kDefLeftMarginWidth = 10;
const JCoordinate kRightMarginWidth   = 2;

const JCoordinate kDebounceWidth        = 3;
const JCoordinate kDraggedOutlineRadius = 10;

const JFileVersion kCurrentPrivateFormatVersion = 1;

const JSize kDefaultMaxUndoCount = 100;

const JSize kUNIXLineWidth    = 75;
const JSize kUNIXTabCharCount = 8;

// JBroadcaster message types

const JCharacter* JTextEditor::kTypeChanged      = "TypeChanged::JTextEditor";
const JCharacter* JTextEditor::kTextSet          = "TextSet::JTextEditor";
const JCharacter* JTextEditor::kTextChanged      = "TextChanged::JTextEditor";
const JCharacter* JTextEditor::kCaretLineChanged = "CaretLineChanged::JTextEditor";

/******************************************************************************
 Constructor

	We don't provide a constructor that accepts text because we
	can't call RecalcAll() due to pure virtual functions.

	*** Derived classes must call RecalcAll().

 ******************************************************************************/

JTextEditor::JTextEditor
	(
	const Type			type,
	const bool		breakCROnly,
	const bool		pasteStyledText,
	const JFontManager*	fontManager,
	JColormap*			colormap,
	const JColorIndex	caretColor,
	const JColorIndex	selectionColor,
	const JColorIndex	outlineColor,
	const JColorIndex	dragColor,
	const JCoordinate	width
	)
	:
	JBroadcaster(),
	itsType(type),
	itsPasteStyledTextFlag(pasteStyledText),

	itsFontMgr(fontManager),
	itsColormap(colormap),

	itsCaretColor(caretColor),
	itsSelectionColor(selectionColor),
	itsSelectionOutlineColor(outlineColor),
	itsDragColor(dragColor)
{
	itsBuffer = new JString;
	assert( itsBuffer != NULL );

	itsStyles = new JRunArray<Font>;
	assert( itsStyles != NULL );

	itsCustomColors          = NULL;
	itsUndo                  = NULL;
	itsUndoList              = NULL;
	itsFirstRedoIndex        = 1;
	itsUndoState             = kIdle;
	itsMaxUndoCount          = kDefaultMaxUndoCount;
	itsActiveFlag            = kFalse;
	itsCaretActiveFlag       = kFalse;
	itsPerformDNDFlag        = kFalse;
	itsAutoIndentFlag        = kFalse;
	itsMoveToFrontOfTextFlag = kFalse;
	itsBreakCROnlyFlag       = breakCROnly;
	itsIsPrintingFlag        = kFalse;

	itsDefFont.size = kJDefaultFontSize;
	// itsDefFont.style is automatically empty
	itsDefFont.id = itsFontMgr->GetFontID(JGetDefaultFontName(), itsDefFont.size, itsDefFont.style);

	itsWidth           = width - kDefLeftMarginWidth - kRightMarginWidth;
	itsHeight          = 0;
	itsGUIWidth        = itsWidth;
	itsLeftMarginWidth = kDefLeftMarginWidth;
	itsDefTabWidth     = 36;	// 1/2 inch

	itsLineStarts = new JArray<JIndex>;
	assert( itsLineStarts != NULL );
	itsLineStarts->SetCompareFunction(JCompareIndices);
	itsLineStarts->SetSortOrder(JOrderedSetT::kSortAscending);

	itsLineGeom = new JRunArray<LineGeometry>;
	assert( itsLineGeom != NULL );

	itsHasSelectionFlag = kFalse;
	itsCaretLoc         = CaretLocation(1,1);
	itsCaretX           = 0;
	itsInsertionFont    = CalcInsertionFont(1);
	itsSelection        = Selection(0,0);

	itsClipText  = NULL;
	itsClipStyle = NULL;

	itsDragText  = NULL;
	itsDragStyle = NULL;

	itsPrevDragType = itsDragType = kInvalidDrag;

	itsPrevBufLength   = 0;
	itsCRMLineWidth    = kUNIXLineWidth;
	itsCRMTabCharCount = kUNIXTabCharCount;

	if (type == kFullEditor)
		{
		itsBuffer->SetBlockSize(1024);
		itsLineStarts->SetBlockSize(100);
		}
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

JTextEditor::JTextEditor
	(
	const JTextEditor& source
	)
	:
	JBroadcaster(source),
	itsType( source.itsType ),
	itsPasteStyledTextFlag( source.itsPasteStyledTextFlag ),

	itsFontMgr( source.itsFontMgr ),
	itsColormap( source.itsColormap ),

	itsCaretColor( source.itsCaretColor ),
	itsSelectionColor( source.itsSelectionColor ),
	itsSelectionOutlineColor( source.itsSelectionOutlineColor ),
	itsDragColor( source.itsDragColor )
{
	itsBuffer = new JString(*(source.itsBuffer));
	assert( itsBuffer != NULL );

	itsStyles = new JRunArray<Font>(*(source.itsStyles));
	assert( itsStyles != NULL );

	itsCustomColors = NULL;
	if (source.itsCustomColors != NULL)
		{
		itsCustomColors = new JArray<JColorIndex>(*(source.itsCustomColors));
		assert( itsCustomColors != NULL );
		const JSize colorCount = itsCustomColors->GetElementCount();
		for (JIndex i=1; i<colorCount; i++)
			{
			itsColormap->UsingColor(itsCustomColors->GetElement(i));
			}
		}

	itsUndo                  = NULL;
	itsUndoList              = NULL;
	itsFirstRedoIndex        = 1;
	itsUndoState             = kIdle;
	itsMaxUndoCount          = source.itsMaxUndoCount;
	itsActiveFlag            = kFalse;
	itsCaretActiveFlag       = kFalse;
	itsPerformDNDFlag        = source.itsPerformDNDFlag;
	itsAutoIndentFlag        = source.itsAutoIndentFlag;
	itsMoveToFrontOfTextFlag = source.itsMoveToFrontOfTextFlag;
	itsBreakCROnlyFlag       = source.itsBreakCROnlyFlag;
	itsIsPrintingFlag        = kFalse;

	itsDefFont         = source.itsDefFont;
	itsWidth           = source.itsWidth;
	itsHeight          = source.itsHeight;
	itsGUIWidth        = source.itsGUIWidth;
	itsLeftMarginWidth = source.itsLeftMarginWidth;
	itsDefTabWidth     = source.itsDefTabWidth;

	itsLineStarts = new JArray<JIndex>(*(source.itsLineStarts));
	assert( itsLineStarts != NULL );

	itsLineGeom = new JRunArray<LineGeometry>(*(source.itsLineGeom));
	assert( itsLineGeom != NULL );

	itsPrevBufLength = source.itsPrevBufLength;

	itsHasSelectionFlag = kFalse;
	itsCaretLoc         = CaretLocation(1,1);
	itsCaretX           = 0;
	itsInsertionFont    = CalcInsertionFont(1);
	itsSelection        = Selection(0,0);

	itsClipText         = NULL;
	itsClipStyle        = NULL;

	itsDragText         = NULL;
	itsDragStyle        = NULL;

	itsPrevDragType     = itsDragType = kInvalidDrag;

	itsCRMLineWidth     = source.itsCRMLineWidth;
	itsCRMTabCharCount  = source.itsCRMTabCharCount;
}

/******************************************************************************
 Destructor

 ******************************************************************************/

JTextEditor::~JTextEditor()
{
	delete itsBuffer;
	delete itsStyles;
	delete itsUndo;
	delete itsLineStarts;
	delete itsLineGeom;

	if (itsUndoList != NULL)
		{
		itsUndoList->DeleteAll();
		delete itsUndoList;
		}

	delete itsClipText;
	delete itsClipStyle;

	delete itsDragText;
	delete itsDragStyle;

	if (itsCustomColors != NULL)
		{
		const JSize count = itsCustomColors->GetElementCount();
		for (JIndex i=1; i<=count; i++)
			{
			itsColormap->DeallocateColor(itsCustomColors->GetElement(i));
			}
		delete itsCustomColors;
		}
}

/******************************************************************************
 SetType (protected)

	This is protected because most derived classes will not be written
	to expect the type to change.

	Broadcasts TypeChanged.

 ******************************************************************************/

void
JTextEditor::SetType
	(
	const Type type
	)
{
	itsType = type;
	TERefresh();
	Broadcast(TypeChanged(type));
}

/******************************************************************************
 SetText

	Returns kFalse if illegal characters had to be removed.

	This is not accessible to the user, so we don't provide Undo.

 ******************************************************************************/

bool
JTextEditor::SetText
	(
	const JCharacter*		text,
	const JRunArray<Font>*	style
	)
{
	*itsBuffer = text;
	return SetText1(style);
}

/******************************************************************************
 SetText1 (private)

	Returns kFalse if illegal characters had to be removed.

	style can be NULL or itsStyles.

 ******************************************************************************/

bool
JTextEditor::SetText1
	(
	const JRunArray<Font>* style
	)
{
	ClearUndo();

	bool cleaned = kFalse;

	if (style != NULL)
		{
		assert( itsBuffer->GetLength() == style->GetElementCount() );
		*itsStyles = *style;
		cleaned = RemoveIllegalChars(itsBuffer, itsStyles);
		}
	else
		{
		cleaned = RemoveIllegalChars(itsBuffer);

		itsStyles->RemoveAll();
		if (!itsBuffer->IsEmpty())
			{
			itsStyles->AppendElements(itsDefFont, itsBuffer->GetLength());
			}
		}

	SetCaretLocation(1);
	RecalcAll();
	Broadcast(TextSet());
	return JNegate(cleaned);
}

/******************************************************************************
 ReadPlainText

	Returns kFalse if illegal characters had to be removed.

	We don't call SetText to avoid making two copies of the file's data.
	(The file could be very large.)

 ******************************************************************************/

static const JCharacter* kUNIXNewline          = "\n";
static const JCharacter  kUNIXNewlineChar      = '\n';
static const JCharacter* kMacintoshNewline     = "\r";
static const JCharacter  kMacintoshNewlineChar = '\r';
static const JCharacter* kDOSNewline           = "\r\n";

bool
JTextEditor::ReadPlainText
	(
	const JCharacter*	fileName,
	PlainTextFormat*	format
	)
{
	TEDisplayBusyCursor();

	JReadFile(fileName, itsBuffer);

	JIndex i;
	if (ContainsIllegalChars(*itsBuffer))
		{
		// It is probably a binary file, so we shouldn't mess with it.

		*format = kUNIXText;
		}

	else if (itsBuffer->LocateLastSubstring(kDOSNewline, &i))
		{
		// We work from the end since the string will shrink.

		*format = kDOSText;
		do
			{
			itsBuffer->ReplaceSubstring(i,i+1, kUNIXNewline);
			}
			while (itsBuffer->LocatePrevSubstring(kDOSNewline, &i));
		}

	else if (itsBuffer->LocateSubstring(kMacintoshNewline, &i))
		{
		*format = kMacintoshText;

		const JCharacter* s   = itsBuffer->GetCString();
		const JSize bufLength = itsBuffer->GetLength();
		for (i--; i<bufLength; i++)
			{
			if (s[i] == kMacintoshNewlineChar)
				{
				itsBuffer->SetCharacter(i+1, kUNIXNewlineChar);
				}
			}
		}

	else
		{
		*format = kUNIXText;
		}

	return SetText1(NULL);
}

/******************************************************************************
 WritePlainText

 ******************************************************************************/

void
JTextEditor::WritePlainText
	(
	const JCharacter*		fileName,
	const PlainTextFormat	format
	)
	const
{
	ofstream output(fileName);
	WritePlainText(output, format);
}

void
JTextEditor::WritePlainText
	(
	ostream&				output,
	const PlainTextFormat	format
	)
	const
{
	if (format == kUNIXText)
		{
		itsBuffer->Print(output);
		return;
		}

	const JCharacter* newlineStr = NULL;
	if (format == kDOSText)
		{
		newlineStr = kDOSNewline;
		}
	else if (format == kMacintoshText)
		{
		newlineStr = kMacintoshNewline;
		}
	assert( newlineStr != NULL );

	const JCharacter* buffer = itsBuffer->GetCString();
	const JSize bufLength    = itsBuffer->GetLength();
	JIndex start             = 0;
	for (JIndex i=0; i<bufLength; i++)
		{
		if (buffer[i] == '\n')
			{
			if (start < i)
				{
				output.write(buffer + start, i - start);
				}
			output << newlineStr;
			start = i+1;
			}
		}

	if (start < bufLength)
		{
		output.write(buffer + start, bufLength - start);
		}
}

/******************************************************************************
 ReadUNIXManOutput

	Returns kFalse if cancelled.

	"_\b_" => underlined space
	"_\bc" => underlined c
	"c\bc" => bold c

 ******************************************************************************/

bool
JTextEditor::ReadUNIXManOutput
	(
	istream&		input,
	const bool	allowCancel
	)
{
	TEDisplayBusyCursor();

	itsBuffer->Clear();
	itsStyles->RemoveAll();

	const JCharacter* fontName = GetDefaultFontName();

	Font boldFont = itsDefFont;
	boldFont.style.bold = kTrue;
	boldFont.id =
		itsFontMgr->GetFontID(fontName, boldFont.size, boldFont.style);

	Font ulFont = itsDefFont;
	ulFont.style.underlineCount = 1;
	ulFont.id =
		itsFontMgr->GetFontID(fontName, ulFont.size, ulFont.style);

	bool cancelled          = kFalse;
	JSize lineCount             = 0;
	const JSize kScaleFactor    = 100;			// lines per progress increment
	JProgressDisplay* pg        = NULL;
	const time_t startTime      = time(NULL);
	const time_t kMaxSilentTime = 3;			// seconds

	input >> ws;
	while (input.good() && !cancelled)
		{
		JCharacter c = input.get();
		if (!input.good())
			{
			break;
			}

		if (c == '_' && input.peek() == '\b')
			{
			input.ignore();
			c = input.get();
			if (!input.good())
				{
				break;
				}

			itsBuffer->AppendCharacter(c == '_' ? ' ' : c);
			itsStyles->AppendElement(ulFont);
			}
		else if (c == '\b' && !itsBuffer->IsEmpty())
			{
			c = input.get();
			if (!input.good())
				{
				break;
				}

			if (c == itsBuffer->GetLastCharacter())
				{
				itsStyles->SetElement(itsStyles->GetElementCount(), boldFont);
				}
			else
				{
				input.putback(c);
				continue;
				}
			}
		else if (c == '\n' && itsBuffer->EndsWith("\n\n"))
			{
			// toss extra blank lines
			continue;
			}
		else
			{
			itsBuffer->AppendCharacter(c);
			itsStyles->AppendElement(itsDefFont);

			if (c == '\n')
				{
				lineCount++;
				const bool timeToUpdate =
					JConvertToBoolean( lineCount % kScaleFactor == 0 );
				if (timeToUpdate && pg == NULL &&
					time(NULL) - startTime >= kMaxSilentTime)
					{
					pg = JNewPG();
					pg->VariableLengthProcessBeginning(
						"Reading man page...", allowCancel, kNoBackground);
					pg->IncrementProgress(lineCount);
					}
				else if (timeToUpdate && pg != NULL)
					{
					cancelled = JNegate( pg->IncrementProgress(lineCount) );
					}
				}
			}
		}

	if (pg != NULL)
		{
		pg->ProcessFinished();
		delete pg;
		}

	// trim trailing whitespace

	while (isspace(itsBuffer->GetLastCharacter()))
		{
		const JSize length = itsBuffer->GetLength();
		itsBuffer->RemoveSubstring(length,length);
		itsStyles->RemoveElement(length);
		}

	SetText1(itsStyles);
	return JNegate(cancelled);
}

/******************************************************************************
 ReadPrivateFormat

	See WritePrivateFormat() for version information.

 ******************************************************************************/

bool
JTextEditor::ReadPrivateFormat
	(
	istream& input
	)
{
	TEDisplayBusyCursor();

	JString text;
	JRunArray<Font> style;
	if (ReadPrivateFormat(input, this, &text, &style))
		{
		*itsBuffer = text;
		SetText1(&style);
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 ReadPrivateFormat (static protected)

	See WritePrivateFormat() for version information.

 ******************************************************************************/

bool
JTextEditor::ReadPrivateFormat
	(
	istream&			input,
	const JTextEditor*	te,
	JString*			text,
	JRunArray<Font>*	style
	)
{
JIndex i;

	text->Clear();
	style->RemoveAll();

	// version

	JFileVersion vers;
	input >> vers;

	if (vers > kCurrentPrivateFormatVersion)
		{
		return kFalse;
		}

	// text

	JSize textLength;
	input >> textLength;
	input.ignore(1);
	if (textLength > 0)
		{
		text->Read(input, textLength);
		}

	// list of font names

	JSize fontCount;
	input >> fontCount;

	JPtrArray<JString> fontList;
	for (i=1; i<=fontCount; i++)
		{
		JString* name = new JString;
		assert( name != NULL );
		input >> *name;
		fontList.Append(name);
		}

	// list of rgb values

	JSize colorCount;
	input >> colorCount;

	JArray<JColorIndex> colorList;

	JRGB color;
	for (i=1; i<=colorCount; i++)
		{
		input >> color;
		colorList.AppendElement(te->RGBToColorIndex(color));
		}

	// styles

	JSize runCount;
	input >> runCount;

	const JFontManager* fontMgr = te->TEGetFontManager();

	for (i=1; i<=runCount; i++)
		{
		JSize charCount;
		input >> charCount;

		JIndex fontIndex;
		input >> fontIndex;

		Font f;
		input >> f.size;
		input >> f.style.bold >> f.style.italic >> f.style.strike;
		input >> f.style.underlineCount;

		JIndex colorIndex;
		input >> colorIndex;
		f.style.color = colorList.GetElement(colorIndex);

		const JString* name = fontList.NthElement(fontIndex);
		f.id = fontMgr->GetFontID(*name, f.size, f.style);

		style->AppendElements(f, charCount);
		}

	// clean up

	fontList.DeleteAll();
	return kTrue;
}

/******************************************************************************
 WritePrivateFormat

 ******************************************************************************/

void
JTextEditor::WritePrivateFormat
	(
	ostream& output
	)
	const
{
	WritePrivateFormat(output, kCurrentPrivateFormatVersion,
					   1, itsBuffer->GetLength());
}

/******************************************************************************
 WritePrivateFormat (protected)

 ******************************************************************************/

void
JTextEditor::WritePrivateFormat
	(
	ostream&			output,
	const JFileVersion	vers,
	const JIndex		startIndex,
	const JIndex		endIndex
	)
	const
{
	WritePrivateFormat(output, this, vers, *itsBuffer, *itsStyles,
					   startIndex, endIndex);
}

void
JTextEditor::WritePrivateFormat
	(
	ostream&				output,
	const JFileVersion		vers,
	const JString&			text,
	const JRunArray<Font>&	style
	)
	const
{
	if (!text.IsEmpty() && text.GetLength() == style.GetElementCount())
		{
		WritePrivateFormat(output, this, vers, text, style,
						   1, text.GetLength());
		}
}

/******************************************************************************
 WriteClipboardPrivateFormat (protected)

	Returns kFalse if the clipboard is empty.

 ******************************************************************************/

bool
JTextEditor::WriteClipboardPrivateFormat
	(
	ostream&			output,
	const JFileVersion	vers
	)
	const
{
	if (itsClipText != NULL && itsClipStyle != NULL &&
		!itsClipText->IsEmpty())
		{
		WritePrivateFormat(output, this, vers, *itsClipText, *itsClipStyle,
						   1, itsClipText->GetLength());
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 WriteDragClipPrivateFormat (protected)

	Returns kFalse if the drag clipboard is empty.

 ******************************************************************************/

bool
JTextEditor::WriteDragClipPrivateFormat
	(
	ostream&			output,
	const JFileVersion	vers
	)
	const
{
	if (itsDragText != NULL && itsDragStyle != NULL &&
		!itsDragText->IsEmpty())
		{
		WritePrivateFormat(output, this, vers, *itsDragText, *itsDragStyle,
						   1, itsDragText->GetLength());
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 WritePrivateFormat (static protected)

	We have to be able to write each version because this is what we
	put on the clipboard.

	version 1:  initial version.

 ******************************************************************************/

void
JTextEditor::WritePrivateFormat
	(
	ostream&				output,
	const JTextEditor*		te,
	const JFileVersion		vers,
	const JString&			text,
	const JRunArray<Font>&	style,
	const JIndex			startIndex,
	const JIndex			endIndex
	)
{
	assert( text.IndexValid(startIndex) );
	assert( text.IndexValid(endIndex) );
	assert( startIndex <= endIndex );
	assert( vers <= kCurrentPrivateFormatVersion );

	// write version

	output << vers;

	// write text efficiently

	const JSize textLength = endIndex-startIndex+1;
	output << ' ' << textLength << ' ';
	output.write(text.GetCString() + startIndex-1, textLength);

	// build lists of font names and colors

	const JFontManager* fontMgr = te->TEGetFontManager();

	JSize styleRunCount = 0;
	JPtrArray<JString> fontList;
	fontList.SetCompareFunction(JCompareStringsCaseSensitive);
	JArray<JColorIndex> colorList;
	colorList.SetCompareFunction(JCompareIndices);

	JIndex startRunIndex, startFirstInRun;
	bool found = style.FindRun(startIndex, &startRunIndex, &startFirstInRun);
	assert( found );

	JIndex i          = startIndex;
	JIndex runIndex   = startRunIndex;
	JIndex firstInRun = startFirstInRun;
	do
		{
		const Font& f    = style.GetRunDataRef(runIndex);
		JString fontName = fontMgr->GetFontName(f.id);
		const JIndex fontIndex =
			fontList.SearchSorted1(&fontName, JOrderedSetT::kAnyMatch, &found);
		if (!found)
			{
			JString* name = new JString(fontName);
			assert( name != NULL );
			fontList.InsertAtIndex(fontIndex, name);
			}

		const JIndex colorIndex =
			colorList.SearchSorted1(f.style.color, JOrderedSetT::kAnyMatch, &found);
		if (!found)
			{
			colorList.InsertElementAtIndex(colorIndex, f.style.color);
			}

		i += style.GetRunLength(runIndex) - (i - firstInRun);
		runIndex++;
		firstInRun = i;
		styleRunCount++;
		}
		while (i <= endIndex);

	// write list of font names

	const JSize fontCount = fontList.GetElementCount();
	output << ' ' << fontCount;

	for (i=1; i<=fontCount; i++)
		{
		output << ' ' << *(fontList.NthElement(i));
		}

	// write list of rgb values

	const JSize colorCount = colorList.GetElementCount();
	output << ' ' << colorCount;

	for (i=1; i<=colorCount; i++)
		{
		output << ' ' << (te->itsColormap)->GetRGB(colorList.GetElement(i));
		}

	// write styles

	output << ' ' << styleRunCount;

	i          = startIndex;
	runIndex   = startRunIndex;
	firstInRun = startFirstInRun;
	do
		{
		JSize charCount = style.GetRunLength(runIndex) - (i - firstInRun);
		if (endIndex < i + charCount - 1)
			{
			charCount = endIndex - i + 1;
			}

		const Font& f    = style.GetRunDataRef(runIndex);
		JString fontName = fontMgr->GetFontName(f.id);

		JIndex fontIndex;
		found = fontList.SearchSorted(&fontName, JOrderedSetT::kAnyMatch, &fontIndex);
		assert( found );

		JIndex colorIndex;
		found = colorList.SearchSorted(f.style.color, JOrderedSetT::kAnyMatch, &colorIndex);
		assert( found );

		output << ' ' << charCount;
		output << ' ' << fontIndex;
		output << ' ' << f.size;
		output << ' ' << f.style.bold << f.style.italic << f.style.strike;
		output << ' ' << f.style.underlineCount;
		output << ' ' << colorIndex;

		i += charCount;
		runIndex++;
		firstInRun = i;
		}
		while (i <= endIndex);

	// clean up

	fontList.DeleteAll();
}

/******************************************************************************
 ColorNameToColorIndex (static)

 ******************************************************************************/

JColorIndex
JTextEditor::ColorNameToColorIndex
	(
	const JCharacter*		name,
	JColormap*				colormap,
	JArray<JColorIndex>**	colorList
	)
{
	JColorIndex colorIndex;
	if (colormap->AllocateStaticNamedColor(name, &colorIndex))
		{
		if (*colorList == NULL)
			{
			*colorList = new JArray<JColorIndex>;
			assert( *colorList != NULL );
			}
		(**colorList).AppendElement(colorIndex);
		return colorIndex;
		}
	else
		{
		return colormap->GetBlackColor();
		}
}

/******************************************************************************
 RGBToColorIndex (private)

 ******************************************************************************/

JColorIndex
JTextEditor::RGBToColorIndex
	(
	const JRGB& color
	)
	const
{
	JColorIndex colorIndex;
	if (itsColormap->AllocateStaticColor(color, &colorIndex))
		{
		if (itsCustomColors == NULL)
			{
			JTextEditor* te = const_cast<JTextEditor*>(this);
			te->itsCustomColors = new JArray<JColorIndex>;
			assert( itsCustomColors != NULL );
			}
		itsCustomColors->AppendElement(colorIndex);
		return colorIndex;
		}
	else
		{
		return itsColormap->GetBlackColor();
		}
}

/******************************************************************************
 HTML

	Information on HTML can be found at:

		http://home.netscape.com/assist/net_sites/index.html
		http://www.ncsa.uiuc.edu/General/Internet/WWW/HTMLPrimer.html
		http://home.netscape.com/assist/net_sites/html_extensions.html
		http://home.netscape.com/assist/net_sites/html_extensions_3.html

	HTML is apparently supposed to be based on a stack, so formatting commands
	cannot be interleaved, only nested.  This is stupid.  If the user types
	"<b>bold<i>bold-italic</b>italic</i>", it is obvious what they mean.
	JTextEditor handles this correctly.

 ******************************************************************************/

enum HTMLCmd
{
	kHTMLNewParagraph,
	kHTMLLineBreak,
	kHTMLHorizRule,

	kHTMLBlockquote,

	kHTMLBold,
	kHTMLItalic,
	kHTMLUnderline,
	kHTMLStrike,

	kHTMLFont,

	kHTMLMonospace,
	kHTMLPreformatted,

	kHTMLHeader1,	// remember to keep kHTMLHeaderFontSize up to date!
	kHTMLHeader2,
	kHTMLHeader3,
	kHTMLHeader4,
	kHTMLHeader5,
	kHTMLHeader6,

	kHTMLHead,
	kHTMLForm,
	kHTMLMap,

	kHTMLUnordList,
	kHTMLOrdList,
	kHTMLListElement,

	kHTMLTermList,
	kHTMLDefTerm,
	kHTMLDefData,

	kHTMLEmpty,
	kHTMLNOP
};

enum
{
	kHTMLBoldUseIndex,
	kHTMLItalicUseIndex,
	kHTMLUnderlineUseIndex,
	kHTMLStrikeUseIndex,

	kHTMLFontFlagCount
};

enum ListType
{
	kNoList,
	kUnordList,
	kOrdList,
	kDefTermList,
	kDefDataList	// same as kDefTermList, but extra tab indenting
};

struct HTMLParserState
{
	const JFontManager*									fontMgr;
	JTextEditor::Font									font;
	JString												fontName;
	JStack<JArray<JTextEditor::Font>,JTextEditor::Font>	fontStack;
	JPtrStack<JArray<JString*>,JString*>				fontNameStack;

	JString								prevFontName;	// for use by kHTMLMonospace
	const JTextEditor::Font				blankLineFont;
	JSize								fontFlagUse [ kHTMLFontFlagCount ];

	ListType							listType;
	JIndex								listIndex;
	JStack<JArray<ListType>,ListType>	listTypeStack;
	JStack<JArray<JIndex>,JIndex>		listIndexStack;

	JSize								indentCount;	// # of blockquote cmds
	JSize								newlineCount;	// number of trailing newlines
	bool							appendWS;		// kTrue if need whitespace in front of next word

	const JCharacter*					delim;
	JSize								delimCount;

	HTMLParserState(const JFontManager* fontManager, const JCharacter* delimiters)
		:
		fontMgr(fontManager),
		font(fontManager->GetFontID(JGetDefaultFontName(), 12, JFontStyle()),
			 12, JFontStyle()),
		fontName(JGetDefaultFontName()),
		prevFontName(fontName),
		blankLineFont(font),
		listType(kNoList),
		listIndex(0),
		indentCount(0),
		newlineCount(0),
		appendWS(kFalse),
		delim(delimiters),
		delimCount(strlen(delimiters))
	{
		for (JIndex i=0; i<kHTMLFontFlagCount; i++)
			{
			fontFlagUse[i] = 0;
			}
	};

	void PushCurrentFont()
	{
		fontStack.Push(font);

		JString* name = new JString(fontName);
		assert( name != NULL );
		fontNameStack.Push(name);
	};

	bool PopFont(JString* buffer, JRunArray<JTextEditor::Font>* styles);

	void UpdateFontID()
	{
		font.id = fontMgr->GetFontID(fontName, font.size, font.style);
	};

	void		NewList(const ListType type, JString* buffer, JRunArray<JTextEditor::Font>* styles);
	void		NewListItem(JString* buffer, JRunArray<JTextEditor::Font>* styles);
	bool	EndList(JString* buffer, JRunArray<JTextEditor::Font>* styles);

	void SetDelimiters(const JCharacter* delimiters)
	{
		delim      = delimiters;
		delimCount = strlen(delimiters);
	};
};

#define JTemplateType ListType
#include <JArray.tmpls>
#undef JTemplateType
#define JTemplateType JArray<ListType>,ListType
#include <JStack.tmpls>
#undef JTemplateType

static const JSize kHTMLPointSize[]      = { 8, 10, 12, 14, 18, 24, 24 };
static const JSize kHTMLHeaderFontSize[] = { 18, 18, 14, 14, 12, 8 };

static const JCharacter* kHTMLBaseDelim = "<&";
static const JCharacter* kHTMLAllDelim  = "<& \t\n";

static void		HandleHTMLOnCmd(istream& input, const HTMLCmd cmd, const JString& attribText,
								JString* buffer, JRunArray<JTextEditor::Font>* styles,
								HTMLParserState* state,
								JColormap* colormap, JArray<JColorIndex>** colorList);
static void		HandleHTMLOffCmd(const HTMLCmd cmd, JString* buffer,
								 JRunArray<JTextEditor::Font>* styles,
								 HTMLParserState* state);

static HTMLCmd	ParseHTMLCmd(istream& input, JString* attribText, bool* on);
static void		ParseHTMLFontAttribs(const JString& attribText, HTMLParserState* state,
									 JColormap* colormap, JArray<JColorIndex>** colorList);
static JString	ParseHTMLEscapedChar(istream& input);
static void		IgnoreUntilHTMLClose(istream& input, const JCharacter* delimiter);

static void		AppendTextForHTML(JString* buffer, const JString& text,
								  JRunArray<JTextEditor::Font>* styles,
								  HTMLParserState* state);
static void 	AppendNewlinesForHTML(const JSize count, JString* buffer,
									  JRunArray<JTextEditor::Font>* styles,
									  HTMLParserState* state);

/******************************************************************************
 AppendCharsForHTML (inline local)

 ******************************************************************************/

inline void 
AppendCharsForHTML
	(
	JString*						buffer,
	const JCharacter*				text,
	JRunArray<JTextEditor::Font>*	styles,
	const JTextEditor::Font&		f
	)
{
	*buffer += text;
	styles->AppendElements(f, strlen(text));
}

inline void 
AppendCharsForHTML
	(
	JString*						buffer,
	const JString&					text,
	JRunArray<JTextEditor::Font>*	styles,
	const JTextEditor::Font&		f
	)
{
	*buffer += text;
	styles->AppendElements(f, text.GetLength());
}

void 
AppendNewlinesForHTML
	(
	const JSize						count,
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles,
	HTMLParserState*				state
	)
{
	if (!buffer->IsEmpty())
		{
		const JTextEditor::Font* f = &(state->font);
		while (state->newlineCount < count)
			{
			AppendCharsForHTML(buffer, "\n", styles, *f);
			(state->newlineCount)++;
			f = &(state->blankLineFont);
			}
		}
}

/******************************************************************************
 AppendTextForHTML (private)

	Appends the given text to the buffer, accounting for the need for
	indenting and whitespace.

 ******************************************************************************/

void
AppendTextForHTML
	(
	JString*						buffer,
	const JString&					text,
	JRunArray<JTextEditor::Font>*	styles,
	HTMLParserState*				state
	)
{
	if (text.IsEmpty())
		{
		return;
		}

	JTextEditor::Font wsFont(0, (state->font).size, JFontStyle());
	wsFont.id = (state->fontMgr)->GetFontID(state->fontName, wsFont.size, wsFont.style);

	if (!buffer->IsEmpty() && buffer->GetLastCharacter() == '\n')
		{
		for (JIndex i=1; i<=state->indentCount; i++)
			{
			AppendCharsForHTML(buffer, "\t", styles, wsFont);
			}

		if (state->listType != kNoList)
			{
			const JSize listDepth = (state->listTypeStack).GetElementCount();
			for (JIndex i=1; i<listDepth; i++)
				{
				AppendCharsForHTML(buffer, "\t", styles, wsFont);
				}

			if (state->listType == kUnordList)
				{
				AppendCharsForHTML(buffer, "\t  ", styles, wsFont);
				}
			else if (state->listType == kOrdList)
				{
				JString str(state->listIndex, 0);
				for (JIndex i=1; i<=str.GetLength(); i++)
					{
					str.SetCharacter(i, ' ');
					}
				str += "  ";
				str.PrependCharacter('\t');
				AppendCharsForHTML(buffer, str, styles, wsFont);
				}
			else if (state->listType == kDefDataList)
				{
				AppendCharsForHTML(buffer, "\t", styles, wsFont);
				}
			}
		}
	else if (!buffer->IsEmpty() && buffer->GetLastCharacter() != '\n' &&
			 state->appendWS)
		{
		AppendCharsForHTML(buffer, " ", styles, wsFont);
		}
	state->appendWS = kFalse;

	AppendCharsForHTML(buffer, text, styles, state->font);
	state->newlineCount = 0;
}

/******************************************************************************
 HTMLParserState functions

 ******************************************************************************/

bool
HTMLParserState::PopFont
	(
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles
	)
{
	if (fontStack.IsEmpty())
		{
		AppendCharsForHTML(buffer, "\n*** Html Font Error ***\n", styles, font);
		fontNameStack.ClearDelete();
		newlineCount = 1;
		return kFalse;
		}
	else
		{
		const JTextEditor::Font f = fontStack.Pop();
		font.size                 = f.size;
		font.style.color          = f.style.color;

		JString* name = fontNameStack.Pop();
		fontName      = *name;
		delete name;

		UpdateFontID();
		return kTrue;
		}
};

void
HTMLParserState::NewList
	(
	const ListType					type,
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles
	)
{
	if (listType == kNoList)
		{
		AppendNewlinesForHTML(2, buffer, styles, this);
		}

	listTypeStack.Push(listType);
	listIndexStack.Push(listIndex);

	listType  = type;
	listIndex = 0;
}

void
HTMLParserState::NewListItem
	(
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles
	)
{
	AppendNewlinesForHTML(1, buffer, styles, this);

	JSize listIndentDepth = listTypeStack.GetElementCount();
	if (listType == kDefTermList || listType == kDefDataList)
		{
		listIndentDepth--;
		}

	for (JIndex i=1; i<=indentCount + listIndentDepth; i++)
		{
		AppendCharsForHTML(buffer, "\t", styles, font);
		}

	listIndex++;

	newlineCount = 0;
	appendWS     = kFalse;
}

bool
HTMLParserState::EndList
	(
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles
	)
{
	if (listTypeStack.IsEmpty())
		{
		AppendCharsForHTML(buffer, "\n*** Html List Error ***\n", styles, font);
		newlineCount = 1;
		return kFalse;
		}
	else
		{
		listType  = listTypeStack.Pop();
		listIndex = listIndexStack.Pop();

		if (listType == kNoList)
			{
			AppendNewlinesForHTML(2, buffer, styles, this);
			}

		return kTrue;
		}
}

/******************************************************************************
 ReadHTML

	Parses HTML text and approximates the formatting.

 ******************************************************************************/

void
JTextEditor::ReadHTML
	(
	istream& input
	)
{
	TEDisplayBusyCursor();

	HTMLParserState state(itsFontMgr, kHTMLAllDelim);

	itsBuffer->Clear();
	itsStyles->RemoveAll();

	while (1)
		{
		JString text;
		JCharacter delim;
		const bool foundDelim =
			JReadUntil(input, state.delimCount, state.delim, &text, &delim);

		AppendTextForHTML(itsBuffer, text, itsStyles, &state);

		if (!foundDelim)
			{
			break;
			}

		else if (isspace(delim))
			{
			if (!itsBuffer->IsEmpty() && !isspace(itsBuffer->GetLastCharacter()))
				{
				state.appendWS = kTrue;
				}
			}

		else if (delim == '&')
			{
			const JString s = ParseHTMLEscapedChar(input);
			AppendTextForHTML(itsBuffer, s, itsStyles, &state);
			}

		else if (delim == '<')
			{
			JString attribText;
			bool on;
			const HTMLCmd cmd = ParseHTMLCmd(input, &attribText, &on);

			if (on)
				{
				HandleHTMLOnCmd(input, cmd, attribText, itsBuffer, itsStyles, &state,
								itsColormap, &itsCustomColors);
				}
			else
				{
				HandleHTMLOffCmd(cmd, itsBuffer, itsStyles, &state);
				}
			}
		}

	ClearUndo();
	SetCaretLocation(1);
	RecalcAll();
	Broadcast(TextSet());
}

/******************************************************************************
 HandleHTMLOnCmd (local)

 ******************************************************************************/

void
HandleHTMLOnCmd
	(
	istream&						input,
	const HTMLCmd					cmd,
	const JString&					attribText,
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles,
	HTMLParserState*				state,
	JColormap*						colormap,
	JArray<JColorIndex>**			colorList
	)
{
	if (cmd == kHTMLNewParagraph)
		{
		AppendNewlinesForHTML(2, buffer, styles, state);
		}
	else if (cmd == kHTMLLineBreak)
		{
		AppendCharsForHTML(buffer, "\n", styles, state->font);
		(state->newlineCount)++;
		}

	else if (cmd == kHTMLHorizRule)
		{
		AppendNewlinesForHTML(1, buffer, styles, state);
		AppendTextForHTML(buffer, "----------", styles, state);
		AppendNewlinesForHTML(1, buffer, styles, state);
		}

	else if (cmd == kHTMLBlockquote)
		{
		AppendNewlinesForHTML(2, buffer, styles, state);
		(state->indentCount)++;
		}

	else if (cmd == kHTMLBold)
		{
		if (state->fontFlagUse[ kHTMLBoldUseIndex ] == 0)
			{
			(state->font).style.bold = kTrue;
			state->UpdateFontID();
			}
		(state->fontFlagUse[ kHTMLBoldUseIndex ])++;
		}
	else if (cmd == kHTMLItalic)
		{
		if (state->fontFlagUse[ kHTMLItalicUseIndex ] == 0)
			{
			(state->font).style.italic = kTrue;
			state->UpdateFontID();
			}
		(state->fontFlagUse[ kHTMLItalicUseIndex ])++;
		}
	else if (cmd == kHTMLUnderline)
		{
		if (state->fontFlagUse[ kHTMLUnderlineUseIndex ] == 0)
			{
			(state->font).style.underlineCount = 1;
			state->UpdateFontID();
			}
		(state->fontFlagUse[ kHTMLUnderlineUseIndex ])++;
		}
	else if (cmd == kHTMLStrike)
		{
		if (state->fontFlagUse[ kHTMLStrikeUseIndex ] == 0)
			{
			(state->font).style.strike = kTrue;
			state->UpdateFontID();
			}
		(state->fontFlagUse[ kHTMLStrikeUseIndex ])++;
		}

	else if (cmd == kHTMLFont)
		{
		state->PushCurrentFont();
		ParseHTMLFontAttribs(attribText, state, colormap, colorList);
		}

	else if (cmd == kHTMLMonospace || cmd == kHTMLPreformatted)
		{
		if (cmd == kHTMLPreformatted)
			{
			AppendNewlinesForHTML(2, buffer, styles, state);
			state->SetDelimiters(kHTMLBaseDelim);
			}

		state->PushCurrentFont();
		state->fontName         = JGetMonospaceFontName();
		state->font.size        = kHTMLPointSize[2];		// 3rd is default size
		state->font.style.color = colormap->GetBlackColor();
		state->UpdateFontID();
		}

	else if (kHTMLHeader1 <= cmd && cmd <= kHTMLHeader6)
		{
		AppendNewlinesForHTML(2, buffer, styles, state);

		state->PushCurrentFont();

		(state->font).size       = kHTMLHeaderFontSize[ cmd - kHTMLHeader1 ];
		(state->font).style.bold = kTrue;
		state->UpdateFontID();

		(state->fontFlagUse[ kHTMLBoldUseIndex ])++;
		}

	else if (cmd == kHTMLHead)
		{
		IgnoreUntilHTMLClose(input, "/head");
		}
	else if (cmd == kHTMLForm)
		{
		IgnoreUntilHTMLClose(input, "/form");
		}
	else if (cmd == kHTMLMap)
		{
		IgnoreUntilHTMLClose(input, "/map");
		}

	else if (cmd == kHTMLUnordList)
		{
		state->NewList(kUnordList, buffer, styles);
		}

	else if (cmd == kHTMLOrdList)
		{
		state->NewList(kOrdList, buffer, styles);
		}

	else if (cmd == kHTMLTermList)
		{
		state->NewList(kDefTermList, buffer, styles);
		}

	else if (cmd == kHTMLListElement && state->listType == kUnordList)
		{
		state->NewListItem(buffer, styles);
		AppendCharsForHTML(buffer, "* ", styles, state->font);
		}
	else if (cmd == kHTMLListElement && state->listType == kOrdList)
		{
		state->NewListItem(buffer, styles);

		JString str(state->listIndex, 0);
		str += ". ";
		AppendCharsForHTML(buffer, str, styles, state->font);
		}
	else if (cmd == kHTMLListElement)
		{
		AppendCharsForHTML(buffer, "\n*** Html List Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}

	else if (cmd == kHTMLDefTerm &&
			 (state->listType == kDefTermList || state->listType == kDefDataList))
		{
		state->NewListItem(buffer, styles);
		state->listType = kDefTermList;
		}
	else if (cmd == kHTMLDefData &&
			 (state->listType == kDefTermList || state->listType == kDefDataList))
		{
		state->NewListItem(buffer, styles);
		state->listType = kDefDataList;
		AppendCharsForHTML(buffer, "\t", styles, state->font);		// extra indent for data
		}
	else if (cmd == kHTMLDefTerm || cmd == kHTMLDefData)
		{
		AppendCharsForHTML(buffer, "\n*** Html List Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}
}

/******************************************************************************
 HandleHTMLOffCmd (local)

 ******************************************************************************/

void
HandleHTMLOffCmd
	(
	const HTMLCmd					cmd,
	JString*						buffer,
	JRunArray<JTextEditor::Font>*	styles,
	HTMLParserState*				state
	)
{
	if (cmd == kHTMLBlockquote && state->indentCount == 0)
		{
		AppendCharsForHTML(buffer, "\n*** Html Blockquote Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}
	else if (cmd == kHTMLBlockquote)
		{
		AppendNewlinesForHTML(2, buffer, styles, state);
		(state->indentCount)--;
		}

	else if (cmd == kHTMLBold && state->fontFlagUse[ kHTMLBoldUseIndex ] == 0)
		{
		AppendCharsForHTML(buffer, "\n*** Html Font Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}
	else if (cmd == kHTMLBold)
		{
		(state->fontFlagUse[ kHTMLBoldUseIndex ])--;
		if (state->fontFlagUse[ kHTMLBoldUseIndex ] == 0)
			{
			(state->font).style.bold = kFalse;
			state->UpdateFontID();
			}
		}

	else if (cmd == kHTMLItalic && state->fontFlagUse[ kHTMLItalicUseIndex ] == 0)
		{
		AppendCharsForHTML(buffer, "\n*** Html Font Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}
	else if (cmd == kHTMLItalic)
		{
		(state->fontFlagUse[ kHTMLItalicUseIndex ])--;
		if (state->fontFlagUse[ kHTMLItalicUseIndex ] == 0)
			{
			(state->font).style.italic = kFalse;
			state->UpdateFontID();
			}
		}

	else if (cmd == kHTMLUnderline && state->fontFlagUse[ kHTMLUnderlineUseIndex ] == 0)
		{
		AppendCharsForHTML(buffer, "\n*** Html Font Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}
	else if (cmd == kHTMLUnderline)
		{
		(state->fontFlagUse[ kHTMLUnderlineUseIndex ])--;
		if (state->fontFlagUse[ kHTMLUnderlineUseIndex ] == 0)
			{
			(state->font).style.underlineCount = 0;
			state->UpdateFontID();
			}
		}

	else if (cmd == kHTMLStrike && state->fontFlagUse[ kHTMLStrikeUseIndex ] == 0)
		{
		AppendCharsForHTML(buffer, "\n*** Html Font Error ***\n", styles, state->font);
		state->newlineCount = 1;
		}
	else if (cmd == kHTMLStrike)
		{
		(state->fontFlagUse[ kHTMLStrikeUseIndex ])--;
		if (state->fontFlagUse[ kHTMLStrikeUseIndex ] == 0)
			{
			(state->font).style.strike = kFalse;
			state->UpdateFontID();
			}
		}

	else if (cmd == kHTMLFont)
		{
		state->PopFont(buffer, styles);
		}

	else if (cmd == kHTMLMonospace)
		{
		state->PopFont(buffer, styles);
		}

	else if (cmd == kHTMLPreformatted)
		{
		if (state->newlineCount == 0 && buffer->GetLastCharacter() == '\n')
			{
			state->newlineCount = 1;
			}
		AppendNewlinesForHTML(2, buffer, styles, state);

		state->SetDelimiters(kHTMLAllDelim);
		state->PopFont(buffer, styles);
		}

	else if (kHTMLHeader1 <= cmd && cmd <= kHTMLHeader6 &&
			 (state->fontStack).IsEmpty())
		{
		AppendCharsForHTML(buffer, "\n*** Html Header Error ***\n", styles, state->font);
		(state->fontNameStack).ClearDelete();
		state->newlineCount = 1;
		}
	else if (kHTMLHeader1 <= cmd && cmd <= kHTMLHeader6)
		{
		AppendNewlinesForHTML(2, buffer, styles, state);

		const JTextEditor::Font f = (state->fontStack).Pop();
		(state->font).size        = f.size;

		// too late to complain about excess </b>
		if (state->fontFlagUse[ kHTMLBoldUseIndex ] > 0)
			{
			(state->fontFlagUse[ kHTMLBoldUseIndex ])--;
			}
		if (state->fontFlagUse[ kHTMLBoldUseIndex ] == 0)
			{
			(state->font).style.bold = kFalse;
			}

		(state->fontNameStack).UnwindDelete(1);

		state->UpdateFontID();
		}

	else if (cmd == kHTMLUnordList || cmd == kHTMLOrdList ||
			 cmd == kHTMLTermList)
		{
		state->EndList(buffer, styles);
		}
}

/******************************************************************************
 ParseHTMLCmd (local)

 ******************************************************************************/

HTMLCmd
ParseHTMLCmd
	(
	istream&	input,
	JString*	attribText,
	bool*	on
	)
{
	const JCharacter delims[] = { ' ', '\n', '\t', '>' };
	const JSize delimCount    = sizeof(delims)/sizeof(JCharacter);

	input >> ws;
	JString cmd;
	JCharacter delim = '>';		// this is the default if we hit end-of-file
	JReadUntil(input, delimCount, delims, &cmd, &delim);
	if (cmd.GetFirstCharacter() == '/')
		{
		*on = kFalse;
		cmd.RemoveSubstring(1,1);
		}
	else
		{
		*on = kTrue;
		}
	cmd.ToLower();

	if (delim != '>')
		{
		input >> ws;
		*attribText = JReadUntil(input, '>');
		attribText->TrimWhitespace();
		}
	else
		{
		attribText->Clear();
		}

	if (cmd == "p")
		{
		input >> ws;
		return kHTMLNewParagraph;
		}
	else if (cmd == "br")
		{
		input >> ws;
		return kHTMLLineBreak;
		}
	else if (cmd == "hr")
		{
		input >> ws;
		return kHTMLHorizRule;
		}

	else if (cmd == "blockquote")
		{
		return kHTMLBlockquote;
		}

	else if (cmd == "b" || cmd == "strong")
		{
		return kHTMLBold;
		}
	else if (cmd == "i" || cmd == "em" || cmd == "cite" ||
			 cmd == "address" || cmd == "var")
		{
		return kHTMLItalic;
		}
	else if (cmd == "u")
		{
		return kHTMLUnderline;
		}
	else if (cmd == "s")
		{
		return kHTMLStrike;
		}
	else if (cmd == "font")
		{
		return kHTMLFont;
		}

	else if (cmd == "tt" || cmd == "code" || cmd == "samp")
		{
		return kHTMLMonospace;
		}
	else if (cmd == "pre")
		{
		if (input.peek() == '\n')
			{
			input.ignore();
			}
		return kHTMLPreformatted;
		}

	else if (cmd == "h1")
		{
		input >> ws;
		return kHTMLHeader1;
		}
	else if (cmd == "h2")
		{
		input >> ws;
		return kHTMLHeader2;
		}
	else if (cmd == "h3")
		{
		input >> ws;
		return kHTMLHeader3;
		}
	else if (cmd == "h4")
		{
		input >> ws;
		return kHTMLHeader4;
		}
	else if (cmd == "h5")
		{
		input >> ws;
		return kHTMLHeader5;
		}
	else if (cmd == "h6")
		{
		input >> ws;
		return kHTMLHeader6;
		}

	else if (cmd == "head")
		{
		return kHTMLHead;
		}
	else if (cmd == "form")
		{
		return kHTMLForm;
		}
	else if (cmd == "map")
		{
		return kHTMLMap;
		}

	else if (cmd == "dir" || cmd == "menu" || cmd == "ul")
		{
		input >> ws;
		return kHTMLUnordList;
		}
	else if (cmd == "ol")
		{
		input >> ws;
		return kHTMLOrdList;
		}
	else if (cmd == "li")
		{
		input >> ws;
		return kHTMLListElement;
		}

	else if (cmd == "dl")
		{
		input >> ws;
		return kHTMLTermList;
		}
	else if (cmd == "dt")
		{
		input >> ws;
		return kHTMLDefTerm;
		}
	else if (cmd == "dd")
		{
		input >> ws;
		return kHTMLDefData;
		}

	else if (cmd == "img" || cmd == "isindex" || cmd == "nobr" || cmd == "wbr" ||
			 cmd == "basefont" || cmd.BeginsWith("!--") || cmd == "frame" || 
			 cmd == "link" || cmd == "base" || cmd == "nextid")
		{
		return kHTMLEmpty;
		}

	else
		{
		return kHTMLNOP;
		}
}

/******************************************************************************
 ParseHTMLFontAttribs (local)

 ******************************************************************************/

void
ParseHTMLFontAttribs
	(
	const JString&			attribText,
	HTMLParserState*		state,
	JColormap*				colormap,
	JArray<JColorIndex>**	colorList
	)
{
	if (attribText.IsEmpty())
		{
		return;
		}

	jistrstream(input, const_cast<JCharacter*>(attribText.GetCString()),
				attribText.GetLength());

	while (1)
		{
		input >> ws;

		bool found;
		JString attrib = JReadUntil(input, '=', &found);
		if (!found)
			{
			break;
			}
		attrib.TrimWhitespace();
		attrib.ToLower();

		input >> ws;
		JString type = JReadUntilws(input);
		if (type.GetFirstCharacter() == '\"' &&
			type.GetLastCharacter()  == '\"')
			{
			type.RemoveSubstring(1,1);
			type.RemoveSubstring(type.GetLength(), type.GetLength());
			}

		if (attrib == "size")
			{
			bool relPlus  = kFalse;
			bool relMinus = kFalse;
			if (type.GetFirstCharacter() == '+')
				{
				type.RemoveSubstring(1,1);
				relPlus = kTrue;
				}
			else if (type.GetFirstCharacter() == '-')
				{
				type.RemoveSubstring(1,1);
				relMinus = kTrue;
				}

			JInteger value;
			if (isdigit(type.GetFirstCharacter()) &&
				type.ConvertToInteger(&value))
				{
				if (relPlus)
					{
					value += 3;
					}
				else if (relMinus)
					{
					value = 3 - value;
					}

				if (value < 1)
					{
					value = 1;
					}
				else if (value > 7)
					{
					value = 7;
					}

				(state->font).size = kHTMLPointSize[value-1];
				}
			}

		else if (attrib == "face")
			{
			state->fontName = type;
			}

		else if (attrib == "color")
			{
			(state->font).style.color =
				JTextEditor::ColorNameToColorIndex(type, colormap, colorList);
			}
		}

	state->UpdateFontID();
}

/******************************************************************************
 ParseHTMLEscapedChar (local)

 ******************************************************************************/

JString
ParseHTMLEscapedChar
	(
	istream& input
	)
{
	const kMinCount = 2;
	const kMaxCount = 6;

	const JCharacter* kName2[] = { "lt", "gt" };
	const JCharacter kValue2[] = { '<', '>' };
	const JSize kCount2        = sizeof(kValue2)/sizeof(JCharacter);

	const JCharacter* kName3[] = { "amp", "yen", "uml", "die", "not", "shy", "reg",
								   "deg", "ETH", "eth" };
	const JCharacter kValue3[] = { '&'   , '\xa5', '\xa8', '\xa8', '\xac', '\xad', '\xae',
								   '\xb0', '\xd0', '\xf0'};
	const JSize kCount3        = sizeof(kValue3)/sizeof(JCharacter);

	const JCharacter* kName4[] = { "quot", "nbsp", "cent", "sect", "copy", "ordf",
								   "macr", "sup2", "sup3", "para", "sup1", "ordm",
								   "Auml", "Euml", "Iuml", "Ouml", "Uuml", "auml",
								   "euml", "iuml", "ouml", "uuml", "yuml" };
	const JCharacter kValue4[] = { '"'   , '\xa0', '\xa2', '\xa7', '\xa9', '\xaa',
								   '\xaf', '\xb2', '\xb3', '\xb6', '\xb9', '\xba',
								   '\xc4', '\xcb', '\xcf', '\xd6', '\xdc', '\xe4',
								   '\xeb', '\xef', '\xf6', '\xfc', '\xff' };
	const JSize kCount4        = sizeof(kValue4)/sizeof(JCharacter);

	const JCharacter* kName5[] = { "iexcl", "pound", "laquo", "hibar", "acute", "micro",
								   "cedil", "raquo", "Acirc", "Aring", "AElig", "Ecirc",
								   "Icirc", "Ocirc", "times", "Ucirc", "THORN", "szlig",
								   "acirc", "aring", "aelig", "ecirc", "icirc", "ocirc",
								   "ucirc", "thorn" };
	const JCharacter kValue5[] = { '\xa1', '\xa3', '\xab', '\xaf', '\xb4', '\xb5',
								   '\xb8', '\xbb', '\xc2', '\xc5', '\xc6', '\xca',
								   '\xce', '\xd4', '\xd7', '\xdb', '\xde', '\xdf',
								   '\xe2', '\xe5', '\xe6', '\xea', '\xee', '\xf4',
								   '\xfb', '\xfe' };
	const JSize kCount5        = sizeof(kValue5)/sizeof(JCharacter);

	const JCharacter* kName6[] = { "curren", "brvbar", "brkbar", "plusmn", "middot",
								   "frac14", "frac12", "frac34", "iquest", "Agrave",
								   "Aacute", "Atilde", "Ccedil", "Egrave", "Eacute",
								   "Igrave", "Iacute", "Dstrok", "Ntilde", "Ograve",
								   "Oacute", "Otilde", "Oslash", "Ugrave", "Uacute",
								   "Yacute", "agrave", "aacute", "atilde", "ccedil",
								   "egrave", "eacute", "igrave", "iacute", "ntilde",
								   "ograve", "oacute", "otilde", "divide", "oslash",
								   "ugrave", "uacute", "yacute" };
	const JCharacter kValue6[] = { '\xa4', '\xa6', '\xa6', '\xb1', '\xb7',
								   '\xbc', '\xbd', '\xbe', '\xbf', '\xc0',
								   '\xc1', '\xc3', '\xc7', '\xc8', '\xc9',
								   '\xcc', '\xcd', '\xd0', '\xd1', '\xd2',
								   '\xd3', '\xd5', '\xd8', '\xd9', '\xda',
								   '\xdd', '\xe0', '\xe1', '\xe3', '\xe7',
								   '\xe8', '\xe9', '\xec', '\xed', '\xf1',
								   '\xf2', '\xf3', '\xf5', '\xf7', '\xf8',
								   '\xf9', '\xfa', '\xfd' };
	const JSize kCount6        = sizeof(kValue6)/sizeof(JCharacter);

	const JSize kCount[]       = {kCount2, kCount3, kCount4, kCount5, kCount6};
	const JCharacter** kName[] = {kName2, kName3, kName4, kName5, kName6};
	const JCharacter* kValue[] = {kValue2, kValue3, kValue4, kValue5, kValue6};

	JCharacter c;
	input.get(c);
	if (c == '#' && isdigit(input.peek()))
		{
		int asciiValue;
		input >> asciiValue;
		if (input.peek() == ';')
			{
			input.ignore();
			}

		const JCharacter s[2] = { (JCharacter) asciiValue, '\0' };
		return JString(s);
		}
	else if (c == '#')
		{
		return JString("&#");
		}
	else if (c == ';')
		{
		return JString("&");
		}
	else if (c == '&' || isspace(c))
		{
		input.putback(c);
		return JString("&");
		}

	JCharacter buffer[kMaxCount+1];
	buffer[0] = c;
	buffer[1] = '\0';

	for (JSize count=kMinCount; count<=kMaxCount; count++)
		{
		input.get(c);
		if (c == ';')
			{
			break;
			}
		else if (c == '&' || isspace(c))
			{
			input.putback(c);
			break;
			}

		buffer[count-1] = c;
		buffer[count]   = '\0';

		const JSize j = count-kMinCount;
		for (JIndex i=0; i<kCount[j]; i++)
			{
			if (strcmp(kName[j][i], buffer) == 0)
				{
				if (input.peek() == ';')
					{
					input.ignore();
					}

				const JCharacter s[2] = { kValue[j][i], '\0' };
				return JString(s);
				}
			}
		}

	// give up

	JString s(buffer);
	s.Prepend("&");
	return s;
}

/******************************************************************************
 IgnoreUntilHTMLClose (local)

	Discards characters until '<'+ws+delimiter+ws+'>' is encountered.

 ******************************************************************************/

void
IgnoreUntilHTMLClose
	(
	istream&			input,
	const JCharacter*	delimiter
	)
{
	const JSize delimLength = strlen(delimiter);
	assert( delimLength > 0 );

	while (1)
		{
		bool found;
		JIgnoreUntil(input, '<', &found);
		if (!found)
			{
			break;
			}

		input >> ws;

		JSize offset = 0;
		while (offset < delimLength)
			{
			JCharacter c;
			input.get(c);
			if (c != delimiter[offset])
				{
				found = kFalse;
				break;
				}
			offset++;
			}
		if (found)
			{
			JIgnoreUntil(input, '>');
			return;
			}
		}
}

/******************************************************************************
 Search and replace

 ******************************************************************************/

/******************************************************************************
 SearchForward

	Look for the next match beyond the current position.
	If we find it, we select it and return kTrue.

 ******************************************************************************/

bool
JTextEditor::SearchForward
	(
	const JCharacter*	searchStr,
	const bool		caseSensitive,
	const bool		entireWord,
	const bool		wrapSearch,
	bool*			wrapped
	)
{
	JIndex startIndex;
	if (itsHasSelectionFlag)
		{
		startIndex = itsSelection.end + 1;
		}
	else
		{
		startIndex = itsCaretLoc.charIndex;
		}

	const JIndex origStartIndex = startIndex;

	*wrapped = kFalse;
	const JSize bufLength = itsBuffer->GetLength();
	if (startIndex > bufLength && wrapSearch)
		{
		startIndex = 1;
		*wrapped   = kTrue;
		}
	else if (startIndex > bufLength)
		{
		return kFalse;
		}

	const JSize searchLength = strlen(searchStr);

	bool found = kFalse;
	while (1)
		{
		found = itsBuffer->LocateNextSubstring(searchStr, searchLength,
											   caseSensitive, &startIndex);
		if (found && entireWord)
			{
			found = IsEntireWord(startIndex, startIndex + searchLength - 1);
			}

		if (found)
			{
			break;
			}

		startIndex++;
		if (!found && startIndex > bufLength && wrapSearch && !(*wrapped))
			{
			startIndex = 1;
			*wrapped   = kTrue;
			}
		else if ((!found && startIndex > bufLength) ||
				 (!found && *wrapped && startIndex >= origStartIndex))
			{
			break;
			}
		}

	if (found)
		{
		SetSelection(startIndex, startIndex + searchLength - 1);
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 SearchBackward

	Look for the match before the current position.
	If we find it, we select it and return kTrue.

 ******************************************************************************/

bool
JTextEditor::SearchBackward
	(
	const JCharacter*	searchStr,
	const bool		caseSensitive,
	const bool		entireWord,
	const bool		wrapSearch,
	bool*			wrapped
	)
{
	JIndex startIndex;
	if (itsHasSelectionFlag)
		{
		startIndex = itsSelection.start;
		}
	else
		{
		startIndex = itsCaretLoc.charIndex;
		}
	startIndex--;

	const JIndex origStartIndex = startIndex;

	*wrapped = kFalse;
	const JSize bufLength = itsBuffer->GetLength();
	if (startIndex == 0 && wrapSearch)
		{
		startIndex = bufLength;
		*wrapped   = kTrue;
		}
	else if (startIndex == 0)
		{
		return kFalse;
		}

	const JSize searchLength = strlen(searchStr);

	bool found = kFalse;
	while (1)
		{
		found = itsBuffer->LocatePrevSubstring(searchStr, searchLength,
											   caseSensitive, &startIndex);
		if (found && entireWord)
			{
			found = IsEntireWord(startIndex, startIndex + searchLength - 1);
			}

		if (found)
			{
			break;
			}

		if (startIndex > 0)
			{
			startIndex--;
			}
		if (!found && startIndex == 0 && wrapSearch && !(*wrapped))
			{
			startIndex = bufLength;
			*wrapped   = kTrue;
			}
		else if ((!found && startIndex == 0) ||
				 (!found && *wrapped && startIndex <= origStartIndex))
			{
			break;
			}
		}

	if (found)
		{
		SetSelection(startIndex, startIndex + searchLength - 1);
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 SelectionMatches

	Returns kTrue if the current selection matches the given search criteria.
	This should always be checked before doing a replace.

 ******************************************************************************/

bool
JTextEditor::SelectionMatches
	(
	const JCharacter*	searchStr,
	const bool		caseSensitive,
	const bool		entireWord
	)
{
	const JSize searchLength = strlen(searchStr);
	if (!itsHasSelectionFlag ||
		itsSelection.end - itsSelection.start + 1 != searchLength ||
		(entireWord && !IsEntireWord(itsSelection.start, itsSelection.end)))
		{
		return kFalse;
		}

	JIndex startIndex = itsSelection.start;
	return JConvertToBoolean(
		itsBuffer->LocateNextSubstring(searchStr, searchLength,
									   caseSensitive, &startIndex) &&
		startIndex == itsSelection.start);
}

/******************************************************************************
 SearchForward

	Look for the next match beyond the current position.
	If we find it, we select it and return kTrue.

 ******************************************************************************/

bool
JTextEditor::SearchForward
	(
	const JRegex&			regex,
	const bool			entireWord,
	const bool			wrapSearch,
	bool*				wrapped,
	JArray<JStringRange>*	submatchList
	)
{
	JIndex startIndex;
	if (itsHasSelectionFlag)
		{
		startIndex = itsSelection.end + 1;
		}
	else
		{
		startIndex = itsCaretLoc.charIndex;
		}

	const JIndex origStartIndex = startIndex;

	*wrapped = kFalse;
	const JSize bufLength = itsBuffer->GetLength();
	if (startIndex > bufLength && wrapSearch)
		{
		startIndex = 1;
		*wrapped   = kTrue;
		}
	else if (startIndex > bufLength)
		{
		return kFalse;
		}

	bool found = kFalse;
	JStringRange all;
	while (1)
		{
		found = regex.MatchFrom(*itsBuffer, startIndex, submatchList);
		if (found)
			{
			all        = submatchList->GetElement(1);
			startIndex = all.GetFirst();
			found      = JNegate( all.IsEmpty() );
			if (found &&
				(!entireWord || IsEntireWord(all.GetFirst(), all.GetLast())))
				{
				break;
				}
			found = kFalse;
			}
		else
			{
			startIndex = bufLength+1;
			}

		startIndex++;
		if (!found && startIndex > bufLength && wrapSearch && !(*wrapped))
			{
			startIndex = 1;
			*wrapped   = kTrue;
			}
		else if (!found &&
				 (startIndex > bufLength ||
				  (*wrapped && startIndex >= origStartIndex)))
			{
			break;
			}
		}

	if (found)
		{
		SetSelection(all.GetFirst(), all.GetLast());
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 SearchBackward

	Look for the match before the current position.
	If we find it, we select it and return kTrue.

 ******************************************************************************/

bool
JTextEditor::SearchBackward
	(
	const JRegex&			regex,
	const bool			entireWord,
	const bool			wrapSearch,
	bool*				wrapped,
	JArray<JStringRange>*	submatchList
	)
{
	JIndex startIndex;
	if (itsHasSelectionFlag)
		{
		startIndex = itsSelection.start;
		}
	else
		{
		startIndex = itsCaretLoc.charIndex;
		}
	startIndex--;

	const JIndex origStartIndex = startIndex;

	*wrapped = kFalse;
	const JSize bufLength = itsBuffer->GetLength();
	if (startIndex == 0 && wrapSearch)
		{
		startIndex = bufLength;
		*wrapped   = kTrue;
		}
	else if (startIndex == 0)
		{
		return kFalse;
		}

	bool found = kFalse;
	JStringRange all;
	while (1)
		{
		found = JConvertToBoolean(
			regex.MatchLastWithin(*itsBuffer, JStringRange(1, startIndex), submatchList) > 0);
		if (found)
			{
			all        = submatchList->GetElement(1);
			startIndex = all.GetFirst();
			found      = JNegate( all.IsEmpty() );
			if (found &&
				(!entireWord || IsEntireWord(all.GetFirst(), all.GetLast())))
				{
				break;
				}
			found = kFalse;
			}
		else
			{
			startIndex = 0;
			}

		if (startIndex > 0)
			{
			startIndex--;
			}
		if (!found && startIndex == 0 && wrapSearch && !(*wrapped))
			{
			startIndex = bufLength;
			*wrapped   = kTrue;
			}
		else if (!found &&
				 (startIndex == 0 ||
				  (*wrapped && startIndex <= origStartIndex)))
			{
			break;
			}
		}

	if (found)
		{
		SetSelection(all.GetFirst(), all.GetLast());
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 SelectionMatches

	Returns kTrue if the current selection matches the given search criteria.
	This should always be checked before doing a replace.

	*** submatchList is relative to the start of the selected text.

 ******************************************************************************/

bool
JTextEditor::SelectionMatches
	(
	const JRegex&			regex,
	const bool			entireWord,
	JArray<JStringRange>*	submatchList
	)
{
	if (!itsHasSelectionFlag ||
		(entireWord && !IsEntireWord(itsSelection.start, itsSelection.end)))
		{
		return kFalse;
		}

	const JStringRange searchRange(1, itsSelection.end - itsSelection.start + 1);
	return JConvertToBoolean(
		regex.MatchWithin(itsBuffer->GetCString() + itsSelection.start-1,
						  searchRange, submatchList) &&
		submatchList->GetElement(1) == searchRange);
}

/******************************************************************************
 SetBreakCROnly

 ******************************************************************************/

void
JTextEditor::SetBreakCROnly
	(
	const bool breakCROnly
	)
{
	if (breakCROnly != itsBreakCROnlyFlag)
		{
		itsBreakCROnlyFlag = breakCROnly;
		if (!itsBreakCROnlyFlag)
			{
			itsWidth = itsGUIWidth;
			}
		RecalcAll();
		}
}

/******************************************************************************
 TESetBoundsWidth (protected)

	Call this to notify us of a change in aperture width.

 ******************************************************************************/

void
JTextEditor::TESetBoundsWidth
	(
	const JCoordinate width
	)
{
	itsGUIWidth = width - itsLeftMarginWidth - kRightMarginWidth;
	assert( itsGUIWidth > 0 );
	TEGUIWidthChanged();
}

/******************************************************************************
 TESetLeftMarginWidth (protected)

	For multi-line input areas it helps to have a wide left margin where
	one can click and drag down to select entire lines.

 ******************************************************************************/

void
JTextEditor::TESetLeftMarginWidth
	(
	const JCoordinate origWidth
	)
{
	const JCoordinate width = JMax((long) kMinLeftMarginWidth, origWidth);

	if (width != itsLeftMarginWidth)
		{
		itsGUIWidth       += itsLeftMarginWidth;
		itsLeftMarginWidth = width;
		itsGUIWidth       -= itsLeftMarginWidth;
		TEGUIWidthChanged();
		}
}

/******************************************************************************
 TEGUIWidthChanged (private)

 ******************************************************************************/

void
JTextEditor::TEGUIWidthChanged()
{
	if (itsBreakCROnlyFlag)
		{
		TERefresh();
		}
	else if (itsWidth != itsGUIWidth)
		{
		itsWidth = itsGUIWidth;
		RecalcAll();
		}
}

/******************************************************************************
 Get current font

 ******************************************************************************/

const JCharacter*
JTextEditor::GetCurrentFontName()
	const
{
	const Font f = GetCurrentFont();
	return itsFontMgr->GetFontName(f.id);
}

JSize
JTextEditor::GetCurrentFontSize()
	const
{
	const Font f = GetCurrentFont();
	return f.size;
}

JFontStyle
JTextEditor::GetCurrentFontStyle()
	const
{
	const Font f = GetCurrentFont();
	return f.style;
}

void
JTextEditor::GetCurrentFont
	(
	JString*	name,
	JSize*		size,
	JFontStyle*	style
	)
	const
{
	const Font f = GetCurrentFont();
	*name  = itsFontMgr->GetFontName(f.id);
	*size  = f.size;
	*style = f.style;
}

// protected

JTextEditor::Font
JTextEditor::GetCurrentFont()
	const
{
	if (itsHasSelectionFlag)
		{
		return itsStyles->GetElement(itsSelection.start);
		}
	else
		{
		return itsInsertionFont;
		}
}

/******************************************************************************
 Set current font

 ******************************************************************************/

void
JTextEditor::SetCurrentFontName
	(
	const JCharacter* name
	)
{
	if (itsHasSelectionFlag)
		{
		bool isNew;
		JTEUndoStyle* undo = GetStyleUndo(&isNew);

		const bool changed =
			SetFontName(itsSelection.start, itsSelection.end, name, kFalse);

		if (changed && isNew)
			{
			NewUndo(undo);
			}
		else if (isNew)
			{
			delete undo;
			}
		}
	else
		{
		itsInsertionFont.id =
			itsFontMgr->GetFontID(name, itsInsertionFont.size, itsInsertionFont.style);
		}
}

void
JTextEditor::SetCurrentFontSize
	(
	const JSize size
	)
{
	#define LocalVarName      size
	#define StructElementName size
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFontBold
	(
	const bool bold
	)
{
	#define LocalVarName      bold
	#define StructElementName style.bold
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFontItalic
	(
	const bool italic
	)
{
	#define LocalVarName      italic
	#define StructElementName style.italic
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFontUnderline
	(
	const JSize count
	)
{
	#define LocalVarName      count
	#define StructElementName style.underlineCount
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFontStrike
	(
	const bool strike
	)
{
	#define LocalVarName      strike
	#define StructElementName style.strike
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFontColor
	(
	const JColorIndex color
	)
{
	#define LocalVarName      color
	#define StructElementName style.color
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFontStyle
	(
	const JFontStyle& style
	)
{
	#define LocalVarName      style
	#define StructElementName style
	#include <JTESetFont.th>
	#undef LocalVarName
	#undef StructElementName
}

void
JTextEditor::SetCurrentFont
	(
	const JCharacter*	name,
	const JSize			size,
	const JFontStyle&	style
	)
{
	SetCurrentFont(Font(itsFontMgr->GetFontID(name, size, style), size, style));
}

// protected

void
JTextEditor::SetCurrentFont
	(
	const Font& f
	)
{
	if (itsHasSelectionFlag)
		{
		bool isNew;
		JTEUndoStyle* undo = GetStyleUndo(&isNew);

		SetFont(itsSelection.start, itsSelection.end, f, kFalse);

		if (isNew)
			{
			NewUndo(undo);
			}
		}
	else
		{
		itsInsertionFont = f;
		}
}

/******************************************************************************
 Get font

 ******************************************************************************/

const JCharacter*
JTextEditor::GetFontName
	(
	const JIndex charIndex
	)
	const
{
	const Font f = itsStyles->GetElement(charIndex);
	return itsFontMgr->GetFontName(f.id);
}

JSize
JTextEditor::GetFontSize
	(
	const JIndex charIndex
	)
	const
{
	const Font f = itsStyles->GetElement(charIndex);
	return f.size;
}

JFontStyle
JTextEditor::GetFontStyle
	(
	const JIndex charIndex
	)
	const
{
	const Font f = itsStyles->GetElement(charIndex);
	return f.style;
}

void
JTextEditor::GetFont
	(
	const JIndex	charIndex,
	JString*		name,
	JSize*			size,
	JFontStyle*		style
	)
	const
{
	const Font f = itsStyles->GetElement(charIndex);
	*name  = itsFontMgr->GetFontName(f.id);
	*size  = f.size;
	*style = f.style;
}

/******************************************************************************
 Set font

	Returns kTrue if anything actually changed

 ******************************************************************************/

bool
JTextEditor::SetFontName
	(
	const JIndex		startIndex,
	const JIndex		endIndex,
	const JCharacter*	name,
	const bool		clearUndo
	)
{
	if (clearUndo)
		{
		ClearUndo();
		}

	Font f;
	bool changed = kFalse;
	JRunArrayIterator<Font> iter(itsStyles, kIteratorStartBefore, startIndex);
	for (JIndex i=startIndex; i<=endIndex; i++)
		{
		const bool ok = iter.Next(&f);
		assert( ok );

		const JFontID newID = itsFontMgr->GetFontID(name, f.size, f.style);
		if (newID != f.id)
			{
			f.id = newID;
			iter.SetPrev(f);
			changed = kTrue;
			}
		}

	if (changed)
		{
		Recalc(startIndex, endIndex - startIndex + 1);
		}

	return changed;
}

bool
JTextEditor::SetFontSize
	(
	const JIndex	startIndex,
	const JIndex	endIndex,
	const JSize		size,
	const bool	clearUndo
	)
{
	if (clearUndo)
		{
		ClearUndo();
		}

	Font f;
	bool changed = kFalse;
	JRunArrayIterator<Font> iter(itsStyles, kIteratorStartBefore, startIndex);
	for (JIndex i=startIndex; i<=endIndex; i++)
		{
		const bool ok = iter.Next(&f);
		assert( ok );

		if (size != f.size)
			{
			f.size = size;

			const JCharacter* name = itsFontMgr->GetFontName(f.id);
			f.id = itsFontMgr->GetFontID(name, f.size, f.style);
			iter.SetPrev(f);
			changed = kTrue;
			}
		}

	if (changed)
		{
		Recalc(startIndex, endIndex - startIndex + 1);
		}

	return changed;
}

bool
JTextEditor::SetFontStyle
	(
	const JIndex		startIndex,
	const JIndex		endIndex,
	const JFontStyle&	style,
	const bool		clearUndo
	)
{
	if (clearUndo)
		{
		ClearUndo();
		}

	Font f;
	bool changed = kFalse;
	JRunArrayIterator<Font> iter(itsStyles, kIteratorStartBefore, startIndex);
	for (JIndex i=startIndex; i<=endIndex; i++)
		{
		const bool ok = iter.Next(&f);
		assert( ok );

		if (style != f.style)
			{
			f.style = style;

			const JCharacter* name = itsFontMgr->GetFontName(f.id);
			f.id = itsFontMgr->GetFontID(name, f.size, f.style);
			iter.SetPrev(f);
			changed = kTrue;
			}
		}

	if (changed)
		{
		Recalc(startIndex, endIndex - startIndex + 1);
		}

	return changed;
}

void
JTextEditor::SetFont
	(
	const JIndex		startIndex,
	const JIndex		endIndex,
	const JCharacter*	name,
	const JSize			size,
	const JFontStyle&	style,
	const bool		clearUndo
	)
{
	SetFont(startIndex, endIndex,
			Font(itsFontMgr->GetFontID(name, size, style), size, style), clearUndo);
}

// protected

void
JTextEditor::SetFont
	(
	const JIndex		startIndex,
	const JIndex		endIndex,
	const Font&			f,
	const bool		clearUndo
	)
{
	if (clearUndo)
		{
		ClearUndo();
		}

	if (endIndex > startIndex)
		{
		const JSize charCount = endIndex - startIndex + 1;
		itsStyles->RemoveNextElements(startIndex, charCount);
		itsStyles->InsertElementsAtIndex(startIndex, f, charCount);
		Recalc(startIndex, charCount);
		}
	else
		{
		assert( startIndex == endIndex );

		itsStyles->SetElement(startIndex, f);
		Recalc(startIndex, 1);
		}
}

// protected

void
JTextEditor::SetFont
	(
	const JIndex			startIndex,
	const JRunArray<Font>&	fontList,
	const bool			clearUndo
	)
{
	if (clearUndo)
		{
		ClearUndo();
		}

	Font f;
	JRunArrayIterator<Font> fIter(fontList);
	JRunArrayIterator<Font> sIter(itsStyles, kIteratorStartBefore, startIndex);

	while (fIter.Next(&f) && sIter.SetNext(f))
		{
		sIter.SkipNext();
		}

	Recalc(startIndex, fontList.GetElementCount());
}

/******************************************************************************
 SetAllFontNameAndSize (protected)

	This function is useful for unstyled text editors that allow the user
	to change the font and size.

	It preserves the styles, in case they are controlled by the program.
	(e.g. context sensitive hilighting)

	You can choose whether or not to throw out all Undo information.
	Unstyled text editors can usually preserve Undo, since they will not
	allow the user to modify styles.  (We explicitly ask for this because
	it is too easy to forget about the issue.)

 ******************************************************************************/

void
JTextEditor::SetAllFontNameAndSize
	(
	const JCharacter*	name,
	const JSize			size,
	const JCoordinate	tabWidth,
	const bool		clearUndo
	)
{
	if (clearUndo)
		{
		ClearUndo();
		}

	const JSize runCount = itsStyles->GetRunCount();
	for (JIndex i=1; i<=runCount; i++)
		{
		Font f = itsStyles->GetRunData(i);
		f.size = size;
		f.id   = itsFontMgr->GetFontID(name, f.size, f.style);
		itsStyles->SetRunData(i, f);
		}

	if (itsUndoList != NULL)
		{
		const JSize undoCount = itsUndoList->GetElementCount();
		for (JIndex i=1; i<=undoCount; i++)
			{
			(itsUndoList->NthElement(i))->SetFont(name, size);
			}
		}
	else if (itsUndo != NULL)
		{
		itsUndo->SetFont(name, size);
		}

	itsInsertionFont.size = size;
	itsInsertionFont.id =
		itsFontMgr->GetFontID(name, itsInsertionFont.size, itsInsertionFont.style);

	SetDefaultFont(name, size, itsDefFont.style);

	itsDefTabWidth = tabWidth;
	RecalcAll();
}

/******************************************************************************
 Get default font

 ******************************************************************************/

const JCharacter*
JTextEditor::GetDefaultFontName()
	const
{
	return itsFontMgr->GetFontName(itsDefFont.id);
}

void
JTextEditor::GetDefaultFont
	(
	JString*	name,
	JSize*		size,
	JFontStyle*	style
	)
	const
{
	*name  = GetDefaultFontName();
	*size  = itsDefFont.size;
	*style = itsDefFont.style;
}

/******************************************************************************
 Set default font

 ******************************************************************************/

void
JTextEditor::SetDefaultFontName
	(
	const JCharacter* name
	)
{
	itsDefFont.id = itsFontMgr->GetFontID(name, itsDefFont.size, itsDefFont.style);
	if (itsBuffer->IsEmpty())
		{
		itsInsertionFont = CalcInsertionFont(1);
		}
}

void
JTextEditor::SetDefaultFontSize
	(
	const JSize size
	)
{
	itsDefFont.size = size;
	itsDefFont.id   =
		itsFontMgr->GetFontID(GetDefaultFontName(), itsDefFont.size, itsDefFont.style);
	if (itsBuffer->IsEmpty())
		{
		itsInsertionFont = CalcInsertionFont(1);
		}
}

void
JTextEditor::SetDefaultFontStyle
	(
	const JFontStyle& style
	)
{
	itsDefFont.style = style;
	itsDefFont.id    =
		itsFontMgr->GetFontID(GetDefaultFontName(), itsDefFont.size, itsDefFont.style);
	if (itsBuffer->IsEmpty())
		{
		itsInsertionFont = CalcInsertionFont(1);
		}
}

void
JTextEditor::SetDefaultFont
	(
	const JFontID		id,
	const JSize			size,
	const JFontStyle&	style
	)
{
	itsDefFont.id    = id;
	itsDefFont.size  = size;
	itsDefFont.style = style;

	if (itsBuffer->IsEmpty())
		{
		itsInsertionFont = CalcInsertionFont(1);
		}
}

/******************************************************************************
 Cut

 ******************************************************************************/

void
JTextEditor::Cut()
{
	TECreateClipboard();

	if (Cut(itsClipText, itsClipStyle))
		{
		TEClipboardChanged();
		}
}

/******************************************************************************
 Cut

	Returns kTrue if there was anything to cut.  style can be NULL.
	If function returns kFalse, text and style are not modified.

 ******************************************************************************/

bool
JTextEditor::Cut
	(
	JString*			text,
	JRunArray<Font>*	style
	)
{
	if (Copy(text, style))
		{
		DeleteSelection();
		DeactivateCurrentUndo();
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 Copy

 ******************************************************************************/

void
JTextEditor::Copy()
{
	TECreateClipboard();

	if (Copy(itsClipText, itsClipStyle))
		{
		TEClipboardChanged();
		}
}

/******************************************************************************
 Copy

	Returns kTrue if there was anything to copy.  style can be NULL.
	If function returns kFalse, text and style are not modified, so
	we cannot call GetSelection().

 ******************************************************************************/

bool
JTextEditor::Copy
	(
	JString*			text,
	JRunArray<Font>*	style
	)
	const
{
	if (itsHasSelectionFlag)
		{
		*text = itsBuffer->GetSubstring(itsSelection.start, itsSelection.end);
		style->RemoveAll();
		style->InsertElementsAtIndex(1, *itsStyles, itsSelection.start,
									 itsSelection.end - itsSelection.start + 1);
		return kTrue;
		}
	else
		{
		return kFalse;
		}
}

/******************************************************************************
 GetClipboard

	Returns the text and style that would be pasted if Paste() were called.

	style can be NULL.  If it is not NULL, it can come back empty even if
	the function returns kTrue.

 ******************************************************************************/

bool
JTextEditor::GetClipboard
	(
	JString*			text,
	JRunArray<Font>*	style
	)
	const
{
	if (TEOwnsClipboard() && itsClipText != NULL)
		{
		*text = *itsClipText;
		if (style != NULL)
			{
			*style = *itsClipStyle;
			}
		return kTrue;
		}
	else if (style != NULL)
		{
		return TEGetExternalClipboard(text, style);
		}
	else
		{
		JRunArray<Font> tempStyle;
		return TEGetExternalClipboard(text, &tempStyle);
		}
}

/******************************************************************************
 Paste

 ******************************************************************************/

void
JTextEditor::Paste()
{
	JString text;
	JRunArray<Font> style;
	if (TEOwnsClipboard() && itsClipText != NULL)
		{
		Paste(*itsClipText, itsClipStyle);
		}
	else if (TEGetExternalClipboard(&text, &style))
		{
		if (style.IsEmpty())
			{
			Paste(text);
			}
		else
			{
			Paste(text, &style);
			}
		}
}

/******************************************************************************
 Paste

	style can be NULL

 ******************************************************************************/

void
JTextEditor::Paste
	(
	const JCharacter*		text,
	const JRunArray<Font>*	style
	)
{
	JSize pasteLength;
	if (style != NULL)
		{
		pasteLength = style->GetElementCount();
		}
	else
		{
		pasteLength = strlen(text);
		}

	JTEUndoPaste* newUndo = NULL;
	if (ContainsIllegalChars(text, pasteLength))
		{
		JString newText(text, pasteLength);
		JRunArray<Font>* newStyle = NULL;
		if (style != NULL)
			{
			newStyle = new JRunArray<Font>(*style);
			assert( newStyle != NULL );
			}
		RemoveIllegalChars(&newText, newStyle);

		newUndo = new JTEUndoPaste(this, newText.GetLength());
		PrivatePaste(newText, newStyle);

		delete newStyle;
		}
	else
		{
		newUndo = new JTEUndoPaste(this, pasteLength);
		PrivatePaste(text, style);
		}

	assert( newUndo != NULL );
	NewUndo(newUndo);
}

/******************************************************************************
 PrivatePaste (private)

	style can be NULL

 ******************************************************************************/

void
JTextEditor::PrivatePaste
	(
	const JCharacter*		text,
	const JRunArray<Font>*	style
	)
{
	if (itsHasSelectionFlag)
		{
		DeleteText(itsSelection.start, itsSelection.end);
		itsHasSelectionFlag = kFalse;
		itsCaretLoc         = CalcCaretLocation(itsSelection.start);
		itsInsertionFont    = CalcInsertionFont(itsCaretLoc.charIndex);
		}

	if (itsPasteStyledTextFlag)
		{
		InsertText(itsCaretLoc.charIndex, text, style);
		}
	else
		{
		InsertText(itsCaretLoc.charIndex, text);
		}

	const JSize textLen = strlen(text);
	Recalc(itsCaretLoc, textLen);
	SetCaretLocation(itsCaretLoc.charIndex + textLen);
}

/******************************************************************************
 GetInternalClipboard (protected)

	Returns kTrue if our internal clipboard contains something.

	style can be NULL.

 ******************************************************************************/

bool
JTextEditor::GetInternalClipboard
	(
	JString*			text,
	JRunArray<Font>*	style
	)
	const
{
	if (itsClipText != NULL && itsClipStyle != NULL)
		{
		*text = *itsClipText;
		if (style != NULL)
			{
			*style = *itsClipStyle;
			}
		return kTrue;
		}
	else
		{
		text->Clear();
		if (style != NULL)
			{
			style->RemoveAll();
			}
		return kFalse;
		}
}

/******************************************************************************
 TECreateClipboard (private)

	Allocate itsClipText and itsClipStyle.

 ******************************************************************************/

void
JTextEditor::TECreateClipboard()
{
	assert( (itsClipText == NULL && itsClipStyle == NULL) ||
			(itsClipText != NULL && itsClipStyle != NULL) );

	if (itsClipText == NULL)
		{
		itsClipText = new JString;
		assert( itsClipText != NULL );

		itsClipStyle = new JRunArray<Font>;
		assert( itsClipStyle != NULL );
		}
}

/******************************************************************************
 TEClearClipboard (protected)

	Delete itsClipText and itsClipStyle.

 ******************************************************************************/

void
JTextEditor::TEClearClipboard()
{
	delete itsClipText;
	itsClipText = NULL;

	delete itsClipStyle;
	itsClipStyle = NULL;
}

/******************************************************************************
 GetInsertionIndex

	Return the index where new text will be typed or pasted.

 ******************************************************************************/

JIndex
JTextEditor::GetInsertionIndex()
	const
{
	if (itsHasSelectionFlag)
		{
		return itsSelection.start;
		}
	else
		{
		return itsCaretLoc.charIndex;
		}
}

/******************************************************************************
 GetSelection

 ******************************************************************************/

bool
JTextEditor::GetSelection
	(
	JString* text
	)
	const
{
	if (itsHasSelectionFlag)
		{
		*text = itsBuffer->GetSubstring(itsSelection.start, itsSelection.end);
		return kTrue;
		}
	else
		{
		text->Clear();
		return kFalse;
		}
}

bool
JTextEditor::GetSelection
	(
	JString*			text,
	JRunArray<Font>*	style
	)
	const
{
	style->RemoveAll();

	if (itsHasSelectionFlag)
		{
		*text = itsBuffer->GetSubstring(itsSelection.start, itsSelection.end);
		style->InsertElementsAtIndex(1, *itsStyles, itsSelection.start,
									 itsSelection.end - itsSelection.start + 1);
		return kTrue;
		}
	else
		{
		text->Clear();
		return kFalse;
		}
}

/******************************************************************************
 SetSelection

 ******************************************************************************/

void
JTextEditor::SetSelection
	(
	const JIndex startIndex,
	const JIndex endIndex
	)
{
	DeactivateCurrentUndo();
	if (itsBuffer->IsEmpty() ||
		(itsHasSelectionFlag &&
		 itsSelection.start == startIndex &&
		 itsSelection.end   == endIndex))
		{
		return;
		}

	assert( IndexValid(startIndex) );
	assert( IndexValid(endIndex) );
	assert( startIndex <= endIndex );

	const bool hadSelection      = itsHasSelectionFlag;
	const CaretLocation origCaretLoc = itsCaretLoc;
	const Selection origSelection    = itsSelection;

	itsHasSelectionFlag = kTrue;
	itsCaretLoc         = CaretLocation(0,0);
	itsSelection.start  = startIndex;
	itsSelection.end    = endIndex;

	const JIndex newStartLine = GetLineForChar(itsSelection.start);
	const JIndex newEndLine   = GetLineForChar(itsSelection.end);

	Broadcast(CaretLineChanged(newStartLine));

	// We only optimize heavily for the case when one end of the
	// selection remains fixed because this is the case during mouse drags.

	if (hadSelection && origSelection.start == itsSelection.start)
		{
		const JIndex origEndLine = GetLineForChar(origSelection.end);
		TERefreshLines(JMin(origEndLine, newEndLine),
					   JMax(origEndLine, newEndLine));
		}
	else if (hadSelection && origSelection.end == itsSelection.end)
		{
		const JIndex origStartLine = GetLineForChar(origSelection.start);
		TERefreshLines(JMin(origStartLine, newStartLine),
					   JMax(origStartLine, newStartLine));
		}
	else if (hadSelection)
		{
		const JIndex origStartLine = GetLineForChar(origSelection.start);
		const JIndex origEndLine   = GetLineForChar(origSelection.end);
		TERefreshLines(origStartLine, origEndLine);
		TERefreshLines(newStartLine, newEndLine);
		}
	else
		{
		TERefreshCaret(origCaretLoc);
		TERefreshLines(newStartLine, newEndLine);
		}
}

/******************************************************************************
 SelectAll

 ******************************************************************************/

void
JTextEditor::SelectAll()
{
	if (!itsBuffer->IsEmpty())
		{
		SetSelection(1, itsBuffer->GetLength());
		}
}

/******************************************************************************
 DeleteSelection

	We create JTEUndoTyping so keys pressed after the delete key count
	as part of the undo task.

 ******************************************************************************/

void
JTextEditor::DeleteSelection()
{
	if (itsHasSelectionFlag)
		{
		JTEUndoTyping* newUndo = new JTEUndoTyping(this);
		assert( newUndo != NULL );

		DeleteText(itsSelection.start, itsSelection.end);
		Recalc(itsSelection.start, itsSelection.end - itsSelection.start + 1);
		SetCaretLocation(itsSelection.start);

		NewUndo(newUndo);
		}
}

/******************************************************************************
 DeleteToStartOfWord

	Delete characters until start-of-word is reached.

 ******************************************************************************/

void
JTextEditor::DeleteToStartOfWord()
{
	if (itsCaretLoc.charIndex > 1)
		{
		if (!itsHasSelectionFlag)
			{
			const JIndex startIndex = GetWordStart(itsCaretLoc.charIndex-1);
			SetSelection(startIndex, itsCaretLoc.charIndex-1);
			}

		DeleteSelection();
		}
}

/******************************************************************************
 DeleteToEndOfWord

	Delete characters until end-of-word is reached.

 ******************************************************************************/

void
JTextEditor::DeleteToEndOfWord()
{
	if (itsCaretLoc.charIndex <= itsBuffer->GetLength())
		{
		if (!itsHasSelectionFlag)
			{
			const JIndex endIndex = GetWordEnd(itsCaretLoc.charIndex);
			SetSelection(itsCaretLoc.charIndex, endIndex);
			}

		DeleteSelection();
		}
}

/******************************************************************************
 TabSelectionLeft

	Remove tabs from the beginning of every selected line.  If nothing
	is selected, we select the line that the caret is on.

 ******************************************************************************/

void
JTextEditor::TabSelectionLeft
	(
	const JSize tabCount
	)
{
JIndex i,j;

	JIndex firstLine, lastLine;
	if (itsHasSelectionFlag)
		{
		firstLine = GetLineForChar(itsSelection.start);
		lastLine  = GetLineForChar(itsSelection.end);
		}
	else if (!itsBuffer->IsEmpty())
		{
		firstLine = lastLine = itsCaretLoc.lineIndex;
		}
	else
		{
		return;
		}

	// check that there are enough tabs at the start of every selected line

	for (i=firstLine; i<=lastLine; i++)
		{
		const JIndex firstChar = GetLineStart(i);
		for (j=firstChar; j<firstChar+tabCount; j++)
			{
			const JCharacter c = itsBuffer->GetCharacter(j);
			if (c != '\t' && c != '\n')
				{
				return;
				}
			if (c == '\n')
				{
				break;	// line is blank or contains only tabs
				}
			}
		}

	bool isNew;
	JTEUndoTabShift* undo = GetTabShiftUndo(firstLine, lastLine, &isNew);
	undo->HandleShiftLeft(tabCount);

	itsHasSelectionFlag = kFalse;
	JSize deleteCount   = 0;
	for (i=firstLine; i<=lastLine; i++)
		{
		const JIndex charIndex = GetLineStart(i) - deleteCount;
		for (j=1; j<=tabCount; j++)
			{
			// The deletion point stays in same place (charIndex) and
			// simply eats characters.

			if (itsBuffer->GetCharacter(charIndex) != '\t')
				{
				break;
				}
			DeleteText(charIndex, charIndex);
			deleteCount++;
			}
		}

	const JIndex startIndex = GetLineStart(firstLine);
	const JIndex endIndex   = GetLineEnd(lastLine);
	Recalc(startIndex, endIndex - startIndex + 1);

	SetSelection(startIndex, endIndex - deleteCount);
	undo->Activate();	// cancel SetSelection()

	if (isNew)
		{
		NewUndo(undo);
		}
}

/******************************************************************************
 TabSelectionRight

	Insert a tab at the beginning of every selected line.  If nothing
	is selected, we select the line that the caret is on.

 ******************************************************************************/

void
JTextEditor::TabSelectionRight
	(
	const JSize tabCount
	)
{
JIndex i;

	JIndex firstLine, lastLine;
	if (itsHasSelectionFlag)
		{
		firstLine = GetLineForChar(itsSelection.start);
		lastLine  = GetLineForChar(itsSelection.end);
		}
	else if (!itsBuffer->IsEmpty())
		{
		firstLine = lastLine = itsCaretLoc.lineIndex;
		}
	else
		{
		return;
		}

	bool isNew;
	JTEUndoTabShift* undo = GetTabShiftUndo(firstLine, lastLine, &isNew);
	undo->HandleShiftRight(tabCount);

	JString tabs;
	for (i=1; i<=tabCount; i++)
		{
		tabs.AppendCharacter('\t');
		}

	itsHasSelectionFlag = kFalse;
	JSize insertCount   = 0;
	for (i=firstLine; i<=lastLine; i++)
		{
		const JIndex charIndex = GetLineStart(i) + insertCount;
		if (itsBuffer->GetCharacter(charIndex) != '\n')
			{
			InsertText(charIndex, tabs);
			insertCount += tabCount;
			}
		}

	const JIndex startIndex = GetLineStart(firstLine);
	const JIndex endIndex   = GetLineEnd(lastLine) + insertCount;
	Recalc(startIndex, endIndex - startIndex + 1);

	SetSelection(startIndex, endIndex);
	undo->Activate();	// cancel SetSelection()

	if (isNew)
		{
		NewUndo(undo);
		}
}

/******************************************************************************
 CleanAllRightMargins

	Cleans up the right margin of the entire text by repeatedly calling
	CleanRightMargin().

	This puts the caret at the top of the text.

 ******************************************************************************/

void
JTextEditor::CleanAllRightMargins()
{
	JIndex index = 1;
	while (index <= itsBuffer->GetLength())
		{
		SetCaretLocation(index);

		JIndex i,j;
		if (CleanRightMargin(&i, &j))
			{
			index = j+2;
			}
		else
			{
			index = GetParagraphEnd(index) + 1;
			}
		}

	SetCaretLocation(1);
}

/******************************************************************************
 CleanRightMargin

	Cleans up the right margin of the paragraph containing the caret or
	start of selection.  Maintains the position of the caret.

	If the caret was in a paragraph, returns kTrue and sets *firstChar to
	the first character of reformatted text and *lastChar to the last
	character (the character before the newline).

	The work done by this function can be changed by overriding the
	various CRM*() functions.

 ******************************************************************************/

bool
JTextEditor::CleanRightMargin
	(
	JIndex* firstChar,
	JIndex* lastChar
	)
{
	if (itsBuffer->IsEmpty())
		{
		*firstChar = *lastChar = 0;
		return kFalse;
		}

	const JIndex caretChar = GetInsertionIndex();
	if (caretChar == itsBuffer->GetLength()+1 &&		// ends with newline
		EndsWithNewline())
		{
		*firstChar = *lastChar = 0;
		return kFalse;
		}

	JIndex startChar, endChar;
	if (!CRMGetRange(caretChar, &startChar, &endChar))
		{
		*firstChar = *lastChar = 0;
		return kFalse;
		}

	JIndex charIndex = startChar;
	JString linePrefix;
	JSize prefixLength;
	if (!CRMGetPrefix(&charIndex, endChar, &linePrefix, &prefixLength))
		{
		*firstChar = *lastChar = 0;
		return kFalse;
		}

	JIndex newCaretIndex = 0;
	if (caretChar <= charIndex)
		{
		newCaretIndex = caretChar;
		}

	// read in each word, convert it, write it out

	JString  newText;
	JSize    currentLineWidth = 0;
	bool needSpace        = kFalse;

	JString wordBuffer, spaceBuffer;
	while (charIndex <= endChar)
		{
		JSize spaceCount;
		JIndex rnwCaretIndex = 0;
		const CRMStatus status =
			CRMReadNextWord(&charIndex, endChar,
							&spaceBuffer, &spaceCount, &wordBuffer,
							currentLineWidth, caretChar, &rnwCaretIndex);

		if (status == kFinished)
			{
			assert( charIndex == endChar+1 );
			break;
			}
		else if (status == kFoundWord)
			{
			// After a newline, the whitespace may have been tossed
			// as belonging to the prefix, but we still need some space.

			if (needSpace && spaceCount == 0)
				{
				spaceBuffer = " ";
				spaceCount  = 1;
				if (rnwCaretIndex > 0)
					{
					rnwCaretIndex++;
					}
				}
			needSpace = kFalse;

			// add the word to the new text

			CRMAppendWord(&newText, &currentLineWidth, &rnwCaretIndex,
						  spaceBuffer, spaceCount, wordBuffer,
						  linePrefix, prefixLength);

			// save new caret location

			if (rnwCaretIndex > 0)
				{
				newCaretIndex = startChar + rnwCaretIndex - 1;
				}
			}
		else
			{
			assert( status == kFoundNewLine );

			CRMTossLinePrefix(&charIndex, endChar);
			needSpace = kTrue;

			if (newCaretIndex == 0 && caretChar <= charIndex)
				{
				newCaretIndex = startChar + newText.GetLength();
				}
			}
		}

	if (caretChar == endChar+1)
		{
		newCaretIndex = startChar + newText.GetLength();
		}

	// replace the text

	SetSelection(startChar, endChar);
	Paste(newText);

	// maintain the position of the caret

	assert( newCaretIndex != 0 );
	SetCaretLocation(newCaretIndex);

	*firstChar = startChar;
	*lastChar  = startChar + newText.GetLength() - 1;
	return kTrue;
}

/*******************************************************************************
 CRMGetRange (virtual protected)

	Returns the range of characters to reformat.
	Returns kFalse if the caret is not in a paragraph.

	caretChar is the current location of the caret.

	The default is to search forward and backward from the caret location
	for blank lines and include all the text between these blank lines.
	Blank lines are defined as lines that contain nothing but prefix characters.

 ******************************************************************************/

bool
JTextEditor::CRMGetRange
	(
	const JIndex	caretChar,
	JIndex*			startChar,
	JIndex*			endChar
	)
	const
{
	*startChar = GetParagraphStart(caretChar);
	*endChar   = GetParagraphEnd(caretChar);

	if (itsBuffer->GetCharacter(*endChar) == '\n')
		{
		(*endChar)--;
		}

	if (*endChar < *startChar ||
		CRMLineIsBlank(*startChar, *endChar))
		{
		return kFalse;
		}

	// search backwards for a blank line
	// (If *startChar==2, the line above us is blank.)

	while (*startChar > 2)
		{
		const JIndex newStart = GetParagraphStart(*startChar - 1);
		if (newStart > *startChar - 2 ||
			CRMLineIsBlank(newStart, *startChar - 2))
			{
			break;
			}
		*startChar = newStart;
		}

	// search backwards for a blank line
	// (If *endChar==bufLength-1, the text ends with a newline.)

	while (*endChar < itsBuffer->GetLength()-1)
		{
		JIndex newEnd = GetParagraphEnd(*endChar + 2);
		if (itsBuffer->GetCharacter(newEnd) == '\n')
			{
			newEnd--;
			}

		if (newEnd < *endChar + 2 ||
			CRMLineIsBlank(*endChar + 2, newEnd))
			{
			break;
			}
		*endChar = newEnd;
		}

	return kTrue;
}

/*******************************************************************************
 CRMLineIsBlank (private)

	Returns kTrue if the given range is nothing but prefix characters.

 ******************************************************************************/

bool
JTextEditor::CRMLineIsBlank
	(
	const JIndex startChar,
	const JIndex endChar
	)
	const
{
	JIndex charIndex = startChar;
	JString linePrefix;
	JSize prefixLength;
	return JNegate(CRMGetPrefix(&charIndex, endChar, &linePrefix, &prefixLength));
}

/*******************************************************************************
 CRMGetPrefix (virtual protected)

	Returns the prefix to be used for each line and updates *startChar to point
	to the first character after the prefix.

	*prefixLength is set to the length of *linePrefix in characters.  This
	can be greater than linePrefix->GetLength() because of tabs.

	Returns kFalse if the entire range qualifies as a prefix.

	The default is to collect all character approved by CRMIsPrefixChar().

 ******************************************************************************/

bool
JTextEditor::CRMGetPrefix
	(
	JIndex*			startChar,
	const JIndex	endChar,
	JString*		linePrefix,
	JSize*			prefixLength
	)
	const
{
	linePrefix->Clear();
	*prefixLength = 0;

	while (*startChar <= endChar)
		{
		const JCharacter c = itsBuffer->GetCharacter(*startChar);
		if (!CRMIsPrefixChar(c))
			{
			break;
			}

		if (c == '\t')
			{
			CRMConvertTab(linePrefix, prefixLength, 0);
			}
		else
			{
			linePrefix->AppendCharacter(c);
			(*prefixLength)++;
			}

		(*startChar)++;
		}

	return JConvertToBoolean(*startChar <= endChar);
}

/*******************************************************************************
 CRMTossLinePrefix (virtual protected)

	Increments *charIndex past whatever qualifies as a line prefix.

	The default is to toss all character approved by CRMIsPrefixChar().

 ******************************************************************************/

void
JTextEditor::CRMTossLinePrefix
	(
	JIndex*			charIndex,
	const JIndex	endChar
	)
	const
{
	while (*charIndex <= endChar &&
		   CRMIsPrefixChar(itsBuffer->GetCharacter(*charIndex)))
		{
		(*charIndex)++;
		}
}

/*******************************************************************************
 CRMIsPrefixChar (virtual protected)

	Returns kTrue if the given character is part of the line prefix.

	The default is to return kTrue for spaces and tabs.

	To implement a scheme with memory, override CRMGetPrefix() and
	CRMTossLinePrefix() instead.

 ******************************************************************************/

bool
JTextEditor::CRMIsPrefixChar
	(
	const JCharacter c
	)
	const
{
	return JConvertToBoolean( c == ' ' || c == '\t' );
}

/*******************************************************************************
 CRMConvertTab (virtual protected)

	Appends the tab to *charBuffer and increments *charCount appropriately.
	The default is to physically append the tab character and use
	CRMGetTabWidth() to increment *charCount.  Note that *charCount may be
	longer than charBuffer->GetLength().

	currentLineWidth is the number of characters on the line -excluding-
	what is in *charBuffer.

	Derived classes can override this to, for example, append some spaces
	instead of a tab character.  (How's that for splitting an infinitive?)

 ******************************************************************************/

void
JTextEditor::CRMConvertTab
	(
	JString*	charBuffer,
	JSize*		charCount,
	const JSize	currentLineWidth
	)
	const
{
	charBuffer->AppendCharacter('\t');
	*charCount += CRMGetTabWidth(currentLineWidth + *charCount);
}

/*******************************************************************************
 CRMGetTabWidth (virtual protected)

	Returns the number of spaces to which the tab is equivalent.
	The default is to round up to the nearest multiple of CRMGetTabCharCount().
	The default value for this is 8 since this is what all UNIX programs use.

	textColumn starts at zero at the left margin.

 ******************************************************************************/

JSize
JTextEditor::CRMGetTabWidth
	(
	const JIndex textColumn
	)
	const
{
	return itsCRMTabCharCount - (textColumn % itsCRMTabCharCount);
}

/*******************************************************************************
 CRMReadNextWord (private)

	Read one block of { spaces + word (non-spaces) } from itsBuffer, starting
	at *charIndex, stopping if we get as far as endIndex.  *spaceBuffer
	contains the whitespace (spaces + tabs) that was found.  *spaceCount is
	the equivalent number of spaces.  *wordBuffer contains the word.
	*charIndex is incremented to point to the next character to read.

	Newlines are treated separately.  If a newline is encountered while reading
	spaces, we throw out the spaces and return kFoundNewLine.  If a newline
	is encountered while reading a word, we leave it for the next time, when
	we immediately return kFoundNewLine.  

	When we pass the position origCaretIndex, we set *newCaretIndex to be
	the index into *spaceBuffer+*wordBuffer.  Otherwise, we do not change
	*newCaretIndex.

 ******************************************************************************/

JTextEditor::CRMStatus
JTextEditor::CRMReadNextWord
	(
	JIndex*			charIndex,
	const JIndex	endIndex,
	JString*		spaceBuffer,
	JSize*			spaceCount,
	JString*		wordBuffer,
	const JSize		currentLineWidth,
	const JIndex	origCaretIndex,
	JIndex*			newCaretIndex
	)
	const
{
	// read the whitespace

	spaceBuffer->Clear();
	*spaceCount = 0;

	while (*charIndex <= endIndex)
		{
		if (*charIndex == origCaretIndex)
			{
			*newCaretIndex = spaceBuffer->GetLength() + 1;
			}

		const JCharacter c = itsBuffer->GetCharacter(*charIndex);
		if (c == ' ')
			{
			(*charIndex)++;
			spaceBuffer->AppendCharacter(c);
			(*spaceCount)++;
			}
		else if (c == '\t')
			{
			(*charIndex)++;
			CRMConvertTab(spaceBuffer, spaceCount, currentLineWidth);
			}
		else if (c == '\n')			// we can ignore the spaces
			{
			(*charIndex)++;
			spaceBuffer->Clear();
			*spaceCount = 0;
			return kFoundNewLine;
			}
		else						// found beginning of word
			{
			break;
			}
		}

	if (*charIndex == endIndex+1)	// we can ignore the spaces
		{
		return kFinished;
		}

	// read the word

	wordBuffer->Clear();

	while (*charIndex <= endIndex)
		{
		if (*charIndex == origCaretIndex)
			{
			*newCaretIndex = spaceBuffer->GetLength() + wordBuffer->GetLength() + 1;
			}

		const JCharacter c = itsBuffer->GetCharacter(*charIndex);
		if (c == ' ' || c == '\t' || c == '\n')
			{
			return kFoundWord;
			}

		wordBuffer->AppendCharacter(c);
		(*charIndex)++;
		}

	return kFoundWord;
}

/*******************************************************************************
 CRMAppendWord (private)

	Add the spaces and word to new text, maintaining the required line width.

	If *newCaretIndex>0, we convert it from an index in spaceBuffer+wordBuffer
	to an index in newText.

 ******************************************************************************/

void
JTextEditor::CRMAppendWord
	(
	JString*		newText,
	JSize*			currentLineWidth,
	JIndex*			newCaretIndex,
	const JString&	spaceBuffer,
	const JSize		spaceCount,
	const JString&	wordBuffer,
	const JString&	linePrefix,
	const JSize		prefixLength
	)
	const
{
	const JSize newLineWidth = *currentLineWidth + spaceCount + wordBuffer.GetLength();
	if (*currentLineWidth == 0 || newLineWidth > itsCRMLineWidth)
		{
		// terminate previous line

		if (!newText->IsEmpty())
			{
			newText->AppendCharacter('\n');
			}
		*newText += linePrefix;

		// write word

		if (*newCaretIndex > 0)
			{
			if (*newCaretIndex <= spaceCount)
				{
				*newCaretIndex = 1;				// in spaces that we toss
				}
			else
				{
				*newCaretIndex -= spaceCount;	// in word
				}

			*newCaretIndex += newText->GetLength();
			}

		*newText          += wordBuffer;
		*currentLineWidth  = prefixLength + wordBuffer.GetLength();
		}
	else if (newLineWidth < itsCRMLineWidth)
		{
		// append spaces + word at end of line

		if (*newCaretIndex > 0)
			{
			*newCaretIndex += newText->GetLength();
			}

		*newText += spaceBuffer;
		*newText += wordBuffer;

		*currentLineWidth = newLineWidth;
		}
	else	// newLineWidth == itsCRMLineWidth
		{
		// write spaces + word at end of line

		if (*newCaretIndex > 0)
			{
			*newCaretIndex += newText->GetLength();
			}

		*newText += spaceBuffer;
		*newText += wordBuffer;

		*currentLineWidth = 0;
		}
}

/******************************************************************************
 Undo

 ******************************************************************************/

void
JTextEditor::Undo()
{
	assert( itsUndoState == kIdle );

	JTEUndoBase* undo;
	const bool hasUndo = GetCurrentUndo(&undo);
	if (hasUndo && itsType == kFullEditor)
		{
		itsUndoState = kUndo;
		undo->Deactivate();
		undo->Undo();
		itsUndoState = kIdle;
		}
	else if (hasUndo)
		{
		ClearUndo();
		}
}

/******************************************************************************
 Redo

 ******************************************************************************/

void
JTextEditor::Redo()
{
	assert( itsUndoState == kIdle );

	JTEUndoBase* undo;
	const bool hasUndo = GetCurrentRedo(&undo);
	if (hasUndo && itsType == kFullEditor)
		{
		itsUndoState = kRedo;
		undo->Deactivate();
		undo->Undo();
		itsUndoState = kIdle;
		}
	else if (hasUndo)
		{
		ClearUndo();
		}
}

/******************************************************************************
 DeactivateCurrentUndo

 ******************************************************************************/

void
JTextEditor::DeactivateCurrentUndo()
{
	JTEUndoBase* undo = NULL;
	if (GetCurrentUndo(&undo))
		{
		undo->Deactivate();
		}
}

/******************************************************************************
 ClearUndo

	Avoid calling this whenever possible since it throws away -all-
	undo information.

 ******************************************************************************/

void
JTextEditor::ClearUndo()
{
	delete itsUndo;
	itsUndo = NULL;

	if (itsUndoList != NULL)
		{
		itsUndoList->DeleteAll();
		}
	itsFirstRedoIndex = 1;
}

/******************************************************************************
 UseMultipleUndo

	You probably never need to turn off multiple undo unless you
	are running out of memory.

 ******************************************************************************/

void
JTextEditor::UseMultipleUndo
	(
	const bool doIt
	)
{
	if (doIt && itsUndoList == NULL)
		{
		ClearUndo();

		itsUndoList = new JPtrArray<JTEUndoBase>(itsMaxUndoCount+1);
		assert( itsUndoList != NULL );
		}
	else if (!doIt && itsUndoList != NULL)
		{
		ClearUndo();

		delete itsUndoList;
		itsUndoList = NULL;
		}
}

/******************************************************************************
 SetUndoDepth

 ******************************************************************************/

void
JTextEditor::SetUndoDepth
	(
	const JSize maxUndoCount
	)
{
	assert( maxUndoCount > 0 );

	itsMaxUndoCount = maxUndoCount;
	ClearOutdatedUndo();
}

/******************************************************************************
 GetCurrentUndo (private)

 ******************************************************************************/

bool
JTextEditor::GetCurrentUndo
	(
	JTEUndoBase** undo
	)
	const
{
	if (itsUndoList != NULL && itsFirstRedoIndex > 1)
		{
		*undo = itsUndoList->NthElement(itsFirstRedoIndex - 1);
		return kTrue;
		}
	else if (itsUndoList != NULL)
		{
		return kFalse;
		}
	else
		{
		*undo = itsUndo;
		return JConvertToBoolean( *undo != NULL );
		}
}

/******************************************************************************
 GetCurrentRedo (private)

 ******************************************************************************/

bool
JTextEditor::GetCurrentRedo
	(
	JTEUndoBase** redo
	)
	const
{
	if (itsUndoList != NULL && itsFirstRedoIndex <= itsUndoList->GetElementCount())
		{
		*redo = itsUndoList->NthElement(itsFirstRedoIndex);
		return kTrue;
		}
	else if (itsUndoList != NULL)
		{
		return kFalse;
		}
	else
		{
		*redo = itsUndo;
		return JConvertToBoolean( *redo != NULL );
		}
}

/******************************************************************************
 NewUndo (private)

	Register a new Undo object.

	itsFirstRedoIndex points to the first redo object in itsUndoList.
	1 <= itsFirstRedoIndex <= itsUndoList->GetElementCount()+1
	Minimum => everything is redo
	Maximum => everything is undo

 ******************************************************************************/

void
JTextEditor::NewUndo
	(
	JTEUndoBase* undo
	)
{
	if (itsUndoList != NULL && itsUndoState == kIdle)
		{
		// clear redo objects

		const JSize undoCount = itsUndoList->GetElementCount();
		for (JIndex i=undoCount; i>=itsFirstRedoIndex; i--)
			{
			itsUndoList->DeleteElement(i);
			}

		// save the new object

		itsUndoList->Append(undo);
		itsFirstRedoIndex++;

		ClearOutdatedUndo();
		assert( !itsUndoList->IsEmpty() );
		}

	else if (itsUndoList != NULL && itsUndoState == kUndo)
		{
		assert( itsFirstRedoIndex > 1 );

		itsFirstRedoIndex--;
		JTEUndoBase* oldUndo = itsUndoList->NthElement(itsFirstRedoIndex);
		delete oldUndo;
		itsUndoList->SetElement(itsFirstRedoIndex, undo);

		undo->SetRedo(kTrue);
		undo->Deactivate();
		}

	else if (itsUndoList != NULL && itsUndoState == kRedo)
		{
		assert( itsFirstRedoIndex <= itsUndoList->GetElementCount() );

		JTEUndoBase* oldRedo = itsUndoList->NthElement(itsFirstRedoIndex);
		delete oldRedo;
		itsUndoList->SetElement(itsFirstRedoIndex, undo);
		itsFirstRedoIndex++;

		undo->SetRedo(kFalse);
		undo->Deactivate();
		}

	else
		{
		delete itsUndo;
		itsUndo = undo;
		}

	Broadcast(TextChanged());
}

/******************************************************************************
 SameUndo (private)

	Called by Undo objects to notify us that there was actually nothing
	to do, so the same object can be re-used.

 ******************************************************************************/

void
JTextEditor::SameUndo
	(
	JTEUndoBase* undo
	)
{
	assert( itsUndoState != kIdle );

	if (itsUndoList != NULL && itsUndoState == kUndo)
		{
		assert( itsFirstRedoIndex > 1 );

		itsFirstRedoIndex--;
		assert( undo == itsUndoList->NthElement(itsFirstRedoIndex) );

		undo->SetRedo(kTrue);
		}

	else if (itsUndoList != NULL && itsUndoState == kRedo)
		{
		assert( itsFirstRedoIndex <= itsUndoList->GetElementCount() );

		assert( undo == itsUndoList->NthElement(itsFirstRedoIndex) );
		itsFirstRedoIndex++;

		undo->SetRedo(kFalse);
		}

	else if (itsUndoList == NULL)
		{
		assert( undo == itsUndo );
		}

	undo->Deactivate();

	// nothing changed, so we don't broadcast TextChanged
}

/******************************************************************************
 ReplaceUndo (private)

 ******************************************************************************/

void
JTextEditor::ReplaceUndo
	(
	JTEUndoBase* oldUndo,
	JTEUndoBase* newUndo
	)
{
#ifndef NDEBUG

	assert( itsUndoState != kIdle );

	if (itsUndoList != NULL && itsUndoState == kUndo)
		{
		assert( itsFirstRedoIndex > 1 &&
				oldUndo == itsUndoList->GetElement(itsFirstRedoIndex - 1) );
		}
	else if (itsUndoList != NULL && itsUndoState == kRedo)
		{
		assert( itsFirstRedoIndex <= itsUndoList->GetElementCount() &&
				oldUndo == itsUndoList->GetElement(itsFirstRedoIndex) );
		}
	else
		{
		assert( oldUndo == itsUndo );
		}

#endif

	NewUndo(newUndo);
}

/******************************************************************************
 ClearOutdatedUndo (private)

 ******************************************************************************/

void
JTextEditor::ClearOutdatedUndo()
{
	if (itsUndoList != NULL)
		{
		JSize undoCount = itsUndoList->GetElementCount();
		while (undoCount > itsMaxUndoCount)
			{
			itsUndoList->DeleteElement(1);
			undoCount--;
			itsFirstRedoIndex--;

			// If we have to throw out redo's, we have to toss everything.

			if (itsFirstRedoIndex == 0)
				{
				ClearUndo();
				break;
				}
			}
		}
}

/******************************************************************************
 GetTypingUndo (private)

	Return the active JTEUndoTyping object.  If the current undo object is
	not an active JTEUndoTyping object, we create a new one that is active.

	If we create a new object, *isNew = kTrue, and the caller is required
	to call NewUndo() after changing the text.

 ******************************************************************************/

JTEUndoTyping*
JTextEditor::GetTypingUndo
	(
	bool* isNew
	)
{
	JTEUndoTyping* typingUndo = NULL;

	JTEUndoBase* undo = NULL;
	if (GetCurrentUndo(&undo) &&
		(typingUndo = undo->CastToJTEUndoTyping()) != NULL &&
		typingUndo->IsActive())
		{
		assert( !itsHasSelectionFlag );
		*isNew = kFalse;
		return typingUndo;
		}
	else
		{
		typingUndo = new JTEUndoTyping(this);
		assert( typingUndo != NULL );

		*isNew = kTrue;
		return typingUndo;
		}
}

/******************************************************************************
 GetStyleUndo (private)

	Return the active JTEUndoStyle object.  If the current undo object is
	not an active JTEUndoStyle object, we create a new one that is active.

	If we create a new object, *isNew = kTrue, and the caller is required
	to call NewUndo() after changing the text.

 ******************************************************************************/

JTEUndoStyle*
JTextEditor::GetStyleUndo
	(
	bool* isNew
	)
{
	JTEUndoStyle* styleUndo = NULL;

	JTEUndoBase* undo = NULL;
	if (GetCurrentUndo(&undo) &&
		(styleUndo = undo->CastToJTEUndoStyle()) != NULL &&
		styleUndo->IsActive())
		{
		assert( itsHasSelectionFlag );
		*isNew = kFalse;
		return styleUndo;
		}
	else
		{
		styleUndo = new JTEUndoStyle(this);
		assert( styleUndo != NULL );

		*isNew = kTrue;
		return styleUndo;
		}
}

/******************************************************************************
 GetTabShiftUndo (private)

	Return the active JTEUndoTabShift object.  If the current undo object is
	not an active JTEUndoTabShift object, we create a new one that is active.

	If we create a new object, *isNew = kTrue, and the caller is required
	to call NewUndo() after changing the text.

 ******************************************************************************/

JTEUndoTabShift*
JTextEditor::GetTabShiftUndo
	(
	const JIndex	startLine,
	const JIndex	endLine,
	bool*		isNew
	)
{
	JTEUndoTabShift* tabShiftUndo = NULL;

	JTEUndoBase* undo = NULL;
	if (GetCurrentUndo(&undo) &&
		(tabShiftUndo = undo->CastToJTEUndoTabShift()) != NULL &&
		tabShiftUndo->IsActive())
		{
		*isNew = kFalse;
		return tabShiftUndo;
		}
	else
		{
		tabShiftUndo = new JTEUndoTabShift(this, startLine, endLine);
		assert( tabShiftUndo != NULL );

		*isNew = kTrue;
		return tabShiftUndo;
		}
}

/******************************************************************************
 InsertText (private)

	*** Caller must call Recalc().  Nothing can be selected.

	style can be NULL.

 ******************************************************************************/

void
JTextEditor::InsertText
	(
	const JIndex			charIndex,
	const JCharacter*		text,
	const JRunArray<Font>*	style
	)
{
	const JSize textLen = strlen(text);
	if (textLen == 0)
		{
		return;
		}

	assert( style == NULL || textLen == style->GetElementCount() );

	assert( !itsHasSelectionFlag );

	itsBuffer->InsertSubstring(text, charIndex);
	if (style != NULL)
		{
		itsStyles->InsertElementsAtIndex(charIndex, *style, 1, style->GetElementCount());
		}
	else if (textLen > 0)
		{
		itsStyles->InsertElementsAtIndex(charIndex, itsInsertionFont, textLen);
		}
}

/******************************************************************************
 DeleteText (private)

	*** Caller must call Recalc().

 ******************************************************************************/

void
JTextEditor::DeleteText
	(
	const JIndex startIndex,
	const JIndex endIndex
	)
{
	itsBuffer->RemoveSubstring(startIndex, endIndex);
	itsStyles->RemoveNextElements(startIndex, endIndex - startIndex + 1);
}

/******************************************************************************
 Paginate (protected)

	Returns breakpoints for cutting text into pages.  The first breakpoint
	is always zero, and the last breakpoint is the height of the text.
	Thus, it is easy to calculate the width of what is printed on each page
	from (breakpt->GetElement(i+1) - breakpt->GetElement(i) + 1).

 ******************************************************************************/

void
JTextEditor::Paginate
	(
	const JCoordinate		pageHeight,
	JArray<JCoordinate>*	breakpts
	)
	const
{
	assert( pageHeight > 0 );

	breakpts->RemoveAll();
	breakpts->AppendElement(0);

	const JSize count = GetLineCount();

	JRunArrayIterator<LineGeometry> iter(itsLineGeom);
	LineGeometry geom;

	JIndex prev = 1, i = 0;
	JCoordinate h = 0;
	do
		{
		// find the number of strips that will fit on this page

		while (i < count && h <= pageHeight)
			{
			i++;
			const bool ok = iter.Next(&geom);
			assert( ok );
			h += geom.height;
			}

		JCoordinate pageH = h;
		if (h > pageHeight && i > prev)
			{
			// The last line didn't fit on the page,
			// so leave it for the next page.

			pageH -= geom.height;
			i--;
			const bool ok = iter.Prev(&geom);
			assert( ok );
			h = 0;
			}
		else if (h > pageHeight)
			{
			// The line won't fit on any page.  Put
			// as much as possible on this page and leave
			// the rest for the next page.

			pageH = pageHeight;
			h    -= pageHeight;
			}
		else
			{
			// Everything fits on the page, so there is no residual.

			h = 0;
			}

		breakpts->AppendElement(breakpts->GetLastElement() + pageH);
		prev = i;
		}
		while (i < count || h > 0);
}

/******************************************************************************
 Print (virtual)

	This function could be optimized to save the necessary state so
	TESetBoundsWidth() doesn't have to be called again at the end.

 ******************************************************************************/

void
JTextEditor::Print
	(
	JPrinter& p
	)
{
	p.OpenDocument();

	const JCoordinate headerHeight = GetPrintHeaderHeight(p);
	const JCoordinate footerHeight = GetPrintFooterHeight(p);

	// We deactivate before printing so the selection or the
	// caret won't be printed.

	const bool savedActive = TEIsActive();
	TEDeactivate();

	// adjust to the width of the page

	itsIsPrintingFlag = kTrue;		// avoid notifing GUI

	const JCoordinate savedWidth = TEGetBoundsWidth();
	const JCoordinate pageWidth  = p.GetPageWidth();
	TESetBoundsWidth(pageWidth);

	// paginate

	JArray<JCoordinate> breakpts;
	Paginate(p.GetPageHeight()-headerHeight-footerHeight, &breakpts);

	// print each page

	const JSize pageCount = breakpts.GetElementCount() - 1;

	bool cancelled = kFalse;
	for (JIndex i=1; i<=pageCount; i++)
		{
		if (!p.NewPage())
			{
			cancelled = kTrue;
			break;
			}

		if (headerHeight > 0)
			{
			DrawPrintHeader(p, headerHeight);
			p.LockHeader(headerHeight);
			}
		if (footerHeight > 0)
			{
			DrawPrintFooter(p, footerHeight);
			p.LockFooter(footerHeight);
			}

		JPoint topLeft(0, breakpts.GetElement(i));
		JPoint bottomRight(pageWidth, breakpts.GetElement(i+1));
		JRect clipRect(JPoint(0,0), bottomRight - topLeft);
		p.SetClipRect(clipRect);

		p.ShiftOrigin(-topLeft);
		TEDraw(p, JRect(topLeft,bottomRight));
		}

	if (!cancelled)
		{
		p.CloseDocument();
		}

	itsIsPrintingFlag = kFalse;

	// restore the original state and width

	if (savedActive)
		{
		TEActivate();
		}

	TESetBoundsWidth(savedWidth);
}

/******************************************************************************
 Print header and footer (virtual protected)

	Derived classes can override these functions if they want to
	print a header or a footer.

 ******************************************************************************/

JCoordinate
JTextEditor::GetPrintHeaderHeight
	(
	JPrinter& p
	)
	const
{
	return 0;
}

JCoordinate
JTextEditor::GetPrintFooterHeight
	(
	JPrinter& p
	)
	const
{
	return 0;
}

void
JTextEditor::DrawPrintHeader
	(
	JPrinter&			p,
	const JCoordinate	headerHeight
	)
{
}

void
JTextEditor::DrawPrintFooter
	(
	JPrinter&			p,
	const JCoordinate	footerHeight
	)
{
}

/******************************************************************************
 PrintPlainText

	This prints the text using the same line breaks as displayed on the
	screen.  Thus, it only makes sense to use this function when text is
	not wrapped around the right of the window.

 ******************************************************************************/

void
JTextEditor::PrintPlainText
	(
	const JCharacter*	fileName,
	const JSize			maxLineCountPerPage
	)
{
	const JSize totalLineCount   = GetLineCount();
	const JSize headerLineCount  = GetPlainTextHeaderLineCount();
	const JSize footerLineCount  = GetPlainTextFooterLineCount();
	const JSize lineCountPerPage = maxLineCountPerPage - headerLineCount - footerLineCount;

	ofstream output(fileName);

	JIndex startLine = 1;
	JIndex pageIndex = 1;
	while (startLine <= totalLineCount)
		{
		if (headerLineCount > 0)
			{
			PrintPlainTextHeader(output, pageIndex);
			}

		JSize lineCount = 0;
		if (itsBuffer->IsEmpty())
			{
			lineCount = 1;
			output << '\n';
			}
		else
			{
			while (lineCount < lineCountPerPage &&
				   startLine + lineCount <= totalLineCount)
				{
				const JIndex startIndex = GetLineStart(startLine + lineCount);
				const JIndex endIndex   = GetLineEnd  (startLine + lineCount);

				const JString line     = itsBuffer->GetSubstring(startIndex, endIndex);
				const JSize lineLength = line.GetLength();

				JIndex col = 0;
				for (JIndex i=1; i<=lineLength; i++)
					{
					const JCharacter c = line.GetCharacter(i);
					if (c == '\t')
						{
						const JSize spaceCount =
							GetPlainTextTabWidth(startIndex + i-1, col);
						for (JIndex j=1; j<=spaceCount; j++)
							{
							output << ' ';
							}
						col += spaceCount;
						}
					else
						{
						output << c;
						col++;
						}
					}

				lineCount++;
				}
			}

		if (footerLineCount > 0)
			{
			while (lineCount < lineCountPerPage)
				{
				output << '\n';
				lineCount++;
				}

			PrintPlainTextFooter(output, pageIndex);
			}

		output << kJFormFeedKey << '\n';

		startLine += lineCount;
		pageIndex++;
		}
}

/******************************************************************************
 Print plain text header and footer (virtual protected)

	Derived classes can override these functions if they want to
	print a header or a footer.

 ******************************************************************************/

JSize
JTextEditor::GetPlainTextHeaderLineCount()
	const
{
	return 0;
}

JSize
JTextEditor::GetPlainTextFooterLineCount()
	const
{
	return 0;
}

void
JTextEditor::PrintPlainTextHeader
	(
	ostream&		output,
	const JIndex	pageIndex
	)
{
}

void
JTextEditor::PrintPlainTextFooter
	(
	ostream&		output,
	const JIndex	pageIndex
	)
{
}

/******************************************************************************
 GetPlainTextTabWidth (virtual protected)

	Derived classes must override this function in order to print tabs
	correctly from PrintPlainText().  They should return the number of
	spaces that the tab should be converted to.

	textColumn starts at zero at the left margin.

 ******************************************************************************/

JSize
JTextEditor::GetPlainTextTabWidth
	(
	const JIndex charIndex,
	const JIndex textColumn
	)
	const
{
	return 1;
}

/******************************************************************************
 GetCmdStatus (protected)

	Returns an array indicating which commands can be performed in the
	current state.

 ******************************************************************************/

JArray<bool>
JTextEditor::GetCmdStatus
	(
	bool* isReadOnly
	)
	const
{
	JArray<bool> flags(kCmdCount);
	for (JIndex i=1; i<=kCmdCount; i++)
		{
		flags.AppendElement(kFalse);
		}

	*isReadOnly = kTrue;

	if (itsType == kStaticText || !itsActiveFlag)
		{
		return flags;
		}

	if (itsHasSelectionFlag)
		{
		flags.SetElement(kCopyCmd, kTrue);
		}
	flags.SetElement(kSelectAllCmd, kTrue);
	flags.SetElement(kToggleReadOnlyCmd, kTrue);

	if (itsType == kFullEditor)
		{
		*isReadOnly = kFalse;

		flags.SetElement(kPasteCmd, kTrue);
		if (itsHasSelectionFlag)
			{
			flags.SetElement(kCutCmd, kTrue);
			flags.SetElement(kDeleteSelCmd, kTrue);
			}

		if (!itsBuffer->IsEmpty())
			{
			flags.SetElement(kCleanRightMarginCmd, kTrue);
			flags.SetElement(kShiftSelLeftCmd,     kTrue);
			flags.SetElement(kShiftSelRightCmd,    kTrue);
			}

		if (itsUndoList != NULL)
			{
			flags.SetElement(kUndoCmd, JConvertToBoolean( itsFirstRedoIndex > 1 ));
			flags.SetElement(kRedoCmd,
				JConvertToBoolean( itsFirstRedoIndex <= itsUndoList->GetElementCount() ));
			}
		else if (itsUndo != NULL)
			{
			const bool isRedo = itsUndo->IsRedo();
			flags.SetElement(kUndoCmd, JNegate(isRedo));
			flags.SetElement(kRedoCmd, isRedo);
			}
		}

	return flags;
}

/******************************************************************************
 TEDraw (protected)

	Draw everything that is visible in the given rectangle.

 ******************************************************************************/

void
JTextEditor::TEDraw
	(
	JPainter&		p,
	const JRect&	rect
	)
{
	// shade the dead-zone
/*
	if (itsLeftMarginWidth > kMinLeftMarginWidth)
		{
		const JColorIndex savedColor = p.GetPenColor();
		const bool savedFill     = p.IsFilling();
		p.SetPenColor(itsColormap->GetGray90Color());
		p.SetFilling(kTrue);
		const JRect& clipRect = p.GetClipRect();
		p.Rect(0, clipRect.top, itsLeftMarginWidth-1, clipRect.height());
		p.SetPenColor(savedColor);
		p.SetFilling(savedFill);
		}
*/
	p.ShiftOrigin(itsLeftMarginWidth, 0);

	// draw the text

	TEDrawText(p, rect);

	// if DND, draw drop location and object being dragged

	if ((itsDragType == kDragAndDrop || itsDragType == kLocalDragAndDrop) &&
		itsDropLoc.charIndex > 0)
		{
		TEDrawCaret(p, itsDropLoc);

		if (itsDragType == kLocalDragAndDrop)
			{
			JRect r = CalcLocalDNDRect(itsPrevPt);
			r.Offset(-itsLeftMarginWidth, 0);
			p.SetPenColor(itsDragColor);
			p.Rect(r);
			}
		}

	// otherwise, draw insertion caret

	else if (itsActiveFlag && itsCaretActiveFlag && !itsHasSelectionFlag &&
			 itsType == kFullEditor)
		{
		TEDrawCaret(p, itsCaretLoc);
		}

	// clean up

	p.ShiftOrigin(-itsLeftMarginWidth, 0);
}

/******************************************************************************
 TEDrawText (private)

	Draw the text that is visible in the given rectangle.

 ******************************************************************************/

void
JTextEditor::TEDrawText
	(
	JPainter&		p,
	const JRect&	rect
	)
{
	if (IsEmpty())
		{
		return;
		}

	const JSize lineCount = GetLineCount();

	JCoordinate h;
	const JIndex startLine = CalcLineIndex(rect.top, &h);

	// draw selection region

	if (itsActiveFlag && itsHasSelectionFlag && itsType != kStaticText)
		{
		TEDrawSelection(p, rect, startLine, h);
		}

	// draw text, one line at a time

	JRunIndex runIndex;
	JIndex firstInRun;
	const bool found = itsStyles->FindRun(GetLineStart(startLine), &runIndex, &firstInRun);
	assert( found );

	JRunArrayIterator<LineGeometry> iter(itsLineGeom, kIteratorStartBefore, startLine);
	LineGeometry geom;
	for (JIndex i=startLine; i<=lineCount; i++)
		{
		const bool ok = iter.Next(&geom);
		assert( ok );

		TEDrawLine(p, h, geom, i, &runIndex, &firstInRun);

		h += geom.height;
		if (h >= rect.bottom)
			{
			break;
			}
		}
}

/******************************************************************************
 TEDrawLine (private)

	Draw the text on the given line.

	Updates *runIndex,*firstInRun so that they are correct for the character
	beyond the end of the line.

 ******************************************************************************/

void
JTextEditor::TEDrawLine
	(
	JPainter&			p,
	const JCoordinate	top,
	const LineGeometry	geom,
	const JIndex		lineIndex,
	JRunIndex*			runIndex,
	JIndex*				firstInRun
	)
{
	const JSize lineLength = GetLineLength(lineIndex);
	assert( lineLength > 0 );

	bool lineEndsWithNewline = kFalse;

	JIndex startChar = GetLineStart(lineIndex);
	JIndex endChar   = startChar + lineLength - 1;
	if (itsBuffer->GetCharacter(endChar) == '\n')	// some fonts draw stuff for \n
		{
		endChar--;
		lineEndsWithNewline = kTrue;
		}

	JString s;
	JCoordinate left = 0;
	while (startChar <= endChar)
		{
		JSize runLength        = itsStyles->GetRunLength(*runIndex);
		const JSize trueRunEnd = *firstInRun + runLength-1;

		runLength -= startChar - *firstInRun;
		if (startChar + runLength-1 > endChar)
			{
			runLength = endChar - startChar + 1;
			}

		const Font& f = itsStyles->GetRunDataRef(*runIndex);
		s             = itsBuffer->GetSubstring(startChar, startChar + runLength-1);

		// If there is a tab in the string, we step up to it and take care of
		// the rest in the next iteration.

		JIndex tabIndex;
		if (s.LocateSubstring("\t", &tabIndex))
			{
			runLength = tabIndex - 1;
			if (runLength > 0)
				{
				s = itsBuffer->GetSubstring(startChar, startChar + runLength-1);
				}
			}
		else
			{
			tabIndex = 0;
			}

		if (runLength > 0)
			{
			p.SetFont(f.id, f.size, f.style);
			JCoordinate ascent,descent;
			p.GetLineHeight(&ascent, &descent);

			p.String(left, top + geom.ascent - ascent, s);

			// we only care if there is more text on the line

			if (startChar + runLength <= endChar)
				{
				left += p.GetStringWidth(s);
				}
			}
		if (tabIndex > 0)
			{
			left += GetTabWidth(startChar + runLength, left);
			runLength++;
			}

		startChar += runLength;
		if (startChar > trueRunEnd)		// move to next style run
			{
			*firstInRun = startChar;
			(*runIndex)++;
			}
		}

	// account for newline

	if (lineEndsWithNewline)
		{
		const JSize runLength = itsStyles->GetRunLength(*runIndex);
		if (startChar >= *firstInRun + runLength-1)
			{
			*firstInRun += runLength;
			(*runIndex)++;
			}
		}
}

/******************************************************************************
 TEDrawSelection (private)

	Draw the selection region.

 ******************************************************************************/

void
JTextEditor::TEDrawSelection
	(
	JPainter&			p,
	const JRect&		rect,
	const JIndex		startVisLine,
	const JCoordinate	startVisLineTop
	)
{
	assert( itsActiveFlag && itsHasSelectionFlag && itsType != kStaticText );

	// calculate intersection of selection region and drawing region

	JIndex startLine = GetLineForChar(itsSelection.start);
	JIndex endLine   = GetLineForChar(itsSelection.end);

	const JIndex origStartLine = startLine;
	const JIndex origEndLine   = endLine;

	JIndex startChar;
	JCoordinate x, y;

	JCoordinate endVisLineTop;
	const JIndex endVisLine = CalcLineIndex(rect.bottom, &endVisLineTop);
	if (startVisLine > endLine || endVisLine < startLine)
		{
		return;
		}
	else if (startVisLine > startLine)
		{
		startLine = startVisLine;
		startChar = GetLineStart(startVisLine);
		x         = 0;
		y         = startVisLineTop;
		}
	else
		{
		startChar = itsSelection.start;
		x         = GetCharLeft(CaretLocation(startChar, startLine));
		y         = GetLineTop(startLine);
		}

	if (endLine > endVisLine)
		{
		endLine = endVisLine;
		}

	// draw the selection region

	const JColorIndex savedColor = p.GetPenColor();
	const bool savedFill     = p.IsFilling();
	if (itsCaretActiveFlag)
		{
		p.SetPenColor(itsSelectionColor);
		p.SetFilling(kTrue);
		}
	else
		{
		p.SetPenColor(itsSelectionOutlineColor);
		p.SetFilling(kFalse);
		}

	const JCoordinate xmax = JMax(itsGUIWidth, itsWidth);

	JRunArrayIterator<LineGeometry> iter(itsLineGeom, kIteratorStartBefore, startLine);
	LineGeometry geom;
	for (JIndex i=startLine; i<=endLine; i++)
		{
		const bool ok = iter.Next(&geom);
		assert( ok );

		JCoordinate w;
		JIndex endChar = GetLineEnd(i);
		if (endChar > itsSelection.end)
			{
			endChar = itsSelection.end;
			w = GetStringWidth(startChar, endChar);
			}
		else
			{
			w = xmax - x;
			}

		const JCoordinate bottom = y + geom.height - 1;
		if (itsCaretActiveFlag)
			{
			// solid rectangle

			p.Rect(x, y, w, geom.height);
			}
		else if (origStartLine == origEndLine)
			{
			// empty rectangle

			p.Rect(x, y, w, geom.height);
			}
		else if (i == origStartLine)
			{
			// top of selection region

			p.Line(0,bottom, x,bottom);
			p.LineTo(x,y);
			p.LineTo(x+w,y);
			p.LineTo(x+w,bottom);
			}
		else if (i == origEndLine)
			{
			// bottom of selection region

			p.Line(0,y, 0,bottom);
			p.LineTo(w,bottom);
			p.LineTo(w,y);
			p.LineTo(xmax,y);
			}
		else
			{
			// vertical sides of selection region

			p.Line(0,y, 0,bottom);
			p.Line(xmax,y, xmax,bottom);
			}

		startChar = endChar+1;

		x  = 0;		// all lines after the first start at the far left
		y += geom.height;
		}

	// clean up

	p.SetPenColor(savedColor);
	p.SetFilling(savedFill);
}

/******************************************************************************
 TEDrawCaret (private)

 ******************************************************************************/

void
JTextEditor::TEDrawCaret
	(
	JPainter&			p,
	const CaretLocation	caretLoc
	)
{
	assert( itsType == kFullEditor );

	JCoordinate x, y1, y2;

	if (caretLoc.charIndex == itsBuffer->GetLength()+1 &&
		EndsWithNewline())									// ends with newline
		{
		x  = -1;
		y1 = GetLineBottom(caretLoc.lineIndex) + 1;
		y2 = y1 + GetEWNHeight()-1;
		}
	else
		{
		x = GetCharLeft(caretLoc) - 1;
		if (x >= itsWidth)
			{
			x = itsWidth;		// keep inside bounds
			}

		y1 = GetLineTop(caretLoc.lineIndex);
		y2 = y1 + GetLineHeight(caretLoc.lineIndex)-1;
		}

	const JColorIndex savedColor = p.GetPenColor();
	p.SetPenColor(itsCaretColor);
	p.Line(x,y1, x,y2);
	p.SetPenColor(savedColor);
}

/******************************************************************************
 TEWillDragAndDrop (protected)

 ******************************************************************************/

bool
JTextEditor::TEWillDragAndDrop
	(
	const JPoint&	origPt,
	const bool	extendSelection,
	const bool	dropCopy
	)
	const
{
	if (!itsActiveFlag || itsType == kStaticText || !itsPerformDNDFlag ||
		(itsHasSelectionFlag && extendSelection))
		{
		return kFalse;
		}

	const JPoint pt(origPt.x - itsLeftMarginWidth, origPt.y);
	const CaretLocation caretLoc = CalcCaretLocation(pt);

	return JConvertToBoolean(
				itsHasSelectionFlag &&
				itsSelection.start <= caretLoc.charIndex &&
				caretLoc.charIndex <= itsSelection.end );
}

/******************************************************************************
 TEHandleMouseDown (protected)

 ******************************************************************************/

void
JTextEditor::TEHandleMouseDown
	(
	const JPoint&	origPt,
	const JSize		clickCount,
	const bool	extendSelection,
	const bool	dropCopy
	)
{
	assert( itsActiveFlag );

	itsDragType = kInvalidDrag;
	if (itsType == kStaticText)
		{
		return;
		}

	DeactivateCurrentUndo();

	const JPoint pt(origPt.x - itsLeftMarginWidth, origPt.y);
	const CaretLocation caretLoc = CalcCaretLocation(pt);

	itsStartPt = itsPrevPt = pt;

	if (itsHasSelectionFlag && extendSelection &&
		caretLoc.charIndex <= itsSelection.start)
		{
		itsDragType =
			(itsPrevDragType == kInvalidDrag ? kSelectDrag : itsPrevDragType);
		itsSelectionPivot = itsSelection.end+1;
		itsPrevPt.x--;
		TEHandleMouseDrag(origPt);
		}
	else if (itsHasSelectionFlag && extendSelection)
		{
		itsDragType =
			(itsPrevDragType == kInvalidDrag ? kSelectDrag : itsPrevDragType);
		itsSelectionPivot = itsSelection.start;
		itsPrevPt.x--;
		TEHandleMouseDrag(origPt);
		}
	else if ((itsType == kFullEditor || itsType == kSelectableText) &&
			 itsPerformDNDFlag && clickCount == 1 && itsHasSelectionFlag &&
			 itsSelection.start <= caretLoc.charIndex &&
			 caretLoc.charIndex <= itsSelection.end+1)
		{
		itsDragType     = kDragAndDrop;
		itsDropLoc      = CaretLocation(0,0);
		itsDropCopyFlag = dropCopy;
		}
	else if (extendSelection)
		{
		itsDragType       = kSelectDrag;
		itsSelectionPivot = itsCaretLoc.charIndex;	// save this before SetSelection()

		if (caretLoc.charIndex < itsCaretLoc.charIndex)
			{
			SetSelection(caretLoc.charIndex, itsCaretLoc.charIndex-1);
			}
		else if (itsCaretLoc.charIndex < caretLoc.charIndex)
			{
			SetSelection(itsCaretLoc.charIndex, caretLoc.charIndex-1);
			}
		}
	else if (clickCount == 1)
		{
		if (caretLoc != itsCaretLoc)
			{
			SetCaretLocation(caretLoc);
			}
		itsDragType       = kSelectDrag;
		itsSelectionPivot = caretLoc.charIndex;
		}
	else if (clickCount == 2)
		{
		itsDragType = kSelectWordDrag;
		TEGetDoubleClickSelection(caretLoc, &itsWordSelPivot.start, &itsWordSelPivot.end);
		SetSelection(itsWordSelPivot.start, itsWordSelPivot.end);
		}
	else if (clickCount == 3)
		{
		itsDragType     = kSelectLineDrag;
		itsLineSelPivot = caretLoc.lineIndex;
		SetSelection(GetLineStart(caretLoc.lineIndex), GetLineEnd(caretLoc.lineIndex));
		}

	TEUpdateDisplay();
}

/******************************************************************************
 TEHandleMouseDrag (protected)

 ******************************************************************************/

void
JTextEditor::TEHandleMouseDrag
	(
	const JPoint& origPt
	)
{
	const JPoint pt(origPt.x - itsLeftMarginWidth, origPt.y);
	if (itsDragType == kInvalidDrag || pt == itsPrevPt)
		{
		return;
		}

	TEScrollForDrag(origPt);

	const CaretLocation caretLoc = CalcCaretLocation(pt);

	if (itsDragType == kSelectDrag && caretLoc.charIndex < itsSelectionPivot)
		{
		SetSelection(caretLoc.charIndex, itsSelectionPivot-1);
		Broadcast(CaretLineChanged(caretLoc.lineIndex));
		}
	else if (itsDragType == kSelectDrag && caretLoc.charIndex == itsSelectionPivot)
		{
		SetCaretLocation(caretLoc);
		}
	else if (itsDragType == kSelectDrag && caretLoc.charIndex > itsSelectionPivot)
		{
		SetSelection(itsSelectionPivot, caretLoc.charIndex-1);
		Broadcast(CaretLineChanged(caretLoc.lineIndex));
		}
	else if (itsDragType == kSelectWordDrag)
		{
		JIndex start, end;
		TEGetDoubleClickSelection(caretLoc, &start, &end);
		SetSelection(JMin(itsWordSelPivot.start, start),
					 JMax(itsWordSelPivot.end, end));
		Broadcast(CaretLineChanged(caretLoc.lineIndex));
		}
	else if (itsDragType == kSelectLineDrag)
		{
		SetSelection(GetLineStart( JMin(itsLineSelPivot, caretLoc.lineIndex) ),
					 GetLineEnd(   JMax(itsLineSelPivot, caretLoc.lineIndex) ) );
		Broadcast(CaretLineChanged(caretLoc.lineIndex));
		}
	else if (itsDragType == kLocalDragAndDrop)
		{
		if (itsDropLoc.charIndex > 0)
			{
			TERefreshCaret(itsDropLoc);
			}
		CaretLocation dropLoc = CaretLocation(0,0);
		if (caretLoc.charIndex <= itsSelection.start ||
			itsSelection.end+1 <= caretLoc.charIndex)
			{
			dropLoc = caretLoc;	// only drop outside selection
			}
		itsDropLoc = dropLoc;
		if (itsDropLoc.charIndex > 0)
			{
			TERefreshCaret(itsDropLoc);
			}
		TERefreshRect( CalcLocalDNDRect(itsPrevPt) );
		TERefreshRect( CalcLocalDNDRect(pt) );
		}
	else if (itsDragType == kDragAndDrop &&
			 (JLAbs(pt.x - itsStartPt.x) > kDebounceWidth ||
			  JLAbs(pt.y - itsStartPt.y) > kDebounceWidth))
		{
		if (TEBeginDND())
			{
			TECreateDragClip();
			// switches to TEHandleDND*()
			}
		else if (itsType == kFullEditor)
			{
			itsDragType = kLocalDragAndDrop;
			TECreateDragClip();
			}
		else
			{
			itsDragType = kInvalidDrag;
			}
		}

	itsPrevPt = pt;

	TEUpdateDisplay();
}

/******************************************************************************
 TEHandleMouseUp (protected)

 ******************************************************************************/

void
JTextEditor::TEHandleMouseUp()
{
	// handle local DND

	if (itsDragType == kLocalDragAndDrop && itsDropLoc.charIndex != 0)
		{
		DropSelection(itsDropLoc.charIndex, itsDropCopyFlag);
		TERefreshRect( CalcLocalDNDRect(itsPrevPt) );	// get rid of rectangle
		}
	else if (itsDragType == kLocalDragAndDrop || itsDragType == kDragAndDrop)
		{
		const CaretLocation startLoc = CalcCaretLocation(itsStartPt);
		if (CalcCaretLocation(itsPrevPt) == startLoc)
			{
			SetCaretLocation(startLoc);
			}
		}

	// set itsSelectionPivot for "shift-arrow" selection

	else if (itsHasSelectionFlag &&
			 (itsDragType == kSelectDrag ||
			  itsDragType == kSelectWordDrag ||
			  itsDragType == kSelectLineDrag))
		{
		if (itsDragType == kSelectWordDrag &&
			itsWordSelPivot.end == itsSelection.end)
			{
			itsSelectionPivot = itsSelection.end+1;
			}
		else if (itsDragType == kSelectLineDrag &&
				 GetLineEnd(itsLineSelPivot) == itsSelection.end)
			{
			itsSelectionPivot = itsSelection.end+1;
			}

		if (itsSelectionPivot == itsSelection.end+1)
			{
			itsCaretX = GetCharLeft(CalcCaretLocation(itsSelection.start));
			}
		else
			{
			itsSelectionPivot = itsSelection.start;
			itsCaretX = GetCharRight(CalcCaretLocation(itsSelection.end));
			}
		}

	// save drag type for "extend" drag

	if (itsDragType == kSelectDrag ||
		itsDragType == kSelectWordDrag || itsDragType == kSelectLineDrag)
		{
		itsPrevDragType = itsDragType;
		}
	else
		{
		itsPrevDragType = kInvalidDrag;
		}

	itsDragType = kInvalidDrag;
}

/******************************************************************************
 TEHandleDNDEnter (protected)

	We don't set itsDropCopyFlag because it will have been set in
	TEHandleMouseDown() when appropriate.

 ******************************************************************************/

void
JTextEditor::TEHandleDNDEnter()
{
	itsDragType = kDragAndDrop;
	itsDropLoc  = CaretLocation(0,0);
	TERefreshCaret(itsCaretLoc);		// hide the typing caret
}

/******************************************************************************
 TEHandleDNDHere (protected)

 ******************************************************************************/

void
JTextEditor::TEHandleDNDHere
	(
	const JPoint&	origPt,
	const bool	dropOnSelf
	)
{
	const JPoint pt(origPt.x - itsLeftMarginWidth, origPt.y);
	if (itsDragType != kDragAndDrop || pt == itsPrevPt)
		{
		return;
		}

	TEScrollForDrag(origPt);
	if (itsDropLoc.charIndex > 0)
		{
		TERefreshCaret(itsDropLoc);
		}

	const CaretLocation caretLoc = CalcCaretLocation(pt);

	CaretLocation dropLoc = CaretLocation(0,0);
	if (!dropOnSelf ||
		caretLoc.charIndex <= itsSelection.start ||
		itsSelection.end+1 <= caretLoc.charIndex)
		{
		dropLoc = caretLoc;		// only drop outside selection
		}
	itsDropLoc = dropLoc;

	if (itsDropLoc.charIndex > 0)
		{
		TERefreshCaret(itsDropLoc);
		}

	itsPrevPt = pt;
	TEUpdateDisplay();
}

/******************************************************************************
 TEHandleDNDLeave (protected)

 ******************************************************************************/

void
JTextEditor::TEHandleDNDLeave()
{
	assert( itsDragType == kDragAndDrop );

	if (itsDropLoc.charIndex > 0)
		{
		TERefreshCaret(itsDropLoc);
		}

	itsDragType = kInvalidDrag;
}

/******************************************************************************
 TEHandleDNDDrop (protected)

	If we are not the target, the derived class has to figure out how to get
	the data from the target.  Once it has the data, it should call
	Paste(text,style).

 ******************************************************************************/

void
JTextEditor::TEHandleDNDDrop
	(
	const JPoint&	pt,
	const bool	dropOnSelf
	)
{
	assert( itsDragType == kDragAndDrop );

	TEHandleDNDHere(pt, dropOnSelf);
	if (itsDropLoc.charIndex > 0)
		{
		TERefreshCaret(itsDropLoc);
		}

	if (dropOnSelf)
		{
		itsDragType = kLocalDragAndDrop;
		TEHandleMouseUp();
		}
	else
		{
		SetCaretLocation(itsDropLoc);
		TEPasteDropData();

		const JIndex index = GetInsertionIndex();
		if (index > itsDropLoc.charIndex)
			{
			SetSelection(itsDropLoc.charIndex, index-1);
			}
		}

	itsDragType = kInvalidDrag;
}

/******************************************************************************
 CalcLocalDNDRect (private)

	Returns the rectangle to draw when performing local DND.
	The point should be relative to the left margin.
	The rectangle is relative to the frame.

 ******************************************************************************/

JRect
JTextEditor::CalcLocalDNDRect
	(
	const JPoint& pt
	)
	const
{
	JRect r(pt, pt);
	r.Offset(itsLeftMarginWidth, 0);
	r.Shrink(-kDraggedOutlineRadius, -kDraggedOutlineRadius);
	return r;
}

/******************************************************************************
 DropSelection (private)

	Called by TEHandleMouseUp() and JTEUndoDrop.  We modify the undo
	information even though we are private because we implement a single
	user command.

 ******************************************************************************/

void
JTextEditor::DropSelection
	(
	const JIndex	origDropLoc,
	const bool	dropCopy
	)
{
	assert( itsHasSelectionFlag );

	if (!dropCopy &&
		(origDropLoc == itsSelection.start ||
		 origDropLoc == itsSelection.end + 1))
		{
		return;
		}

	const JSize textLen = itsSelection.end - itsSelection.start + 1;

	JString dropText;
	JRunArray<Font> dropStyles;
	const bool ok = Copy(&dropText, &dropStyles);
	assert( ok );

	JIndex dropLoc       = origDropLoc;
	JTEUndoBase* newUndo = NULL;
	if (dropCopy)
		{
		SetCaretLocation(dropLoc);
		newUndo = new JTEUndoPaste(this, textLen);
		}
	else
		{
		JIndex origIndex = itsSelection.start;
		if (dropLoc > itsSelection.start)
			{
			dropLoc -= textLen;
			}
		else
			{
			assert( dropLoc < itsSelection.start );
			origIndex += textLen;
			}

		newUndo = new JTEUndoDrop(this, origIndex, dropLoc, textLen);

		DeleteText(itsSelection.start, itsSelection.end);
		Recalc(itsSelection.start, textLen);
		}
	assert( newUndo != NULL );

	itsHasSelectionFlag = kFalse;
	InsertText(dropLoc, dropText, &dropStyles);
	Recalc(dropLoc, textLen);
	SetSelection(dropLoc, dropLoc + textLen-1);
	TEScrollToSelection(kFalse);

	NewUndo(newUndo);
}

/******************************************************************************
 GetDragClip (protected)

	Returns kTrue if our internal drag clipboard contains something.

	style can be NULL.

 ******************************************************************************/

bool
JTextEditor::GetDragClip
	(
	JString*			text,
	JRunArray<Font>*	style
	)
	const
{
	if (itsDragText != NULL && itsDragStyle != NULL)
		{
		*text = *itsDragText;
		if (style != NULL)
			{
			*style = *itsDragStyle;
			}
		return kTrue;
		}
	else
		{
		text->Clear();

		if (style != NULL)
			{
			style->RemoveAll();
			}
		return kFalse;
		}
}

/******************************************************************************
 TECreateDragClip (private)

	Allocate itsDragText and itsDragStyle.

 ******************************************************************************/

void
JTextEditor::TECreateDragClip()
{
	assert( (itsDragText == NULL && itsDragStyle == NULL) ||
			(itsDragText != NULL && itsDragStyle != NULL) );

	if (itsDragText == NULL)
		{
		itsDragText = new JString;
		assert( itsDragText != NULL );

		itsDragStyle = new JRunArray<Font>;
		assert( itsDragStyle != NULL );
		}

	const bool ok = GetSelection(itsDragText, itsDragStyle);
	assert( ok );
}

/******************************************************************************
 TEClearDragClip (protected)

	Delete itsDragText and itsDragStyle.

 ******************************************************************************/

void
JTextEditor::TEClearDragClip()
{
	delete itsDragText;
	itsDragText = NULL;

	delete itsDragStyle;
	itsDragStyle = NULL;
}

/******************************************************************************
 TEGetDoubleClickSelection (private)

	Select the word that was clicked on.  By computing the end of the word
	found by GetWordStart(), we avoid selecting two words when the user
	double clicks on the space between them.

 ******************************************************************************/

void
JTextEditor::TEGetDoubleClickSelection
	(
	const CaretLocation	caretLoc,
	JIndex*				startChar,
	JIndex*				endChar
	)
{
	const JIndex startIndex = GetWordStart(caretLoc.charIndex);
	const JIndex endIndex   = GetWordEnd(startIndex);

	// To select the word, the caret location should be inside the word
	// or on the character following the word.

	const JSize bufLength = itsBuffer->GetLength();

	if ((startIndex <= caretLoc.charIndex  && caretLoc.charIndex <= endIndex) ||
		(caretLoc.charIndex == endIndex+1  && IndexValid(endIndex+1)) ||
		(caretLoc.charIndex == bufLength+1 && endIndex == bufLength))
		{
		*startChar = startIndex;
		*endChar   = endIndex;
		}

	// Otherwise, we select the character that was clicked on

	else
		{
		*startChar = *endChar = JMin(caretLoc.charIndex, bufLength);
		if (*startChar > 1 &&
			itsBuffer->GetCharacter(*startChar)   == '\n' &&
			itsBuffer->GetCharacter(*startChar-1) != '\n')
			{
			(*startChar)--;
			(*endChar)--;
			}
		}
}

/******************************************************************************
 TEHitSamePart

 ******************************************************************************/

bool
JTextEditor::TEHitSamePart
	(
	const JPoint& pt1,
	const JPoint& pt2
	)
	const
{
	const CaretLocation loc1 = CalcCaretLocation(pt1);
	const CaretLocation loc2 = CalcCaretLocation(pt2);
	return JConvertToBoolean(loc1 == loc2);
}

/******************************************************************************
 TEHandleKeyPress (protected)

	Returns kTrue if the key was processed.

 ******************************************************************************/

bool
JTextEditor::TEHandleKeyPress
	(
	const JCharacter	origKey,
	const bool		selectText,
	const bool		moveEOW,
	const bool		moveEOL
	)
{
	assert( itsActiveFlag );
	assert( ( itsHasSelectionFlag && itsCaretLoc.charIndex == 0) ||
			(!itsHasSelectionFlag && itsCaretLoc.charIndex >  0) );

	if (itsType == kStaticText)
		{
		return kFalse;
		}
	else if (origKey == kJEscapeKey && itsDragType == kLocalDragAndDrop)
		{
		itsDragType = kInvalidDrag;
		TERefresh();
		return kTrue;
		}
	else if (itsDragType != kInvalidDrag)
		{
		return kTrue;
		}

	// pre-processing

	JCharacter key = origKey;
	if (key == '\r')
		{
		key = '\n';
		}

	const JSize bufLength = itsBuffer->GetLength();

	// We select text by selecting to where the caret ends up.

	const bool willSelectText = JConvertToBoolean(
		selectText &&
		(key == kJLeftArrow || key == kJRightArrow ||
		 key == kJUpArrow   || key == kJDownArrow));

	if (willSelectText)
		{
		bool restoreCaretX        = kTrue;
		const JCoordinate savedCaretX = itsCaretX;

		if (itsHasSelectionFlag && itsSelectionPivot == itsSelection.end+1)
			{
			SetCaretLocation(itsSelection.start);
			}
		else if (itsHasSelectionFlag && itsSelectionPivot == itsSelection.start)
			{
			SetCaretLocation(itsSelection.end+1);
			}
		else if (itsHasSelectionFlag)	// SetSelection() was called by outsider
			{
			itsSelectionPivot = itsSelection.start;
			restoreCaretX     = kFalse;
			SetCaretLocation(itsSelection.end+1);
			}
		else
			{
			itsSelectionPivot = itsCaretLoc.charIndex;
			}

		if (restoreCaretX && (key == kJUpArrow || key == kJDownArrow))
			{
			itsCaretX = savedCaretX;
			}
		}
	else if (itsType == kSelectableText)
		{
		return kFalse;
		}

	// left arrow

	if (key == kJLeftArrow && moveEOL && itsHasSelectionFlag)
		{
		GoToBeginningOfLine();
		}
	else if (key == kJLeftArrow && moveEOL &&
			 itsCaretLoc.charIndex == bufLength+1 && EndsWithNewline())		// ends with newline
		{
		SetCaretLocation(bufLength+1);	// scroll to it
		}
	else if (key == kJLeftArrow && moveEOL)	// first to start of text, then start of line
		{
		GoToBeginningOfLine();
		}

	else if (key == kJLeftArrow && moveEOW && itsHasSelectionFlag)
		{
		SetCaretLocation(GetWordStart(itsSelection.start));				// works for zero
		}
	else if (key == kJLeftArrow && moveEOW)
		{
		SetCaretLocation(GetWordStart(itsCaretLoc.charIndex-1));		// works for zero
		}

	else if (key == kJLeftArrow && itsHasSelectionFlag)
		{
		SetCaretLocation(itsSelection.start);
		}
	else if (key == kJLeftArrow)
		{
		if (itsCaretLoc.charIndex > 1)
			{
			SetCaretLocation(itsCaretLoc.charIndex-1);
			}
		else
			{
			SetCaretLocation(1);	// scroll to it
			}
		}

	// right arrow

	else if (key == kJRightArrow && moveEOL && itsHasSelectionFlag)
		{
		const JIndex lineIndex = GetLineForChar(itsSelection.end);
		const JIndex charIndex = GetLineEnd(lineIndex);
		if (isspace(itsBuffer->GetCharacter(charIndex)))
			{
			SetCaretLocation(charIndex);
			}
		else
			{
			SetCaretLocation(charIndex+1);
			}
		}
	else if (key == kJRightArrow && moveEOL &&
			 itsCaretLoc.charIndex == bufLength+1 && EndsWithNewline())
		{
		SetCaretLocation(bufLength+1);	// scroll to it
		}
	else if (key == kJRightArrow && moveEOL)
		{
		if (!itsBuffer->IsEmpty())
			{
			const JIndex charIndex = GetLineEnd(itsCaretLoc.lineIndex);
			const JCharacter c     = itsBuffer->GetCharacter(charIndex);
			if (isspace(c) && (charIndex < bufLength || c == '\n'))
				{
				SetCaretLocation(charIndex);
				}
			else
				{
				SetCaretLocation(charIndex+1);
				}
			}
		}

	else if (key == kJRightArrow && moveEOW && itsHasSelectionFlag)
		{
		SetCaretLocation(GetWordEnd(itsSelection.end)+1);
		}
	else if (key == kJRightArrow && moveEOW)
		{
		SetCaretLocation(GetWordEnd(itsCaretLoc.charIndex)+1);
		}

	else if (key == kJRightArrow && itsHasSelectionFlag)
		{
		SetCaretLocation(itsSelection.end+1);
		}
	else if (key == kJRightArrow)
		{
		if (itsCaretLoc.charIndex <= bufLength)
			{
			SetCaretLocation(itsCaretLoc.charIndex+1);
			}
		else
			{
			SetCaretLocation(bufLength+1);	// scroll to it
			}
		}

	// up arrow

	else if (key == kJUpArrow && moveEOL)
		{
		SetCaretLocation(1);
		}

	else if (key == kJUpArrow && moveEOW && itsHasSelectionFlag)
		{
		SetCaretLocation(GetParagraphStart(itsSelection.start-1));
		}
	else if (key == kJUpArrow && moveEOW)
		{
		SetCaretLocation(GetParagraphStart(itsCaretLoc.charIndex-1));
		}

	else if (key == kJUpArrow && itsHasSelectionFlag)
		{
		SetCaretLocation(itsSelection.start);
		}
	else if (key == kJUpArrow && itsCaretLoc.charIndex == bufLength+1 &&
			 EndsWithNewline())									// ends with newline
		{
		SetCaretLocation(GetLineStart(itsCaretLoc.lineIndex));
		}
	else if (key == kJUpArrow && itsCaretLoc.lineIndex > 1)
		{
		MoveCaretVert(-1);
		}
	else if (key == kJUpArrow)
		{
		SetCaretLocation(1);
		}

	// down arrow

	else if (key == kJDownArrow && moveEOL)
		{
		SetCaretLocation(bufLength+1);
		}

	else if (key == kJDownArrow && moveEOW && itsHasSelectionFlag)
		{
		SetCaretLocation(GetParagraphEnd(itsSelection.end+1)+1);
		}
	else if (key == kJDownArrow && moveEOW)
		{
		SetCaretLocation(GetParagraphEnd(itsCaretLoc.charIndex)+1);
		}

	else if (key == kJDownArrow && itsHasSelectionFlag)
		{
		SetCaretLocation(itsSelection.end+1);
		}
	else if (key == kJDownArrow && itsCaretLoc.lineIndex < GetLineCount())
		{
		MoveCaretVert(+1);
		}
	else if (key == kJDownArrow)
		{
		SetCaretLocation(bufLength+1);
		}

	// delete

	else if (key == kJDeleteKey && itsHasSelectionFlag)
		{
		DeleteSelection();
		}
	else if (key == kJDeleteKey && itsCaretLoc.charIndex > 1)
		{
		bool isNew;
		JTEUndoTyping* typingUndo = GetTypingUndo(&isNew);
		typingUndo->HandleDelete();

		const Font f = itsStyles->GetElement(itsCaretLoc.charIndex-1);	// preserve font
		DeleteText(itsCaretLoc.charIndex-1, itsCaretLoc.charIndex-1);
		Recalc(itsCaretLoc.charIndex-1, 1);
		SetCaretLocation(itsCaretLoc.charIndex-1);
		itsInsertionFont = f;

		typingUndo->Activate();		// cancel SetCaretLocation()
		if (isNew)
			{
			NewUndo(typingUndo);
			}
		}

	// forward delete

	else if (key == kJForwardDeleteKey && itsHasSelectionFlag)
		{
		DeleteSelection();
		}
	else if (key == kJForwardDeleteKey && itsCaretLoc.charIndex <= bufLength)
		{
		bool isNew;
		JTEUndoTyping* typingUndo = GetTypingUndo(&isNew);
		typingUndo->HandleFwdDelete();

		DeleteText(itsCaretLoc.charIndex, itsCaretLoc.charIndex);
		Recalc(itsCaretLoc, 1);
		SetCaretLocation(itsCaretLoc.charIndex);

		typingUndo->Activate();		// cancel SetCaretLocation()
		if (isNew)
			{
			NewUndo(typingUndo);
			}
		}

	// insert character

	else if (isprint(key) || key == '\n' || key == '\t' || (key & 0x80))
		{
		bool isNew;
		JTEUndoTyping* typingUndo = GetTypingUndo(&isNew);
		typingUndo->HandleCharacter();

		if (itsHasSelectionFlag)
			{
			itsInsertionFont    = itsStyles->GetElement(itsSelection.start);
			DeleteText(itsSelection.start, itsSelection.end);
			itsHasSelectionFlag = kFalse;
			itsCaretLoc         = CalcCaretLocation(itsSelection.start);
			}
		JCharacter s[2] = {key, '\0'};
		InsertText(itsCaretLoc.charIndex, s);
		Recalc(itsCaretLoc, 1);
		SetCaretLocation(itsCaretLoc.charIndex+1);

		typingUndo->Activate();		// cancel SetCaretLocation()

		if (key == '\n' && itsAutoIndentFlag)
			{
			AutoIndent(typingUndo);
			}

		if (isNew)
			{
			NewUndo(typingUndo);
			}
		}

	// finish selection process

	if (willSelectText)
		{
		if (itsCaretLoc.charIndex < itsSelectionPivot)
			{
			SetSelection(itsCaretLoc.charIndex, itsSelectionPivot-1);
			}
		else if (itsCaretLoc.charIndex > itsSelectionPivot)
			{
			SetSelection(itsSelectionPivot, itsCaretLoc.charIndex-1);
			}

		itsPrevDragType = kSelectDrag;
		}

	// We redraw the display immediately because it is very disconcerting
	// when the display does not instantly show the changes.

	TEUpdateDisplay();
	return kTrue;
}

/******************************************************************************
 AutoIndent (private)

	Duplicate the leading whitespace on the previous line.  If the previous
	line is nothing but whitespace, clear it.

 ******************************************************************************/

void
JTextEditor::AutoIndent
	(
	JTEUndoTyping* typingUndo
	)
{
	assert( !itsHasSelectionFlag );

	// Move up one line if we are not at the very end of the text.

	CaretLocation caretLoc = itsCaretLoc;
	const JSize bufLength  = itsBuffer->GetLength();
	if (caretLoc.charIndex <= bufLength)			// ends with newline
		{
		caretLoc.lineIndex--;
		}

	// Skip past lines that were created by wrapping the text.

	JIndex charIndex = GetLineStart(caretLoc.lineIndex);
	while (caretLoc.lineIndex > 1 && itsBuffer->GetCharacter(charIndex-1) != '\n')
		{
		caretLoc.lineIndex--;
		charIndex = GetLineStart(caretLoc.lineIndex);
		}

	// Find the whitespace range.

	const JIndex firstChar = charIndex;
	while (charIndex <= bufLength)
		{
		const JCharacter c = itsBuffer->GetCharacter(charIndex);
		if (c != ' ' && c != '\t')		// can't use isspace() because '\n' stops us
			{
			charIndex--;
			break;
			}
		charIndex++;
		}
	assert( charIndex < bufLength );	// just typed '\n', which stops loop before end of string

	// Copy the whitespace characters and include them in the undo object.

	if (charIndex >= firstChar)
		{
		const JString whitespace = itsBuffer->GetSubstring(firstChar, charIndex);
		const JSize spaceCount   = whitespace.GetLength();

		typingUndo->HandleCharacters(spaceCount);

		InsertText(itsCaretLoc.charIndex, whitespace);
		Recalc(itsCaretLoc, spaceCount);

		// clear blank line

		if (itsBuffer->GetCharacter(charIndex+1) == '\n')
			{
			typingUndo->HandleAutoIndentDelete(firstChar, charIndex);

			DeleteText(firstChar, charIndex);
			Recalc(CaretLocation(firstChar, caretLoc.lineIndex), spaceCount);

			SetCaretLocation(itsCaretLoc.charIndex);
			}
		else
			{
			SetCaretLocation(itsCaretLoc.charIndex + spaceCount);
			}

		// re-activate undo after SetCaretLocation()

		typingUndo->Activate();
		}
}

/******************************************************************************
 ContainsIllegalChars (static)

	Returns kTrue if the given text contains characters that we will not
	accept:  00-08, 0B,0C, 0E-1F, 7F

	We accept all characters above 0x7F because they provide useful
	(though hopelessly system dependent) extensions to the character set.

 ******************************************************************************/

static bool illegalCharRegexInit = kFalse;
static JRegex illegalCharRegex;

static const JCharacter* kIllegalCharPattern = "[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]+";
const JSize kIllegalCharPatternLength        = 12;	// contains NULL!

bool
JTextEditor::ContainsIllegalChars
	(
	const JCharacter*	text,
	const JSize			length
	)
{
	if (!illegalCharRegexInit)
		{
		illegalCharRegexInit = kTrue;
		illegalCharRegex.SetPatternOrDie(kIllegalCharPattern, kIllegalCharPatternLength);
		}

	return illegalCharRegex.MatchWithin(text, JStringRange(1,length));
}

/******************************************************************************
 RemoveIllegalChars (static)

	Returns kTrue if we had to remove any characters that
	ContainsIllegalChars() would flag.

	If the user cancels, we toss the entire string and return kTrue.

	style can be NULL or empty.

 ******************************************************************************/

bool
JTextEditor::RemoveIllegalChars
	(
	JString*			text,
	JRunArray<Font>*	style
	)
{
	if (!illegalCharRegexInit)
		{
		illegalCharRegexInit = kTrue;
		illegalCharRegex.SetPatternOrDie(kIllegalCharPattern, kIllegalCharPatternLength);
		}

	assert( style == NULL || style->IsEmpty() ||
			style->GetElementCount() == text->GetLength() );

	JSize pgValue               = 0;
	JSize counter               = 0;
	const JSize kScaleFactor    = 100;			// matches per progress increment
	JProgressDisplay* pg        = NULL;
	const time_t startTime      = time(NULL);
	const time_t kMaxSilentTime = 3;			// seconds

	const JSize origTextLength = text->GetLength();
	const JSize saveBlockSize  = text->GetBlockSize();
	text->SetBlockSize(origTextLength);			// avoid realloc

	JStringRange remainder(1, text->GetLength());
	JStringRange illegal;
	while (illegalCharRegex.MatchWithin(*text, remainder, &illegal))
		{
		text->RemoveSubstring(illegal);
		if (style != NULL && !style->IsEmpty())
			{
			style->RemoveNextElements(illegal.GetFirst(), illegal.GetLength());
			}

		pgValue += (illegal.GetFirst() - remainder.GetFirst()) + illegal.GetLength();
		remainder.Set(illegal.GetFirst(), text->GetLength());

		counter++;
		if (pg == NULL && counter % kScaleFactor == 0 &&
			time(NULL) - startTime >= kMaxSilentTime)
			{
			pg = JNewPG();
			pg->FixedLengthProcessBeginning(origTextLength,
				"Removing illegal characters...", kCancellable, kNoBackground);
			pg->IncrementProgress(pgValue);
			counter = 0;
			}
		else if (counter >= kScaleFactor && pg != NULL)
			{
			if (!pg->IncrementProgress(pgValue))
				{
				text->RemoveSubstring(remainder);
				if (style != NULL)
					{
					style->RemoveNextElements(remainder.GetFirst(), remainder.GetLength());
					}
				break;
				}
			counter = 0;
			}
		}

	if (pg != NULL)
		{
		pg->ProcessFinished();
		delete pg;
		}

	text->SetBlockSize(saveBlockSize);
	return JConvertToBoolean( text->GetLength() < origTextLength );
}

/******************************************************************************
 GetWordStart

	Return the index of the first character of the word at the given location.
	This function is required to work for charIndex == 0.

 ******************************************************************************/

JIndex
JTextEditor::GetWordStart
	(
	const JIndex charIndex
	)
	const
{
	if (itsBuffer->IsEmpty() || charIndex <= 1)
		{
		return 1;
		}

	JIndex i = JMin(charIndex, itsBuffer->GetLength());
	if (!IsCharacterInWord(*itsBuffer, i))
		{
		i--;
		while (i >= 1 && !IsCharacterInWord(*itsBuffer, i))
			{
			i--;
			}
		}

	while (i >= 1 && IsCharacterInWord(*itsBuffer, i))
		{
		i--;
		}
	return i+1;
}

/******************************************************************************
 GetWordEnd

	Return the index of the last character of the word at the given location.
	This function is required to work for charIndex > buffer length.

 ******************************************************************************/

JIndex
JTextEditor::GetWordEnd
	(
	const JIndex charIndex
	)
	const
{
	if (itsBuffer->IsEmpty())
		{
		return 1;
		}

	const JSize bufLen = itsBuffer->GetLength();
	if (charIndex >= bufLen)
		{
		return bufLen;
		}

	JIndex i = charIndex;
	if (!IsCharacterInWord(*itsBuffer, i))
		{
		i++;
		while (i <= bufLen && !IsCharacterInWord(*itsBuffer, i))
			{
			i++;
			}
		}

	while (i <= bufLen && IsCharacterInWord(*itsBuffer, i))
		{
		i++;
		}
	return i-1;
}

/******************************************************************************
 IsCharacterInWord (virtual protected)

	Returns kTrue if the given character should be considered part of
	a word.  The default definition is [A-Za-z0-9].

 ******************************************************************************/

bool
JTextEditor::IsCharacterInWord
	(
	const JString&	text,
	const JIndex	charIndex
	)
	const
{
	return JConvertToBoolean( isalnum(text.GetCharacter(charIndex)) );
}

/******************************************************************************
 GetParagraphStart

	Return the index of the first character in the paragraph that contains
	the character at the given location.  This function is required to work
	for charIndex == 0.

 ******************************************************************************/

JIndex
JTextEditor::GetParagraphStart
	(
	const JIndex charIndex
	)
	const
{
	if (itsBuffer->IsEmpty() || charIndex <= 1)
		{
		return 1;
		}

	JIndex i = JMin(charIndex, itsBuffer->GetLength());
	while (i > 1 && itsBuffer->GetCharacter(i-1) != '\n')
		{
		i--;
		}

	return i;
}

/******************************************************************************
 GetParagraphEnd

	Return the index of the newline that ends the paragraph that contains
	the character at the given location.  This function is required to work
	for charIndex > buffer length.

 ******************************************************************************/

JIndex
JTextEditor::GetParagraphEnd
	(
	const JIndex charIndex
	)
	const
{
	if (itsBuffer->IsEmpty())
		{
		return 1;
		}

	const JSize bufLen = itsBuffer->GetLength();
	if (charIndex >= bufLen)
		{
		return bufLen;
		}

	JIndex i = charIndex;
	while (i < bufLen && itsBuffer->GetCharacter(i) != '\n')
		{
		i++;
		}

	return i;
}

/******************************************************************************
 SetCaretLocation

	Move the caret to the specified point.

 ******************************************************************************/

void
JTextEditor::SetCaretLocation
	(
	const JIndex origCharIndex
	)
{
	JIndex charIndex = JMax(origCharIndex, (unsigned long) 1);
	charIndex        = JMin(charIndex, itsBuffer->GetLength()+1);

	SetCaretLocation( CalcCaretLocation(charIndex) );
}

// private

void
JTextEditor::SetCaretLocation
	(
	const CaretLocation caretLoc
	)
{
	DeactivateCurrentUndo();
	if (!itsHasSelectionFlag && itsCaretLoc == caretLoc)
		{
		TEScrollTo(itsCaretLoc);
		itsCaretX = GetCharLeft(itsCaretLoc);
		return;
		}

	const bool hadSelection      = itsHasSelectionFlag;
	const CaretLocation origCaretLoc = itsCaretLoc;

	itsHasSelectionFlag = kFalse;
	itsSelection        = Selection(0,0);
	itsCaretLoc         = caretLoc;
	itsCaretX           = GetCharLeft(itsCaretLoc);
	itsInsertionFont    = CalcInsertionFont(itsCaretLoc.charIndex);

	if (!TEScrollTo(itsCaretLoc))
		{
		TERefreshCaret(origCaretLoc);
		TERefreshCaret(itsCaretLoc);
		}

	if (hadSelection || origCaretLoc.lineIndex != itsCaretLoc.lineIndex)
		{
		Broadcast(CaretLineChanged(itsCaretLoc.lineIndex));
		}
}

/******************************************************************************
 GoToLine

 ******************************************************************************/

void
JTextEditor::GoToLine
	(
	const JIndex lineIndex
	)
{
	JIndex trueIndex      = lineIndex;
	const JSize lineCount = GetLineCount();

	CaretLocation caretLoc;
	if (trueIndex > lineCount && EndsWithNewline())		// ends with newline
		{
		caretLoc.charIndex = itsBuffer->GetLength() + 1;
		caretLoc.lineIndex = lineCount;
		}
	else
		{
		if (trueIndex == 0)
			{
			trueIndex = 1;
			}
		else if (trueIndex > lineCount)
			{
			trueIndex = lineCount;
			}
		caretLoc.charIndex = GetLineStart(trueIndex);
		caretLoc.lineIndex = trueIndex;
		}

	TEScrollToRect(CalcCaretRect(caretLoc), kTrue);
	SetCaretLocation(caretLoc);
}

/******************************************************************************
 SelectLine

 ******************************************************************************/

void
JTextEditor::SelectLine
	(
	const JIndex lineIndex
	)
{
	GoToLine(lineIndex);
	assert( !itsHasSelectionFlag );
	SetSelection(GetLineStart(itsCaretLoc.lineIndex),
				 GetLineEnd(itsCaretLoc.lineIndex));
}

/******************************************************************************
 GoToBeginningOfLine (private)

 ******************************************************************************/

void
JTextEditor::GoToBeginningOfLine()
{
	CaretLocation caretLoc;
	if (itsHasSelectionFlag)
		{
		caretLoc = CalcCaretLocation(itsSelection.start);
		}
	else
		{
		caretLoc = itsCaretLoc;
		}

	if (itsMoveToFrontOfTextFlag)
		{
		const JIndex firstChar = GetLineStart(caretLoc.lineIndex);
		const JIndex lastChar  = GetLineEnd(caretLoc.lineIndex);
		JIndex firstNonWSChar  = firstChar;
		while (firstNonWSChar <= lastChar &&
			   isspace(itsBuffer->GetCharacter(firstNonWSChar)))
			{
			firstNonWSChar++;
			}

		JIndex charIndex = firstNonWSChar;
		if (caretLoc.charIndex <= firstNonWSChar)
			{
			charIndex = firstChar;
			}

		caretLoc.charIndex = charIndex;
		}
	else
		{
		caretLoc.charIndex = GetLineStart(caretLoc.lineIndex);
		}

	SetCaretLocation(caretLoc);
}

/******************************************************************************
 TEScrollTo (private)

	Scroll to the specified insertion point.  Returns kTrue if scrolling
	was actually necessary.

 ******************************************************************************/

bool
JTextEditor::TEScrollTo
	(
	const CaretLocation caretLoc
	)
{
	return TEScrollToRect(CalcCaretRect(caretLoc), kFalse);
}

/******************************************************************************
 CalcCaretRect (private)

	Calculate the rectangle enclosing the caret when it is at the given
	location.  We set the width of the rectangle to be the left margin
	width so that the entire left margin will scroll into view when the
	caret is at the far left.

 ******************************************************************************/

JRect
JTextEditor::CalcCaretRect
	(
	const CaretLocation caretLoc
	)
	const
{
	JRect r;

	if (caretLoc.charIndex == itsBuffer->GetLength()+1 &&
		EndsWithNewline())								// ends with newline
		{
		r.top    = GetLineBottom(caretLoc.lineIndex) + 1;
		r.bottom = r.top + GetEWNHeight();
		r.left   = 0;
		r.right  = 2*itsLeftMarginWidth;
		}
	else
		{
		r.top    = GetLineTop(caretLoc.lineIndex);
		r.bottom = r.top + GetLineHeight(caretLoc.lineIndex);
		r.left   = GetCharLeft(caretLoc);
		r.right  = r.left + 2*itsLeftMarginWidth;
		}

	return r;
}

/******************************************************************************
 TEScrollToSelection (private)

	Scroll to make the selection or caret visible.  Returns kTrue if scrolling
	was actually necessary.

 ******************************************************************************/

bool
JTextEditor::TEScrollToSelection
	(
	const bool centerInDisplay
	)
{
	if (itsHasSelectionFlag)
		{
		const CaretLocation start = CalcCaretLocation(itsSelection.start);
		const CaretLocation end   = CalcCaretLocation(itsSelection.end);

		JRect r;
		r.top    = GetLineTop(start.lineIndex);
		r.bottom = GetLineBottom(end.lineIndex);
		if (start.lineIndex == end.lineIndex)
			{
			r.left  = GetCharLeft(start) + itsLeftMarginWidth;
			r.right = GetCharRight(end) + itsLeftMarginWidth;
			}
		else
			{
			r.left  = 0;
			r.right = itsLeftMarginWidth + itsWidth + kRightMarginWidth;
			}

		if (itsSelection.end == itsBuffer->GetLength()+1 &&
			EndsWithNewline())								// ends with newline
			{
			const JCoordinate dh = GetEWNHeight();
			r.top    += dh;
			r.bottom += dh;
			r.left    = 0;
			r.right   = itsLeftMarginWidth + itsWidth + kRightMarginWidth;
			}

		return TEScrollToRect(r, centerInDisplay);
		}
	else
		{
		return TEScrollToRect(CalcCaretRect(itsCaretLoc), centerInDisplay);
		}
}

/******************************************************************************
 TERefreshLines (protected)

	Redraw the specified range of lines.

 ******************************************************************************/

void
JTextEditor::TERefreshLines
	(
	const JIndex firstLine,
	const JIndex lastLine
	)
{
	const JRect r(GetLineTop(firstLine), 0, GetLineBottom(lastLine)+1,
				  itsLeftMarginWidth + JMax(itsGUIWidth, itsWidth) +
				  kRightMarginWidth);
	TERefreshRect(r);
}

/******************************************************************************
 TERefreshCaret (private)

	This refreshes the entire aperture if caretLoc is invalid.

 ******************************************************************************/

void
JTextEditor::TERefreshCaret
	(
	const CaretLocation caretLoc
	)
{
	if (caretLoc.charIndex == itsBuffer->GetLength()+1 &&
		EndsWithNewline())								// ends with newline
		{
		const JRect r(itsHeight - GetEWNHeight(), 0, itsHeight,
					  itsLeftMarginWidth + JMax(itsGUIWidth, itsWidth) +
					  kRightMarginWidth);
		TERefreshRect(r);
		}
	else if (itsLineStarts->IndexValid(caretLoc.lineIndex))
		{
		TERefreshLines(caretLoc.lineIndex, caretLoc.lineIndex);
		}
	else
		{
		TERefresh();
		}
}

/******************************************************************************
 MoveCaretVert (protected)

	Moves the caret up or down the specified number of lines.

 ******************************************************************************/

void
JTextEditor::MoveCaretVert
	(
	const JInteger deltaLines
	)
{
	assert( !itsHasSelectionFlag );

	const JSize lineCount  = GetLineCount();
	const JIndex lineIndex = itsCaretLoc.lineIndex;

	JIndex newLineIndex = 0;
	if (deltaLines > 0 && lineIndex + deltaLines <= lineCount)
		{
		newLineIndex = lineIndex + deltaLines;
		}
	else if (deltaLines > 0)
		{
		newLineIndex = lineCount;
		}
	else if (deltaLines < 0 && lineIndex > (JSize) -deltaLines)
		{
		newLineIndex = lineIndex + deltaLines;
		}
	else if (deltaLines < 0)
		{
		newLineIndex = 1;
		}

	if (newLineIndex > 0)
		{
		const JCoordinate saveX = itsCaretX;

		const JPoint pt(itsCaretX, GetLineTop(newLineIndex)+1);
		SetCaretLocation(CalcCaretLocation(pt));

		itsCaretX = saveX;
		}
}

/******************************************************************************
 GetLineForChar

	Returns the line that the specified character is on.  Since the
	array is sorted, we can use a binary search.  We can use kAnyMatch
	because we know the values are unique.

 ******************************************************************************/

JIndex
JTextEditor::GetLineForChar
	(
	const JIndex charIndex
	)
	const
{
	if (charIndex == 0)
		{
		return 1;
		}

	bool found;
	JIndex lineIndex =
		itsLineStarts->SearchSorted1(charIndex, JOrderedSetT::kAnyMatch, &found);
	if (!found)
		{
		lineIndex--;	// wants to insert -after- the value
		}
	return lineIndex;
}

/******************************************************************************
 CalcInsertionFont (private)

	Returns the font to use when inserting at the specified point.

 ******************************************************************************/

JTextEditor::Font
JTextEditor::CalcInsertionFont
	(
	const JIndex charIndex
	)
	const
{
	if (1 < charIndex && charIndex <= itsBuffer->GetLength() &&
		itsBuffer->GetCharacter(charIndex-1) == '\n')
		{
		return itsStyles->GetElement(charIndex);
		}
	else if (charIndex > 1)
		{
		return itsStyles->GetElement(charIndex-1);
		}
	else if (!itsStyles->IsEmpty())
		{
		return itsStyles->GetElement(1);
		}
	else
		{
		return itsDefFont;
		}
}

/******************************************************************************
 GetLineEnd

	Returns the last character on the specified line.

 ******************************************************************************/

JIndex
JTextEditor::GetLineEnd
	(
	const JIndex lineIndex
	)
	const
{
	if (lineIndex < GetLineCount())
		{
		return GetLineStart(lineIndex+1) - 1;
		}
	else
		{
		return itsPrevBufLength;	// consistent with rest of output from Recalc()
		}
}

/******************************************************************************
 GetLineTop (private)

	Returns the top of the specified line.

 ******************************************************************************/

JCoordinate
JTextEditor::GetLineTop
	(
	const JIndex endLineIndex
	)
	const
{
	assert( itsLineGeom->IndexValid(endLineIndex) );

	JIndex lineIndex = 1;
	JCoordinate y    = 0;

	const JSize runCount = itsLineGeom->GetRunCount();
	for (JIndex i=1; i<=runCount && lineIndex < endLineIndex; i++)
		{
		const JSize runLength    = itsLineGeom->GetRunLength(i);
		const LineGeometry& geom = itsLineGeom->GetRunDataRef(i);

		const JIndex newLineIndex = lineIndex + runLength;
		if (newLineIndex <= endLineIndex)
			{
			lineIndex = newLineIndex;
			y        += geom.height * runLength;
			}
		else	// newLineIndex > endLineIndex
			{
			y += geom.height * (endLineIndex - lineIndex);
			break;
			}
		}

	return y;
}

/******************************************************************************
 GetCharLeft (private)

	Returns the starting x coordinate of the specified character.

 ******************************************************************************/

JCoordinate
JTextEditor::GetCharLeft
	(
	const CaretLocation charLoc
	)
	const
{
	const JIndex firstChar = GetLineStart(charLoc.lineIndex);

	JCoordinate x = 0;
	if (charLoc.charIndex > firstChar)
		{
		x = GetStringWidth(firstChar, charLoc.charIndex-1);
		}
	return x;
}

/******************************************************************************
 GetCharWidth (private)

	Returns the width of the specified character.

 ******************************************************************************/

JCoordinate
JTextEditor::GetCharWidth
	(
	const CaretLocation charLoc
	)
	const
{
	const JCharacter c = itsBuffer->GetCharacter(charLoc.charIndex);
	if (c != '\t')
		{
		const Font f = itsStyles->GetElement(charLoc.charIndex);
		return itsFontMgr->GetCharWidth(f.id, f.size, f.style, c);
		}
	else
		{
		return GetTabWidth(charLoc.charIndex, GetCharLeft(charLoc));
		}
}

/******************************************************************************
 GetStringWidth (private)

	Returns the width of the specified character range.

	The second version updates *runIndex,*firstInRun so that they
	are correct for endIndex+1.

 ******************************************************************************/

JCoordinate
JTextEditor::GetStringWidth
	(
	const JIndex startIndex,
	const JIndex endIndex
	)
	const
{
	JRunIndex runIndex;
	JIndex firstInRun;
	const bool found = itsStyles->FindRun(startIndex, &runIndex, &firstInRun);
	assert( found );

	return GetStringWidth(startIndex, endIndex, &runIndex, &firstInRun);
}

JCoordinate
JTextEditor::GetStringWidth
	(
	const JIndex	origStartIndex,
	const JIndex	endIndex,
	JRunIndex*		runIndex,
	JIndex*			firstInRun
	)
	const
{
	assert( IndexValid(origStartIndex) );
	assert( IndexValid(endIndex) );

	// preWidth stores the width of the characters preceding origStartIndex
	// on the line containing origStartIndex.  We calculate this -once- when
	// it is first needed.  (i.e. when we hit the first tab character)

	JCoordinate width    = 0;
	JCoordinate preWidth = -1;

	JIndex startIndex = origStartIndex;
	while (startIndex <= endIndex)
		{
		JSize runLength        = itsStyles->GetRunLength(*runIndex);
		const JSize trueRunEnd = *firstInRun + runLength-1;

		runLength -= startIndex - *firstInRun;
		if (startIndex + runLength-1 > endIndex)
			{
			runLength = endIndex - startIndex + 1;
			}

		const Font& f = itsStyles->GetRunDataRef(*runIndex);

		// If there is a tab in the string, we step up to it and take care of
		// the rest in the next iteration.

		JIndex tabIndex;
		if (LocateTab(startIndex, startIndex + runLength-1, &tabIndex))
			{
			runLength = tabIndex - startIndex;
			}
		else
			{
			tabIndex = 0;
			}

		if (runLength > 0)
			{
			width += itsFontMgr->GetStringWidth(f.id, f.size, f.style,
												itsBuffer->GetCString() + startIndex-1,
												runLength);
			}
		if (tabIndex > 0)
			{
			if (preWidth < 0)
				{
				// recursion: max depth 1
				preWidth = GetCharLeft(CalcCaretLocation(origStartIndex));
				assert( preWidth >= 0 );
				}
			width += GetTabWidth(startIndex + runLength, preWidth + width);
			runLength++;
			}

		startIndex += runLength;
		if (startIndex > trueRunEnd)	// move to next style run
			{
			*firstInRun = startIndex;
			(*runIndex)++;
			}
		}

	return width;
}

/******************************************************************************
 LocateTab (private)

	Returns the index of the first tab character, starting from startIndex.
	If no tab is found, returns kFalse, and *tabIndex = 0.

 ******************************************************************************/

bool
JTextEditor::LocateTab
	(
	const JIndex	startIndex,
	const JIndex	endIndex,
	JIndex*			tabIndex
	)
	const
{
	for (JIndex i=startIndex; i<=endIndex; i++)
		{
		if (itsBuffer->GetCharacter(i) == '\t')
			{
			*tabIndex = i;
			return kTrue;
			}
		}

	*tabIndex = 0;
	return kFalse;
}

/******************************************************************************
 GetTabWidth (virtual protected)

	Given the index of the tab character (charIndex) and the horizontal
	position on the line (in pixels) where the tab character starts (x),
	return the width of the tab character.

	This default implementation rounds the location up to the nearest
	multiple of itsDefTabWidth.

 ******************************************************************************/

JCoordinate
JTextEditor::GetTabWidth
	(
	const JIndex		charIndex,
	const JCoordinate	x
	)
	const
{
	const JCoordinate xnew = ((x / itsDefTabWidth) + 1) * itsDefTabWidth;
	return (xnew - x);
}

/******************************************************************************
 RecalcAll (protected)

 ******************************************************************************/

void
JTextEditor::RecalcAll()
{
	if (itsBreakCROnlyFlag)
		{
		itsWidth = 0;
		}

	itsLineStarts->RemoveAll();
	itsLineStarts->AppendElement(1);

	itsLineGeom->RemoveAll();

	Recalc(CaretLocation(1,1), itsBuffer->GetLength());
}

/******************************************************************************
 Recalc (private)

	Recalculate layout, starting from caretLoc and continuing at least
	through charCount characters.

	*** We assume that nothing above caretLoc.lineIndex needs to be recalculated.
		We also assume that the first line to recalculate already exists.

 ******************************************************************************/

void
JTextEditor::Recalc
	(
	const CaretLocation	origCaretLoc,
	const JSize			minCharCount
	)
{
	JCoordinate maxLineWidth = 0;
	if (itsBreakCROnlyFlag && GetLineCount() == 1)
		{
		itsWidth = 0;
		}

	CaretLocation caretLoc = origCaretLoc;
	const JSize bufLength  = itsBuffer->GetLength();
	if (caretLoc.charIndex == bufLength+1)
		{
		(caretLoc.charIndex)--;
		caretLoc.lineIndex = GetLineForChar(caretLoc.charIndex);
		}

	JIndex firstLineIndex, lastLineIndex;
	if (bufLength > 0)
		{
		Recalc1(bufLength, caretLoc, minCharCount, &maxLineWidth,
				&firstLineIndex, &lastLineIndex);
		}
	else
		{
		itsLineStarts->RemoveAll();
		itsLineStarts->AppendElement(1);

		itsLineGeom->RemoveAll();

		const Font f = CalcInsertionFont(1);
		JCoordinate ascent,descent;
		const JCoordinate h =
			itsFontMgr->GetLineHeight(f.id, f.size, f.style, &ascent, &descent);
		itsLineGeom->AppendElement(LineGeometry(h, ascent));

		firstLineIndex = lastLineIndex = 1;
		}

	// If the caret is visible, recalculate the line index.

	if (!itsHasSelectionFlag)
		{
		const JIndex origLine = itsCaretLoc.lineIndex;
		itsCaretLoc.lineIndex = GetLineForChar(itsCaretLoc.charIndex);
		if (itsCaretLoc.lineIndex != origLine)
			{
			Broadcast(CaretLineChanged(itsCaretLoc.lineIndex));
			}
		}

	// If we only break at newlines, we control our width.

	if (itsBreakCROnlyFlag && maxLineWidth > itsWidth)
		{
		itsWidth = maxLineWidth;
		}

	// If all the lines are the same height, set the scrolling step size to that.

	if (itsLineGeom->GetRunCount() == 1 && !itsIsPrintingFlag)
		{
		TESetVertScrollStep(GetLineHeight(1));
		}
	else if (!itsIsPrintingFlag)
		{
		TESetVertScrollStep(
			itsFontMgr->GetLineHeight(itsDefFont.id, itsDefFont.size, itsDefFont.style));
		}

	// recalculate the height

	const JSize lineCount = GetLineCount();
	JCoordinate newHeight = GetLineTop(lineCount) + GetLineHeight(lineCount);
	if (EndsWithNewline())								// ends with newline
		{
		newHeight += GetEWNHeight();
		}

	if (!itsIsPrintingFlag && newHeight != itsHeight)
		{
		TERefresh();	// redraw everything if the line heights changed
		}

	itsHeight = newHeight;

	// notify the derived class of our new size

	if (!itsIsPrintingFlag)
		{
		TESetGUIBounds(itsLeftMarginWidth + itsWidth + kRightMarginWidth, itsHeight);
		}

	// save buffer length for next time

	itsPrevBufLength = bufLength;

	// show the changes

	if (!itsIsPrintingFlag)
		{
		TERefreshLines(firstLineIndex, lastLineIndex);
		}
}

/******************************************************************************
 Recalc1 (private)

	Subroutine called by Recalc().

	(firstLineIndex, lastLineIndex) gives the range of lines that had
	to be recalculated.

 ******************************************************************************/

void
JTextEditor::Recalc1
	(
	const JSize			bufLength,
	const CaretLocation	caretLoc,
	const JSize			origMinCharCount,
	JCoordinate*		maxLineWidth,
	JIndex*				firstLineIndex,
	JIndex*				lastLineIndex
	)
{
	JIndex lineIndex = caretLoc.lineIndex;
	if (!itsBreakCROnlyFlag && lineIndex > 1 &&
		caretLoc.charIndex <= bufLength &&
		NoPrevWhitespaceOnLine(*itsBuffer, caretLoc))
		{
		// If we start in the first word on the line, it
		// might actually belong on the previous line.

		lineIndex--;
		}

	JIndex firstChar   = GetLineStart(lineIndex);
	JSize minCharCount = origMinCharCount + (caretLoc.charIndex - firstChar);
	*firstLineIndex    = lineIndex;

	JRunIndex runIndex;
	JIndex firstInRun;
	const bool found = itsStyles->FindRun(firstChar, &runIndex, &firstInRun);
	assert( found );

	JSize totalCharCount = 0;
	*maxLineWidth        = itsWidth;
	while (1)
		{
		JCoordinate lineWidth;
		const JSize charCount = RecalcLine(bufLength, firstChar, lineIndex, &lineWidth,
										   &runIndex, &firstInRun);
		totalCharCount += charCount;
		if (*maxLineWidth < lineWidth)
			{
			*maxLineWidth = lineWidth;
			}
		const JIndex endChar = firstChar + charCount-1;
		assert( endChar <= bufLength );

		// remove line starts that are further from the end than the new one
		// (we use (bufLength - endChar) so subtraction won't produce negative numbers)

		while (lineIndex < GetLineCount() &&
			   (itsPrevBufLength+1) - GetLineStart(lineIndex+1) >
					bufLength - endChar)
			{
			itsLineStarts->RemoveElement(lineIndex+1);
			itsLineGeom->RemoveElement(lineIndex+1);
			}

		// check if we are done

		if (endChar >= bufLength)
			{
			// We reached the end of the text.

			break;
			}
		else if (totalCharCount >= minCharCount &&
				 lineIndex < GetLineCount() &&
				 itsPrevBufLength - GetLineStart(lineIndex+1) ==
					bufLength - (endChar+1))
			{
			// The rest of the line starts merely shift.

			const JSize lineCount = itsLineStarts->GetElementCount();
			assert( lineCount > lineIndex );
			const long delta = endChar+1 - GetLineStart(lineIndex+1);
			if (delta != 0)
				{
				const JIndex* lineStart = itsLineStarts->GetCArray();
				for (JIndex i=lineIndex+1; i<=lineCount; i++)
					{
					itsLineStarts->SetElement(i, lineStart[i-1] + delta);
					}
				}
			break;
			}

		// insert the new line start

		lineIndex++;
		firstChar += charCount;

		itsLineStarts->InsertElementAtIndex(lineIndex, firstChar);
		itsLineGeom->InsertElementAtIndex(lineIndex, LineGeometry());

		// This catches the case when the new and old line starts
		// are equally far from the end, but we haven't recalculated
		// far enough yet, so the above breakout code didn't trigger.

		if (lineIndex < GetLineCount() &&
			   itsPrevBufLength - GetLineStart(lineIndex+1) ==
					bufLength - (endChar+1))
			{
			itsLineStarts->RemoveElement(lineIndex+1);
			itsLineGeom->RemoveElement(lineIndex+1);
			}
		}

	*lastLineIndex = lineIndex;
}

/******************************************************************************
 RecalcLine (private)

	Recalculate the line starting with firstChar.  Returns the number
	of characters on the line.  Sets the appropriate values in itsLineGeom.
	Sets *lineWidth to the width of the line in pixels.

	If insertLine is kTrue, then this line is new, so we insert a new
	element into itsLineGeom.

	Updates *runIndex,*firstInRun so that they are correct for the character
	beyond the end of the line.

 ******************************************************************************/

JSize
JTextEditor::RecalcLine
	(
	const JSize		bufLength,
	const JIndex	firstCharIndex,
	const JIndex	lineIndex,
	JCoordinate*	lineWidth,
	JRunIndex*		runIndex,
	JIndex*			firstInRun
	)
{
	JSize charCount = 0;
	*lineWidth      = 0;

	JRunIndex gswRunIndex = *runIndex;
	JIndex gswFirstInRun  = *firstInRun;

	if (itsBreakCROnlyFlag)
		{
		JIndex endIndex = firstCharIndex;
		if (!itsBuffer->LocateNextSubstring("\n", &endIndex))
			{
			endIndex = itsBuffer->GetLength();
			}
		charCount  = endIndex - firstCharIndex + 1;
		*lineWidth = GetStringWidth(firstCharIndex, endIndex,
									&gswRunIndex, &gswFirstInRun);
		}

	else
		{
		// include leading whitespace

		bool endOfLine;
		charCount = IncludeWhitespaceOnLine(bufLength, firstCharIndex,
											lineWidth, &endOfLine,
											&gswRunIndex, &gswFirstInRun);
		JIndex charIndex = firstCharIndex + charCount;

		// Add words until we hit the right margin, a newline,
		// or the end of the buffer.

		while (charIndex <= bufLength && !endOfLine)
			{
			// get the next word

			JIndex prevIndex = charIndex;
			if (!LocateNextWhitespace(bufLength, &charIndex))
				{
				charIndex = bufLength+1;
				}

			// check if the word fits on this line

			JCoordinate dw =
				GetStringWidth(prevIndex, charIndex-1, &gswRunIndex, &gswFirstInRun);
			if (*lineWidth + dw > itsWidth)
				{
				if (prevIndex != firstCharIndex)
					{
					// this word goes on the next line

					charIndex = prevIndex;
					}
				else
					{
					// put as much of this word as possible on the line

					assert( *lineWidth == 0 && charCount == 0 );
					charCount = GetSubwordForLine(bufLength, lineIndex,
												  firstCharIndex, lineWidth);
					}
				break;
				}

			// put the word on this line

			*lineWidth += dw;
			charCount  += charIndex - prevIndex;

			// include the whitespace after the word

			JSize wsCount =
				IncludeWhitespaceOnLine(bufLength, charIndex, lineWidth, &endOfLine,
										&gswRunIndex, &gswFirstInRun);
			charIndex += wsCount;
			charCount += wsCount;
			}
		}

	// update geometry for this line

	const JSize runCount = itsStyles->GetRunCount();
	const JSize lastChar = firstCharIndex + charCount-1;

	JCoordinate maxAscent=0, maxDescent=0;
	while (*runIndex <= runCount)
		{
		const Font& f = itsStyles->GetRunDataRef(*runIndex);
		JCoordinate ascent, descent;
		itsFontMgr->GetLineHeight(f.id, f.size, f.style, &ascent, &descent);

		if (ascent > maxAscent)
			{
			maxAscent = ascent;
			}
		if (descent > maxDescent)
			{
			maxDescent = descent;
			}

		const JIndex firstInNextRun = *firstInRun + itsStyles->GetRunLength(*runIndex);
		if (firstInNextRun <= lastChar+1)
			{
			(*runIndex)++;
			*firstInRun = firstInNextRun;
			}
		if (firstInNextRun > lastChar)
			{
			break;
			}
		}

	const LineGeometry geom(maxAscent+maxDescent, maxAscent);
	if (lineIndex <= itsLineGeom->GetElementCount())
		{
		itsLineGeom->SetElement(lineIndex, geom);
		}
	else
		{
		itsLineGeom->AppendElement(geom);
		}

	// return number of characters on line

	return charCount;
}

/******************************************************************************
 IncludeWhitespaceOnLine (private)

	*** Only for use by RecalcLine()

	Starting with the given index, return the number of consecutive whitespace
	characters encountered.  Increments *lineWidth with the width of this
	whitespace.  If we encounter a newline, we stop beyond it and set
	*endOfLine to kTrue.

	Updates *runIndex,*firstInRun so that they are correct for the character
	beyond the end of the whitespace.

 ******************************************************************************/

JSize
JTextEditor::IncludeWhitespaceOnLine
	(
	const JSize		bufLength,
	const JIndex	origStartIndex,
	JCoordinate*	lineWidth,
	bool*		endOfLine,
	JRunIndex*		runIndex,
	JIndex*			firstInRun
	)
	const
{
	*endOfLine = kFalse;

	JIndex startIndex = origStartIndex;
	JIndex endIndex   = startIndex;
	JSize wsCount     = 0;

	while (endIndex <= bufLength)
		{
		const JCharacter c = itsBuffer->GetCharacter(endIndex);
		if (!isspace(c))
			{
			break;
			}

		wsCount++;
		if (c == '\t')
			{
			if (endIndex > startIndex)
				{
				*lineWidth += GetStringWidth(startIndex, endIndex-1,
											 runIndex, firstInRun);
				}
			*lineWidth += GetTabWidth(endIndex, *lineWidth);
			startIndex  = endIndex+1;

			// update *runIndex,*firstInRun after passing tab character

			const JSize runLength = itsStyles->GetRunLength(*runIndex);
			if (startIndex > *firstInRun + runLength-1)
				{
				*firstInRun += runLength;
				(*runIndex)++;
				}

			// tab characters can wrap to the next line

			if (!itsBreakCROnlyFlag && *lineWidth > itsWidth)
				{
				*endOfLine = kTrue;
				break;
				}
			}

		endIndex++;
		if (c == '\n')
			{
			*endOfLine = kTrue;
			break;
			}
		}

	if (endIndex > startIndex)
		{
		*lineWidth += GetStringWidth(startIndex, endIndex-1, runIndex, firstInRun);
		}

	return wsCount;
}

/******************************************************************************
 LocateNextWhitespace (private)

	*** Only for use by RecalcLine()

	Find the next whitespace character, starting from the given index.
	Returns kFalse if it doesn't find any.

	*** If we only break at newlines, only newlines are considered to be
		whitespace.

 ******************************************************************************/

bool
JTextEditor::LocateNextWhitespace
	(
	const JSize	bufLength,
	JIndex*		startIndex
	)
	const
{
	for (JIndex i=*startIndex; i<bufLength; i++)
		{
		const JCharacter c = itsBuffer->GetCharacter(i);
		if ((!itsBreakCROnlyFlag && isspace(c)) ||
			( itsBreakCROnlyFlag && c == '\n'))
			{
			*startIndex = i;
			return kTrue;
			}
		}

	return kFalse;
}

/******************************************************************************
 GetSubwordForLine (private)

	*** Only for use by RecalcLine()

	Starting with the given index, return the number of characters that
	will fit on a line.  Sets *lineWidth to the width of the line in pixels.
	We always put at least one character on the line.

 ******************************************************************************/

JSize
JTextEditor::GetSubwordForLine
	(
	const JSize		bufLength,
	const JIndex	lineIndex,
	const JIndex	startIndex,
	JCoordinate*	lineWidth
	)
	const
{
	*lineWidth = 0;

	JIndex endIndex = 0;
	CaretLocation caretLoc(0, lineIndex);
	for (JIndex i=startIndex; i<=bufLength; i++)
		{
		caretLoc.charIndex   = i;
		const JCoordinate dw = GetCharWidth(caretLoc);
		if (i > startIndex && *lineWidth + dw > itsWidth)
			{
			endIndex = i-1;
			break;
			}
		else
			{
			*lineWidth += dw;
			}
		}
	if (endIndex == 0)
		{
		endIndex = bufLength;
		}

	return (endIndex - startIndex + 1);
}

/******************************************************************************
 NoPrevWhitespaceOnLine (private)

	Returns kTrue if there is no whitespace between startIndex-1 and
	the first character on the line.

	Called by Recalc1() to decide whether or not to start on the
	previous line.

 ******************************************************************************/

bool
JTextEditor::NoPrevWhitespaceOnLine
	(
	const JCharacter*	str,
	const CaretLocation	startLoc
	)
	const
{
	const JIndex firstChar = GetLineStart(startLoc.lineIndex);
	for (JIndex i = startLoc.charIndex - 1; i>firstChar; i--)
		{
		if (isspace(str[i-1]))
			{
			return kFalse;
			}
		}

	return kTrue;	// we hit the start of the string
}

/******************************************************************************
 CalcCaretLocation (private)

	Return the closest insertion point.  If the line ends with a space,
	the last possible insertion point is in front of this space

 ******************************************************************************/

JTextEditor::CaretLocation
JTextEditor::CalcCaretLocation
	(
	const JPoint& pt
	)
	const
{
	const JSize bufLength = itsBuffer->GetLength();
	if (bufLength == 0)
		{
		return CaretLocation(1,1);
		}
	else if (pt.y >= itsHeight)
		{
		return CaretLocation(bufLength+1, GetLineCount());
		}

	// find the line that was clicked on

	JCoordinate lineTop;
	const JIndex lineIndex = CalcLineIndex(pt.y, &lineTop);
	if (EndsWithNewline() &&									// ends with newline
		itsHeight - GetEWNHeight() < pt.y && pt.y <= itsHeight)
		{
		return CaretLocation(bufLength+1, GetLineCount());
		}

	// find the closest insertion point

	JIndex charIndex = 0;
	{
	const JIndex lineStart = GetLineStart(lineIndex);

	JIndex lineEnd = GetLineEnd(lineIndex);
	if ((lineEnd < bufLength || EndsWithNewline()) &&	// ends with newline
		isspace(itsBuffer->GetCharacter(lineEnd)))
		{
		lineEnd--;
		}

	JCoordinate prevD = pt.x;
	if (prevD <= 0)
		{
		charIndex = lineStart;
		}
	else
		{
		JCoordinate x = 0;
		for (JIndex i=lineStart; i<=lineEnd; i++)
			{
			x += GetCharWidth(CaretLocation(i, lineIndex));
			const JCoordinate d = pt.x - x;
			if (d == 0)
				{
				charIndex = i+1;
				break;
				}
			else if (d < 0 && prevD <= -d)
				{
				charIndex = i;
				break;
				}
			else if (d < 0 && prevD > -d)
				{
				charIndex = i+1;
				break;
				}
			prevD = d;
			}

		if (charIndex == 0)
			{
			charIndex = lineEnd+1;
			}
		}
	}

	return CaretLocation(charIndex, lineIndex);
}

/******************************************************************************
 CalcLineIndex (private)

 ******************************************************************************/

JIndex
JTextEditor::CalcLineIndex
	(
	const JCoordinate	y,
	JCoordinate*		lineTop
	)
	const
{
	JIndex lineIndex = 1;
	JCoordinate h    = 0;

	const JSize runCount = itsLineGeom->GetRunCount();
	for (JIndex i=1; i<=runCount && h < y; i++)
		{
		const JSize runLength    = itsLineGeom->GetRunLength(i);
		const LineGeometry& geom = itsLineGeom->GetRunDataRef(i);

		const JCoordinate newH = h + geom.height * runLength;
		if (y < newH)
			{
			const JSize deltaLines = (y - h) / geom.height;
			lineIndex += deltaLines;
			h         += geom.height * deltaLines;
			break;
			}
		else
			{
			lineIndex += runLength;
			h          = newH;

			if (i == runCount)		// return last line
				{
				lineIndex--;
				h -= geom.height;
				}
			}
		}

	*lineTop = h;
	return lineIndex;
}

/******************************************************************************
 GetEWNHeight (private)

	Not inline to avoid including JFontManager.h in header file

 ******************************************************************************/

JCoordinate
JTextEditor::GetEWNHeight()
	const
{
	const Font f = CalcInsertionFont(itsBuffer->GetLength() + 1);
	return itsFontMgr->GetLineHeight(f.id, f.size, f.style);
}
