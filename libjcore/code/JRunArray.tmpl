#ifndef _T_JRunArray
#define _T_JRunArray

/******************************************************************************
 JRunArray.tmpl

	JRunArray is a dynamic array optimized to conserve space where
	consecutive entries have the same value. Such a sequence of
	identical entries is called a run. Rather than storing N
	consecutive, identical entries, JRunArray stores the value once, 
	along with the length of the run.

	When using a JRunArray, operator== must be defined for the data type.

	gcc 2.7.2 does not implement static data for template classes, without
	which we cannot provide an efficient implementation of Sort().

	Implementation details:

	A JArray is used to store the run lengths + actual items.
	Thus, JRunArrays cannot store objects, only intrinisic types.

	BASE CLASS = JList

	Copyright (C) 1994-2018 by John Lindal.

 ******************************************************************************/

#include "JRunArray.h"
#include "jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JRunArray<T>::JRunArray
	(
	const JSize blockSize
	)
	:
	JList<T>()
{
	itsRuns = jnew JArray< JRunArrayElement<T> >(blockSize);
	assert( itsRuns != nullptr );
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JRunArray<T>::JRunArray
	(
	const JRunArray<T>& source
	)
	:
	JList<T>(source)
{
	itsRuns = jnew JArray< JRunArrayElement<T> >(*source.itsRuns);
	assert( itsRuns != nullptr );
}

template <class T>
JRunArray<T>::JRunArray
	(
	const JRunArray<T>&	source,
	const JIndexRange&	range
	)
{
	itsRuns = jnew JArray< JRunArrayElement<T> >(source.itsRuns->GetBlockSize());
	assert( itsRuns != nullptr );

	JIndex runIndex = 1, firstIndexInRun = 1;
	IteratorInsertSlice(1, source, range, &runIndex, &firstIndexInRun);
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JRunArray<T>::~JRunArray()
{
	jdelete itsRuns;
}

/******************************************************************************
 Assignment operator

 ******************************************************************************/

template <class T>
const JRunArray<T>&
JRunArray<T>::operator=
	(
	const JRunArray<T>& source
	)
{
	if (this == &source)
	{
		return *this;
	}

	JCollection::operator=(source);		// JList::operator= is private

	*itsRuns = *source.itsRuns;
	JRunArray<T>::ListAssigned(source);

	return *this;
}

/******************************************************************************
 PrependElement (virtual)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::PrependElement
	(
	const T& data
	)
{
	PrependElements(data, 1);
}

/******************************************************************************
 PrependElements

	Prepend a run of elements.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::PrependElements
	(
	const T&	data,
	const JSize	count
	)
{
	JIndex runIndex = 1, firstIndexInRun = 1;
	IteratorInsertElementsAtIndex(1, data, count, &runIndex, &firstIndexInRun);
}

/******************************************************************************
 PrependSlice

 ******************************************************************************/

template <class T>
void
JRunArray<T>::PrependSlice
	(
	const JRunArray<T>&	source,
	const JIndexRange&	range
	)
{
	JIndex runIndex = 1, firstIndexInRun = 1;
	IteratorInsertSlice(1, source, range, &runIndex, &firstIndexInRun);
}

/******************************************************************************
 AppendElement (virtual)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::AppendElement
	(
	const T& data
	)
{
	AppendElements(data, 1);
}

/******************************************************************************
 AppendElements

	Append a run of elements.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::AppendElements
	(
	const T&	data,
	const JSize	count
	)
{
	const JSize totalCount = this->GetElementCount();

	JIndex runIndex, firstIndexInRun;
	FindRun(totalCount, &runIndex, &firstIndexInRun);

	IteratorInsertElementsAtIndex(totalCount+1, data, count, &runIndex, &firstIndexInRun);
}

/******************************************************************************
 AppendSlice

 ******************************************************************************/

template <class T>
void
JRunArray<T>::AppendSlice
	(
	const JRunArray<T>&	source,
	const JIndexRange&	range
	)
{
	const JSize totalCount = this->GetElementCount();

	JIndex runIndex, firstIndexInRun;
	FindRun(totalCount, &runIndex, &firstIndexInRun);

	IteratorInsertSlice(totalCount+1, source, range, &runIndex, &firstIndexInRun);
}

/******************************************************************************
 IteratorInsertElementsAtIndex (private)

	Insert a run of elements into the array at the specified index.
	Any elements at or below elementIndex are moved down. If index is any value
	greater than the current size, then the elements are appended to the end
	of the array.

	Assumes *runIndex,*firstIndexInRun refer to the run containing
	elementIndex and updates them based on what has to be done to the runs.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::IteratorInsertElementsAtIndex
	(
	const JIndex	elementIndex,
	const T&		data,
	const JSize		newElementCount,
	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
{
	if (newElementCount > 0)
	{
		const JIndex trueElementIndex =
			PrivateInsertElementsAtIndex(elementIndex, data, newElementCount,
										 runIndex, firstIndexInRun);

		JListT::ElementsInserted message(trueElementIndex, newElementCount);
		JList<T>::NotifyIterators(message);
		JBroadcaster::Broadcast(message);
	}
}

/******************************************************************************
 IteratorInsertSlice (private)

	Optimized copy of a slice of another JRunArray.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::IteratorInsertSlice
	(
	const JIndex		elementIndex,
	const JRunArray<T>&	source,
	const JIndexRange&	range,
	JIndex*				runIndex,
	JIndex*				firstIndexInRun
	)
{
	JIndex startRun, firstIndexInStartRun;
	if (!source.FindRun(range.first, &startRun, &firstIndexInStartRun))
	{
		return;
	}

	JIndex endRun = startRun, firstIndexInEndRun = firstIndexInStartRun;
	if (!source.IncrementalFindRun(range.first, range.last, &endRun, &firstIndexInEndRun))
	{
		return;
	}

	if (startRun == endRun)
	{
		PrivateInsertElementsAtIndex(elementIndex,
									 source.GetRunData(startRun), range.GetCount(),
									 runIndex, firstIndexInRun);

		JListT::ElementsInserted message(elementIndex, range.GetCount());
		JList<T>::NotifyIterators(message);
		JBroadcaster::Broadcast(message);
		return;
	}

	const JRunArrayElement<T>* sourceRuns = (source.itsRuns)->GetCArray();

	JSize count = sourceRuns[startRun-1].length - (range.first - firstIndexInStartRun);
	JIndex i    = PrivateInsertElementsAtIndex(elementIndex, sourceRuns[startRun-1].data, count,
											   runIndex, firstIndexInRun);
{
	JListT::ElementsInserted message(i, count);
	JList<T>::NotifyIterators(message);
	JBroadcaster::Broadcast(message);
}

	i += count;
	JIndex lastIndexInRun = *firstIndexInRun + GetRunLength(*runIndex) - 1;
	if (i > lastIndexInRun)
	{
		(*runIndex)++;
		*firstIndexInRun = lastIndexInRun + 1;
	}

	bool needSplit = i != *firstIndexInRun;

	for (JIndex j=startRun+1; j<endRun; j++)
	{
		count = sourceRuns[j-1].length;

		if (needSplit)
		{
			PrivateInsertElementsAtIndex(i, sourceRuns[j-1].data, count,
										 runIndex, firstIndexInRun);
			needSplit = false;
		}
		else
		{
			InsertRun(*runIndex, count, sourceRuns[j-1].data);
		}

		JListT::ElementsInserted message(i, count);
		JList<T>::NotifyIterators(message);
		JBroadcaster::Broadcast(message);

		i += count;
		(*runIndex)++;
		*firstIndexInRun = i;
	}

	count = range.last - firstIndexInEndRun + 1;
	PrivateInsertElementsAtIndex(i, sourceRuns[endRun-1].data, count,
								 runIndex, firstIndexInRun);
{
	JListT::ElementsInserted message(i, count);
	JList<T>::NotifyIterators(message);
	JBroadcaster::Broadcast(message);
}
}

/******************************************************************************
 PrivateInsertElementsAtIndex

	Returns the actual starting index so caller can broadcast the correct
	index.

	Assumes *runIndex,*firstIndexInRun refer to the run containing
	elementIndex and updates them based on what has to be done to the runs.

 ******************************************************************************/

template <class T>
JIndex
JRunArray<T>::PrivateInsertElementsAtIndex
	(
	const JIndex	elementIndex,
	const T&		data,
	const JSize		newElementCount,
	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
{
	assert( elementIndex > 0 );
	assert( newElementCount > 0 );

	if (JList<T>::IndexValid(elementIndex))
	{
		if (data == GetRunData(*runIndex))
		{
			IncrementRunLength(*runIndex, newElementCount);
		}
		else
		{
			// We save a lot of code by incrementing the run length and
			// then asking SetValue to handle the details of splitting
			// the run.

			IncrementRunLength(*runIndex, 1);
			PrivateSetElement(elementIndex, data, runIndex, firstIndexInRun);

			// now insert the rest, if any, once we know the runs won't change

			if (newElementCount > 1)
			{
				IncrementRunLength(*runIndex, newElementCount-1);
			}
		}

		return elementIndex;
	}
	else
	{
		// We need to append the data to the end of the array.

		const JSize elementCount = this->GetElementCount();
		const JSize runCount     = GetRunCount();

		if (runCount > 0 && data == GetRunData(runCount))
		{
			IncrementRunLength(runCount, newElementCount);
		}
		else
		{
			InsertRun(runCount+1, newElementCount, data);
		}

		*runIndex        = GetRunCount();
		*firstIndexInRun = this->GetElementCount() - GetRunLength(*runIndex) + 1;

		return elementCount + 1;
	}
}

/******************************************************************************
 GetFirstElement (virtual)

 ******************************************************************************/

template <class T>
T
JRunArray<T>::GetFirstElement()
	const
{
	return GetRunData(1);
}

/******************************************************************************
 GetLastElement (virtual)

 ******************************************************************************/

template <class T>
T
JRunArray<T>::GetLastElement()
	const
{
	return GetRunData(itsRuns->GetElementCount());
}

/******************************************************************************
 IteratorSetElements (private)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::IteratorSetElements
	(
	const JIndex	elementIndex,
	const T&		data,
	const JSize		count,
	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
{
	bool changed = true;
	if (count == 1)
	{
		changed = PrivateSetElement(elementIndex, data, runIndex, firstIndexInRun);
	}
	else
	{
		PrivateRemoveElements(elementIndex, count, runIndex, firstIndexInRun);

		if (JList<T>::IndexValid(elementIndex))
		{
			// We save a lot of code by incrementing the run length and
			// then asking SetValue to handle the details of splitting
			// the run.

			IncrementRunLength(*runIndex, 1);
			PrivateSetElement(elementIndex, data, runIndex, firstIndexInRun);
			IncrementRunLength(*runIndex, count-1);
		}
		else
		{
			PrivateInsertElementsAtIndex(elementIndex, data, count, runIndex, firstIndexInRun);
		}
	}

	if (changed)
	{
		JListT::ElementsChanged message(elementIndex, count);
		JList<T>::NotifyIterators(message);
		JBroadcaster::Broadcast(message);
	}
}

/******************************************************************************
 PrivateSetElement (private)

	Returns true if the element actually changed.

	Assumes *runIndex,*firstIndexInRun refer to the run containing
	elementIndex and updates them based on what has to be done to the runs.

 ******************************************************************************/

template <class T>
bool
JRunArray<T>::PrivateSetElement
	(
	const JIndex	elementIndex,
	const T&		data,
	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
{
	const T originalElement = GetRunData(*runIndex);
	if (data == originalElement)
	{
		return false;
	}

	const JSize origRunLength   = GetRunLength(*runIndex);
	const JIndex lastIndexInRun = *firstIndexInRun + origRunLength - 1;

	// check if the element can go in the previous run

	if (*runIndex > 1 && elementIndex == *firstIndexInRun &&
		data == GetRunData(*runIndex-1))
	{
		*firstIndexInRun -= GetRunLength(*runIndex-1);

		if (origRunLength == 1)
		{
			RemoveRun(*runIndex);
		}
		else
		{
			DecrementRunLength(*runIndex, 1);
		}

		(*runIndex)--;
		IncrementRunLength(*runIndex, 1);
	}

	// check if the element can go in the next run

	else if (*runIndex < GetRunCount() && elementIndex == lastIndexInRun &&
			 data == GetRunData(*runIndex+1))
	{
		IncrementRunLength(*runIndex+1, 1);

		if (origRunLength == 1)
		{
			RemoveRun(*runIndex, runIndex, firstIndexInRun);
		}
		else
		{
			DecrementRunLength(*runIndex, 1);
			*firstIndexInRun += GetRunLength(*runIndex);
			(*runIndex)++;
		}
	}

	// Since we can't merge it with the previous or the next run,
	// check if this is the only element in the run.

	else if (origRunLength == 1)
	{
		SetRunData(*runIndex, data);
	}

	// We have to break the run into two or more runs.

	else
	{
		// At this point we know the run size is greater than
		// one and if the item is at the start or end of the
		// run, we can't merge it with the previous or next run.
		// Therefore the item itself starts a new run, and there
		// may be a new run preceeding or following the item.

		if (elementIndex > *firstIndexInRun)
		{
			InsertRun(*runIndex, elementIndex - *firstIndexInRun, originalElement);
			(*runIndex)++;							// everything just moved down
		}
		if (elementIndex < lastIndexInRun)
		{
			InsertRun(*runIndex+1, lastIndexInRun - elementIndex, originalElement);
		}

		// The item now has the run all to itself. Update the value and length.

		JRunArrayElement<T> run = itsRuns->GetElement(*runIndex);

		this->SetElementCount(this->GetElementCount() - run.length + 1);

		run.length = 1;
		run.data   = data;
		itsRuns->SetElement(*runIndex, run);

		*firstIndexInRun = elementIndex;
	}

	return true;
}

/******************************************************************************
 IteratorRemoveElements (private)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::IteratorRemoveElements
	(
	const JIndex	firstIndex,
	const JSize		count,
	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
{
	if (firstIndex == 1 && count == this->GetElementCount())
	{
		RemoveAll();
	}
	else if (count > 0)
	{
		PrivateRemoveElements(firstIndex, count, runIndex, firstIndexInRun);

		JListT::ElementsRemoved message(firstIndex, count);
		JList<T>::NotifyIterators(message);
		JBroadcaster::Broadcast(message);
	}
}

/******************************************************************************
 PrivateRemoveElements (private)

	Assumes *runIndex,*firstIndexInRun refer to the run containing
	firstIndex and updates them based on what has to be done to the runs.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::PrivateRemoveElements
	(
	const JIndex	firstIndex,
	const JSize		count,
	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
{
	if (firstIndex == 1 && count == this->GetElementCount())
	{
		RemoveAll();
		return;
	}

	JSize remainder = count;
	while (remainder > 0 && firstIndex <= this->GetElementCount())
	{
		const JSize rightCount =
			GetRunLength(*runIndex) - (firstIndex - *firstIndexInRun);

		if (*firstIndexInRun == firstIndex && rightCount <= remainder)
		{
			RemoveRun(*runIndex, runIndex, firstIndexInRun);
			remainder -= rightCount;
		}
		else if (*firstIndexInRun < firstIndex && rightCount <= remainder)
		{
			DecrementRunLength(*runIndex, rightCount);
			remainder       -= rightCount;
			*firstIndexInRun = firstIndex;
			(*runIndex)++;
		}
		else	// remainder < rightCount
		{
			DecrementRunLength(*runIndex, remainder);
			break;
		}
	}
}

/******************************************************************************
 RemoveAll (virtual)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::RemoveAll()
{
	if (!this->IsEmpty())
	{
		JListT::ElementsRemoved message(1, this->GetElementCount());

		itsRuns->RemoveAll();
		this->SetElementCount(0);

		JList<T>::NotifyIterators(message);
		JBroadcaster::Broadcast(message);
	}
}

/******************************************************************************
 AllElementsEqual

 ******************************************************************************/

template <class T>
bool
JRunArray<T>::AllElementsEqual
	(
	T* data
	)
	const
{
	if (GetRunCount() == 1)
	{
		if (data != nullptr)
		{
			*data = GetRunData(1);
		}
		return true;
	}
	else
	{
		return false;
	}
}

/******************************************************************************
 SumElements

	Returns the sum of the specified range of elements, using the given
	accumulator function.  We assume that the result is an integer because
	a JRunArray of floating point values would be silly, given the problem
	of round off errors.

 ******************************************************************************/

template <class T>
JInteger
JRunArray<T>::SumElements
	(
	const JIndex startIndex,
	const JIndex endIndex,
	JInteger (*value)(const T& data)
	)
	const
{
	JIndex index = startIndex;
	JInteger sum = 0;

	JIndex runIndex, firstIndexInRun;
	const bool found = FindRun(index, &runIndex, &firstIndexInRun);
	assert( found && JList<T>::IndexValid(endIndex) );

	const JSize runCount = GetRunCount();
	for (JIndex i=runIndex; i<=runCount && index <= endIndex; i++)
	{
		const JSize runLength = GetRunLength(i);
		const JInteger v      = value(GetRunData(i));

		const JIndex newIndex = (i == runIndex ? firstIndexInRun : index) + runLength;
		if (newIndex <= endIndex)
		{
			sum += v * (newIndex - index);
		}
		else	// newIndex > endIndex
		{
			sum += v * (endIndex+1 - index);
			break;
		}

		index = newIndex;
	}

	return sum;
}

/******************************************************************************
 FindPositiveSum

	Returns the index of the element that causes the sum, starting from
	startIndex, to exceed requestedSum.  *trueSum is the sum of the elements
	up to, but not including, *endIndex.  This gives the correct behavior
	for determining which interval was clicked by a cursor.  To verify this,
	consider the case when all intervals have width one, and the left edge
	has coordinate zero.

	Returns false if the sum through the end of the array does not exceeed
	requestedSum.  In this case, *endIndex is the last element, and *trueSum
	is the sum up to, but not including, *endIndex.

	*** This function requires that requestedSum be positive.

 ******************************************************************************/

template <class T>
bool
JRunArray<T>::FindPositiveSum
	(
	const JInteger	requestedSum,
	const JIndex	startIndex,
	JIndex*			endIndex,
	JInteger*		trueSum,
	JInteger (*value)(const T& data)
	)
	const
{
	assert( requestedSum >= 0 );

	*endIndex = startIndex;
	*trueSum  = 0;

	JIndex runIndex, firstIndexInRun;
	const bool found = FindRun(*endIndex, &runIndex, &firstIndexInRun);
	assert( found );

	const JSize runCount = GetRunCount();
	for (JIndex i=runIndex; i<=runCount && *trueSum < requestedSum; i++)
	{
		const JSize runLength = GetRunLength(i);
		const JInteger v      = value(GetRunData(i));

		const JInteger newSum =
			*trueSum + v * (runLength - (i == runIndex ? startIndex - firstIndexInRun : 0));
		if (requestedSum < newSum)
		{
			assert( v > 0 /* this can only happen if v > 0 */ );

			const JSize deltaIndex = (requestedSum - *trueSum) / v;
			*endIndex             += deltaIndex;
			*trueSum              += v * deltaIndex;
			break;
		}
		else	// newSum <= requestedSum
		{
			*endIndex = (i == runIndex ? firstIndexInRun : *endIndex) + runLength;
			*trueSum  = newSum;

			if (i == runCount)		// return last element
			{
				(*endIndex)--;
				*trueSum -= v;
				return false;
			}
		}
	}

	return true;
}

/******************************************************************************
 GetBlockSize

	Get the block size used by the underlying JArray.

 ******************************************************************************/

template <class T>
JSize
JRunArray<T>::GetBlockSize()
	const
{
	return itsRuns->GetBlockSize();
}

/******************************************************************************
 SetBlockSize

	Set the block size used by the underlying JArray.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::SetBlockSize
	(
	const JSize newBlockSize
	)
{
	itsRuns->SetBlockSize(newBlockSize);
}

/******************************************************************************
 GetRunCount

 ******************************************************************************/

template <class T>
JSize
JRunArray<T>::GetRunCount()
	const
{
	return itsRuns->GetElementCount();
}

/******************************************************************************
 FindRun (private)

	Return the index of the run containing the element with the specified index.
	firstIndexInRun is updated with the index of the first element in the run.

	Returns false if elementIndex is not in the array.

	On the assumption that most run arrays have a relatively uniform
	distribution of runs (JTextEditor is a good example, JTableSelection
	with a rectangular selection is a counterexample), we start from the
	edge of the array that is closest to elementIndex.

 ******************************************************************************/

template <class T>
bool
JRunArray<T>::FindRun
	(
	const JIndex	elementIndex,

	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
	const
{
	const JSize count = this->GetElementCount();
	if (elementIndex <= 1 + count/2)	// automatically catches count==0
	{
		*runIndex        = 1;
		*firstIndexInRun = 1;
		return IncrementalFindRun(1, elementIndex, runIndex, firstIndexInRun);
	}
	else
	{
		*runIndex         = GetRunCount();
		*firstIndexInRun  = count - GetRunLength(*runIndex) + 1;
		return IncrementalFindRun(count, elementIndex, runIndex, firstIndexInRun);
	}
}

/******************************************************************************
 IncrementalFindRun (private)

	Assuming that *runIndex,*firstIndexInRun correspond to origIndex,
	modify them to correspond to newIndex.

	Returns false if origIndex or newIndex is not in the array.

 ******************************************************************************/

template <class T>
bool
JRunArray<T>::IncrementalFindRun
	(
	const JIndex	origIndex,
	const JIndex	newIndex,

	JIndex*			runIndex,
	JIndex*			firstIndexInRun
	)
	const
{
	if (!JList<T>::IndexValid(origIndex) ||
		!JList<T>::IndexValid(newIndex))
	{
		return false;
	}
	else if (origIndex == newIndex)
	{
		return true;
	}

	assert( *firstIndexInRun <= origIndex );

	bool found = false;
	if (newIndex < origIndex)
	{
		const JRunArrayElement<T>* r = itsRuns->GetCArray() + *runIndex-1;

		for (JIndex i=*runIndex; i>=1; i--)
		{
			if (*firstIndexInRun <= newIndex)
			{
				*runIndex = i;
				found     = true;
				break;
			}
			if (i > 1)
			{
				r--;
				*firstIndexInRun -= r->length;
			}
		}
	}
	else if (origIndex < newIndex)
	{
		const JRunArrayElement<T>* r = itsRuns->GetCArray() + *runIndex-1;
		JIndex lastIndexInRun        = *firstIndexInRun - 1;

		const JSize runCount = itsRuns->GetElementCount();
		for (JIndex i=*runIndex; i<=runCount; i++, r++)
		{
			lastIndexInRun += r->length;
			if (newIndex <= lastIndexInRun)
			{
				*runIndex        = i;
				*firstIndexInRun = lastIndexInRun - r->length + 1;
				found            = true;
				break;
			}
		}
	}

	return found;
}

/******************************************************************************
 InsertRun (private)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::InsertRun
	(
	const JIndex	runIndex,
	const JSize		newRunLength,
	const T&		data
	)
{
	JRunArrayElement<T> run(newRunLength, data);
	itsRuns->InsertElementAtIndex(runIndex, run);

	this->SetElementCount(this->GetElementCount() + newRunLength);
}

/******************************************************************************
 RemoveRun (private)

	This can result in the merging of two adjacent runs
	if they have the same value.

	newRunIndex,newFirstInRun can be nullptr.  If they are not, they must
	apply to the run that is being removed.  They are then updated if runs
	end up being merged.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::RemoveRun
	(
	const JIndex	runIndex,
	JIndex*			newRunIndex,
	JIndex*			newFirstInRun
	)
{
	assert( newRunIndex == nullptr || (*newRunIndex == runIndex && newFirstInRun != nullptr) );

	this->SetElementCount(this->GetElementCount() - GetRunLength(runIndex));
	itsRuns->RemoveElement(runIndex);

	// If the specified run was between two runs with the same value,
	// then we can merge them.

	if (1 < runIndex && runIndex <= GetRunCount() &&
		GetRunData(runIndex-1) == GetRunData(runIndex))
	{
		if (newRunIndex != nullptr)
		{
			*newFirstInRun -= GetRunLength(runIndex-1);
			(*newRunIndex)--;
		}

		const JSize runLength = GetRunLength(runIndex);
		IncrementRunLength(runIndex-1, runLength);

		this->SetElementCount(this->GetElementCount() - runLength);
		itsRuns->RemoveElement(runIndex);
	}
}

/******************************************************************************
 GetRunLength (private)

 ******************************************************************************/

template <class T>
JSize
JRunArray<T>::GetRunLength
	(
	const JIndex runIndex
	)
	const
{
	assert( itsRuns->IndexValid(runIndex) );
	const JRunArrayElement<T>* runData = itsRuns->GetCArray();
	return runData[runIndex-1].length;
}

/******************************************************************************
 SetRunLength (private)

	Set the length of the specified run, and keep elementCount up to date.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::SetRunLength
	(
	const JIndex	runIndex,
	const JSize		newLength
	)
{
	JRunArrayElement<T> run = itsRuns->GetElement(runIndex);

	this->SetElementCount(this->GetElementCount() - run.length + newLength);

	run.length = newLength;
	itsRuns->SetElement(runIndex, run);
}

/******************************************************************************
 IncrementRunLength (private)

	Add value of "extraElementCount" to the length of the specified run.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::IncrementRunLength
	(
	const JIndex	runIndex,
	const JSize		delta
	)
{
	SetRunLength(runIndex, GetRunLength(runIndex) + delta);
}

/******************************************************************************
 DecrementRunLength (private)

	Subtract value of "extraElementCount" from the length of the specified run.

 ******************************************************************************/

template <class T>
void
JRunArray<T>::DecrementRunLength
	(
	const JIndex	runIndex,
	const JSize		delta
	)
{
	SetRunLength(runIndex, GetRunLength(runIndex) - delta);
}

/******************************************************************************
 GetRunData (private)

 ******************************************************************************/

template <class T>
const T&
JRunArray<T>::GetRunData
	(
	const JIndex runIndex
	)
	const
{
	assert( itsRuns->IndexValid(runIndex) );
	const JRunArrayElement<T>* runData = itsRuns->GetCArray();
	return runData[runIndex-1].data;
}

/******************************************************************************
 SetRunData (private)

 ******************************************************************************/

template <class T>
void
JRunArray<T>::SetRunData
	(
	const JIndex	runIndex,
	const T&		data
	)
{
	JRunArrayElement<T> run = itsRuns->GetElement(runIndex);
	run.data = data;
	itsRuns->SetElement(runIndex, run);
}

/******************************************************************************
 NewIterator

 ******************************************************************************/

template <class T>
JListIterator<T>*
JRunArray<T>::NewIterator
	(
	const JIteratorPosition	start,
	const JIndex			index
	)
{
	JRunArrayIterator<T>* iter = jnew JRunArrayIterator<T>(this, start, index);
	assert( iter != nullptr );
	return iter;
}

template <class T>
JListIterator<T>*
JRunArray<T>::NewIterator
	(
	const JIteratorPosition	start,
	const JIndex			index
	)
	const
{
	JRunArrayIterator<T>* iter = jnew JRunArrayIterator<T>(*this, start, index);
	assert( iter != nullptr );
	return iter;
}

/******************************************************************************
 Range-based for loop

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>
begin
	(
	const JRunArray<T>& a
	)
{
	return JRunArrayIterator<T>(a, kJIteratorStartAtBeginning);
}

template <class T>
JRunArrayIterator<T>
end
	(
	const JRunArray<T>& a
	)
{
	return JRunArrayIterator<T>(a, kJIteratorStartAtEnd);
}

#endif
