#ifndef _T_JStringPtrMap
#define _T_JStringPtrMap

/******************************************************************************
 JStringPtrMap.tmpl

	A convenience for maps which store pointers.

	BASE CLASS = public JStringMap

	Copyright (C) 1998 by Dustin Laurence.
	
	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include "JStringPtrMap.h"
#include "JStringPtrMapCursor.h"
#include "jAssert.h"

/******************************************************************************
 Constructor

 *****************************************************************************/

template <class V>
JStringPtrMap<V>::JStringPtrMap
	(
	const JPtrArrayT::CleanUpAction action,
	const JSize                     lgSize  // = kJDefaultLgMinTableSize
	)
	:
	JStringMap<V*>(lgSize),
	itsCleanUpAction(action)
{
}

/******************************************************************************
 Destructor

 *****************************************************************************/

template <class V>
JStringPtrMap<V>::~JStringPtrMap()
{
	if (itsCleanUpAction == JPtrArrayT::kDeleteAll)
	{
		DeleteAll();
	}
	else if (itsCleanUpAction == JPtrArrayT::kDeleteAllAsArrays)
	{
		DeleteAllAsArrays();
	}
}

/******************************************************************************
 CleanOut

 ******************************************************************************/

template <class V>
void
JStringPtrMap<V>::CleanOut()
{
	if (itsCleanUpAction == JPtrArrayT::kDeleteAll)
	{
		DeleteAll();
	}
	else if (itsCleanUpAction == JPtrArrayT::kDeleteAllAsArrays)
	{
		DeleteAllAsArrays();
	}
	else
	{
		assert( itsCleanUpAction == JPtrArrayT::kForgetAll );
		JStringMap<V*>::RemoveAll();
	}
}

/******************************************************************************
 PrepareForSet (virtual protected)

	Operates on the cursor's element.

 *****************************************************************************/

template <class V>
void
JStringPtrMap<V>::PrepareForSet
	(
	const JPtrArrayT::SetAction action
	)
{
	if (action == JPtrArrayT::kDelete)
	{
		jdelete JHashTable< JStrValue<V*> >::GetCursor()->GetValue().value;
	}
	else if (action == JPtrArrayT::kDeleteAsArray)
	{
		jdelete [] JHashTable< JStrValue<V*> >::GetCursor()->GetValue().value;
	}
	else
	{
		assert( action == JPtrArrayT::kForget );
	}
}

/******************************************************************************
 Set...Element

	These override the versions in JStringMap to allow you to store a copy
	of the object.

 *****************************************************************************/

template <class V>
bool
JStringPtrMap<V>::SetItem
	(
	const JUtf8Byte*                   key,
	const V&                           data,
	const JPtrArrayT::SetAction action,
	const JStringMapT::SetType         type // = kAlways
	)
{
	V* ptr = jnew V(data);
	return SetItem(JString(key, JString::kNoCopy), ptr, action, type);
}

template <class V>
bool
JStringPtrMap<V>::SetItem
	(
	const JString&                     key,
	const V&                           data,
	const JPtrArrayT::SetAction action,
	const JStringMapT::SetType         type // = kAlways
	)
{
	V* ptr = jnew V(data);
	return SetItem(key, ptr, action, type);
}

template <class V>
bool
JStringPtrMap<V>::SetNewElement
	(
	const JUtf8Byte* key,
	const V&         data
	)
{
	V* ptr = jnew V(data);
	return SetNewElement(JString(key, JString::kNoCopy), ptr);
}

template <class V>
bool
JStringPtrMap<V>::SetNewElement
	(
	const JString& key,
	const V&       data
	)
{
	V* ptr = jnew V(data);
	return SetNewElement(key, ptr);
}

template <class V>
bool
JStringPtrMap<V>::SetOldElement
	(
	const JUtf8Byte*                   key,
	const V&                           data,
	const JPtrArrayT::SetAction action
	)
{
	V* ptr = jnew V(data);
	return SetOldElement(JString(key, JString::kNoCopy), ptr, action);
}

template <class V>
bool
JStringPtrMap<V>::SetOldElement
	(
	const JString&                     key,
	const V&                           data,
	const JPtrArrayT::SetAction action
	)
{
	V* ptr = jnew V(data);
	return SetOldElement(key, ptr, action);
}

template <class V>
bool
JStringPtrMap<V>::SetContains
	(
	const JUtf8Byte*                   key,
	const V&                           data,
	const JPtrArrayT::SetAction action
	)
{
	V* ptr = jnew V(data);
	return SetContains(JString(key, JString::kNoCopy), ptr, action);
}

template <class V>
bool
JStringPtrMap<V>::SetContains
	(
	const JString&                     key,
	const V&                           data,
	const JPtrArrayT::SetAction action
	)
{
	V* ptr = jnew V(data);
	return SetContains(key, ptr, action);
}

#endif
