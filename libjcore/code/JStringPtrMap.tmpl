#ifndef _T_JStringPtrMap
#define _T_JStringPtrMap

/******************************************************************************
 JStringPtrMap.tmpl

	A convenience for maps which store pointers.

	BASE CLASS = public JStringMap

	Copyright © 1998 by Dustin Laurence.  All rights reserved.
	
	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include <JStringPtrMap.h>
#include <JStringPtrMapCursor.h>
#include <jAssert.h>

/******************************************************************************
 Constructor

 *****************************************************************************/

template <class V>
JStringPtrMap<V>::JStringPtrMap
	(
	const JPtrArrayT::CleanUpAction action,
	const JBoolean                  copyKeys
	)
	:
	JStringMap<V*>(copyKeys),
	itsCleanUpAction(action)
{
}

template <class V>
JStringPtrMap<V>::JStringPtrMap
	(
	const JPtrArrayT::CleanUpAction action,
	const JSize                     lgSize,  // = kJDefaultLgMinTableSize
	const JBoolean                  copyKeys // = kJTrue
	)
	:
	JStringMap<V*>(lgSize, copyKeys),
	itsCleanUpAction(action)
{
}

/******************************************************************************
 Destructor

 *****************************************************************************/

template <class V>
JStringPtrMap<V>::~JStringPtrMap()
{
	if (itsCleanUpAction == JPtrArrayT::kDeleteAll)
		{
		DeleteAll();
		}
	else if (itsCleanUpAction == JPtrArrayT::kDeleteAllAsArrays)
		{
		DeleteAllAsArrays();
		}
}

/******************************************************************************
 CleanOut

 ******************************************************************************/

template <class V>
void
JStringPtrMap<V>::CleanOut()
{
	if (itsCleanUpAction == JPtrArrayT::kDeleteAll)
		{
		DeleteAll();
		}
	else if (itsCleanUpAction == JPtrArrayT::kDeleteAllAsArrays)
		{
		DeleteAllAsArrays();
		}
	else
		{
		assert( itsCleanUpAction == JPtrArrayT::kForgetAll );
		JStringMap<V*>::RemoveAll();
		}
}

#ifdef JStringPtrMapCopy

/******************************************************************************
 Set...Element

	These override the versions in JStringMap to allow you to store a copy
	of the object.

 *****************************************************************************/

template <class V>
JBoolean
JStringPtrMap<V>::SetElement
	(
	const JCharacter* const            key,
	const V&                           data,
	const JPtrArrayT::SetElementAction action,
	const JStringMapT::SetType         type // = kAlways
	)
{
	V* ptr = new V(data);
	assert( ptr != NULL );
	return SetElement(key, ptr, action, type);
}

template <class V>
JBoolean
JStringPtrMap<V>::SetNewElement
	(
	const JCharacter* const key,
	const V&                data
	)
{
	V* ptr = new V(data);
	assert( ptr != NULL );
	return SetNewElement(key, ptr);
}

template <class V>
JBoolean
JStringPtrMap<V>::SetOldElement
	(
	const JCharacter* const            key,
	const V&                           data,
	const JPtrArrayT::SetElementAction action
	)
{
	V* ptr = new V(data);
	assert( ptr != NULL );
	return SetOldElement(key, ptr, action);
}

template <class V>
JBoolean
JStringPtrMap<V>::SetContains
	(
	const JCharacter* const            key,
	const V&                           data,
	const JPtrArrayT::SetElementAction action
	)
{
	V* ptr = new V(data);
	assert( ptr != NULL );
	return SetContains(key, ptr, action);
}

#endif	// JStringPtrMapCopy

#endif

// Instantiate the template for the specified type.

#if defined JTemplateType && ! defined JOnlyWantTemplateDefinition
	#define JTemplateName JStringPtrMap
	#include <instantiate_template.h>
	#undef JTemplateName
#endif
