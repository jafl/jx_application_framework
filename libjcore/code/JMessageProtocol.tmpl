#ifndef _T_JMessageProtocol
#define _T_JMessageProtocol

/******************************************************************************
 JMessageProtocol.tmpl

	Parses incoming bytes into messages separated by itsSeparatorStr.

	The data that you send can contain any byte sequence other than
	itsDisconnectStr.  This sequence is reserved for terminating the
	connection.  (You can set itsDisconnectStr to be empty.)

	The default is the UNIX protocol which uses "\n" as separator and "\0" as
	terminator.  Macintosh sets the separator to "\r", and DOS sets the
	separator to "\r\n".  In general, the separator must not contain the
	terminator, and visa versa.

	BASE CLASS = JNetworkProtocolBase, virtual JBroadcaster

	Copyright (C) 1998-2000 by John Lindal. All rights reserved.

 ******************************************************************************/

#include <JMessageProtocol.h>
#include <JStringIterator.h>
#include <JStringMatch.h>
#include <JMinMax.h>
#include <jAssert.h>

/******************************************************************************
 Constructor

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JMessageProtocol<ACE_PEER_STREAM_2>::JMessageProtocol
	(
	const JBoolean synchSend
	)
	:
	JNetworkProtocolBase<ACE_PEER_STREAM_2>(synchSend),
	itsMessageList(JPtrArrayT::kDeleteAll)
{
	JMessageProtocolX();
}

template <ACE_PEER_STREAM_1>
JMessageProtocol<ACE_PEER_STREAM_2>::JMessageProtocol
	(
	const ACE_HANDLE	fd,
	const JBoolean		synchSend
	)
	:
	JNetworkProtocolBase<ACE_PEER_STREAM_2>(synchSend),
	itsMessageList(JPtrArrayT::kDeleteAll)
{
	JMessageProtocolX();

	ACE_Svc_Handler<ACE_PEER_STREAM_2, ACE_SYNCH>::set_handle(fd);
	ACE_Svc_Handler<ACE_PEER_STREAM_2, ACE_SYNCH>::open(NULL);
}

// private

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::JMessageProtocolX()
{
	NewMessage();

	itsBufferSize   = JMessageProtocolT::kDefaultBufferSize;
	itsBufferOffset = 0;

	itsBuffer = jnew JUtf8Byte [ itsBufferSize ];
	assert( itsBuffer != NULL );

	UseUNIXProtocol();

	itsSentDisconnectFlag     = kJFalse;
	itsReceivedDisconnectFlag = kJFalse;
	itsInHandleInputFlag      = kJFalse;
}

/******************************************************************************
 Destructor

	Client must call SendDisconnect() explicitly.  This makes their code
	clearer.  It also allows using this class on read-only connections
	because the client can ensure that nothing will ever be written.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JMessageProtocol<ACE_PEER_STREAM_2>::~JMessageProtocol()
{
	jdelete [] itsBuffer;
}

/******************************************************************************
 Protocol

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::GetProtocol
	(
	JString* separator,
	JString* disconnect
	)
	const
{
	*separator  = itsSeparatorStr;
	*disconnect = itsDisconnectStr;
}

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::SetProtocol
	(
	const JUtf8Byte*	separatorStr,
	const JSize			separatorByteCount,
	const JUtf8Byte*	disconnectStr,
	const JSize			disconnectByteCount
	)
{
	assert( separatorByteCount > 0 );

	itsSeparatorStr.Set(separatorStr, separatorByteCount > 0 ? separatorByteCount : strlen(separatorStr));
	itsDisconnectStr.Set(disconnectStr, disconnectByteCount > 0 ? disconnectByteCount : strlen(disconnectStr));

	assert( disconnectByteCount == 0 ||
			(separatorByteCount == disconnectByteCount &&
			 itsSeparatorStr != itsDisconnectStr) ||
			(separatorByteCount > disconnectByteCount &&
			 !itsSeparatorStr.Contains(itsDisconnectStr)) ||
			(disconnectByteCount > separatorByteCount &&
			 !itsDisconnectStr.Contains(itsSeparatorStr)) );

	UpdateTokenPattern();
}

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::UseUNIXProtocol()
{
	itsSeparatorStr.Set(JMessageProtocolT::kUNIXSeparatorStr,
						JMessageProtocolT::kUNIXSeparatorByteCount);
	itsDisconnectStr.Set(JMessageProtocolT::kStdDisconnectStr,
						 JMessageProtocolT::kStdDisconnectByteCount);
	UpdateTokenPattern();
}

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::UseMacintoshProtocol()
{
	itsSeparatorStr.Set(JMessageProtocolT::kMacintoshSeparatorStr,
						JMessageProtocolT::kMacintoshSeparatorByteCount);
	itsDisconnectStr.Set(JMessageProtocolT::kStdDisconnectStr,
						 JMessageProtocolT::kStdDisconnectByteCount);
	UpdateTokenPattern();
}

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::UseDOSProtocol()
{
	itsSeparatorStr.Set(JMessageProtocolT::kDOSSeparatorStr,
						JMessageProtocolT::kDOSSeparatorByteCount);
	itsDisconnectStr.Set(JMessageProtocolT::kStdDisconnectStr,
						 JMessageProtocolT::kStdDisconnectByteCount);
	UpdateTokenPattern();
}

/******************************************************************************
 Buffer size

	This controls how much is read from the connection at one time.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JSize
JMessageProtocol<ACE_PEER_STREAM_2>::GetBufferSize()
	const
{
	return itsBufferSize;
}

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::SetBufferSize
	(
	const JSize bufferSize
	)
{
	assert( bufferSize > 0 );

	itsBufferSize = bufferSize;

	jdelete [] itsBuffer;
	itsBuffer = jnew JUtf8Byte [ itsBufferSize ];
	assert( itsBuffer != NULL );
}

/******************************************************************************
 ReceivedDisconnect

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JBoolean
JMessageProtocol<ACE_PEER_STREAM_2>::ReceivedDisconnect()
	const
{
	return itsReceivedDisconnectFlag;
}

/******************************************************************************
 SendDisconnect

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::SendDisconnect()
{
	assert( !itsDisconnectStr.IsEmpty() );

	if (!itsSentDisconnectFlag)
		{
		JNetworkProtocolBase<ACE_PEER_STREAM_2>::Send(itsDisconnectStr);
		itsSentDisconnectFlag = kJTrue;
		}
}

/******************************************************************************
 HasMessages

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JBoolean
JMessageProtocol<ACE_PEER_STREAM_2>::HasMessages()
	const
{
	return JConvertToBoolean( itsMessageList.GetElementCount() > 1 );
}

/******************************************************************************
 GetMessageCount

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JSize
JMessageProtocol<ACE_PEER_STREAM_2>::GetMessageCount()
	const
{
	return itsMessageList.GetElementCount() - 1;
}

/******************************************************************************
 GetNextMessage

	Stores the next complete message in *message and removes it from the queue.
	Returns kJFalse if no complete messages are available.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JBoolean
JMessageProtocol<ACE_PEER_STREAM_2>::GetNextMessage
	(
	JString* message
	)
{
	if (itsMessageList.GetElementCount() > 1)
		{
		*message = *(itsMessageList.FirstElement());
		itsMessageList.DeleteElement(1);
		return kJTrue;
		}
	else
		{
		message->Clear();
		return kJFalse;
		}
}

/******************************************************************************
 PeekNextMessage

	Stores the next complete message in *message.
	Returns kJFalse if no complete messages are available.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JBoolean
JMessageProtocol<ACE_PEER_STREAM_2>::PeekNextMessage
	(
	JString* message
	)
{
	if (!itsMessageList.IsEmpty())
		{
		*message = *(itsMessageList.FirstElement());
		return kJTrue;
		}
	else
		{
		message->Clear();
		return kJFalse;
		}
}

/******************************************************************************
 PeekPartialMessage

	Stores the message that is being received in *message.
	Returns kJFalse if the message is empty.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JBoolean
JMessageProtocol<ACE_PEER_STREAM_2>::PeekPartialMessage
	(
	JString* message
	)
{
	*message = itsRecvData;
	return JNegate( message->IsEmpty() );
}

/******************************************************************************
 SendMessage

	Sends the given data and then a separator.  The data can contain separators.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::SendMessage
	(
	const JString& message
	)
{
	if (!itsSentDisconnectFlag)
		{
		iovec buffer[2];
		buffer[0].iov_base = const_cast<char*>(message.GetBytes());
		buffer[0].iov_len  = message.GetByteCount();
		buffer[1].iov_base = const_cast<char*>(itsSeparatorStr.GetBytes());
		buffer[1].iov_len  = itsSeparatorStr.GetByteCount();

		JNetworkProtocolBase<ACE_PEER_STREAM_2>::Send(buffer, 2);
		}
}

/******************************************************************************
 SendData

	Sends the given data without a separator.  The data can contain separators.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::SendData
	(
	const JString& data
	)
{
	if (!itsSentDisconnectFlag)
		{
		JNetworkProtocolBase<ACE_PEER_STREAM_2>::Send(data.GetBytes(), data.GetByteCount());
		}
}

/******************************************************************************
 TranslateFromUNIXAndSend

	Translates the data from UNIX protocol ("\n") and sends it.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::TranslateFromUNIXAndSend
	(
	const JString& data
	)
{
	TranslateAndSend(data,
					 JMessageProtocolT::kUNIXSeparatorStr,
					 JMessageProtocolT::kUNIXSeparatorByteCount);
}

/******************************************************************************
 TranslateFromMacintoshAndSend

	Translates the data from Macintosh protocol ("\r") and sends it.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::TranslateFromMacintoshAndSend
	(
	const JString& data
	)
{
	TranslateAndSend(data,
					 JMessageProtocolT::kMacintoshSeparatorStr,
					 JMessageProtocolT::kMacintoshSeparatorByteCount);
}

/******************************************************************************
 TranslateFromDOSAndSend

	Translates the data from DOS protocol ("\r\n") and sends it.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::TranslateFromDOSAndSend
	(
	const JString& data
	)
{
	TranslateAndSend(data,
					 JMessageProtocolT::kDOSSeparatorStr,
					 JMessageProtocolT::kDOSSeparatorByteCount);
}

/******************************************************************************
 TranslateAndSend

	Translates the data from the given protocol and sends it.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::TranslateAndSend
	(
	const JString&		data,
	const JUtf8Byte*	separatorStr,
	const JSize			separatorByteCount
	)
{
	if (data.IsEmpty())
		{
		return;
		}

	// build list of data blocks to send

	JArray<iovec> bufferList(100);

	iovec sepBuffer;
	sepBuffer.iov_base = const_cast<char*>(itsSeparatorStr.GetBytes());
	sepBuffer.iov_len  = itsSeparatorStr.GetByteCount();

	JStringIterator iter(data);
	iter.BeginMatch();
	while (iter.Next(separatorStr, separatorByteCount))
		{
		const JStringMatch& m  = iter.FinishMatch();
		const JUtf8ByteRange r = m.GetUtf8ByteRange();

		iovec buffer;
		buffer.iov_base = const_cast<char*>(data.GetBytes() + r.first - 1);
		buffer.iov_len  = r.GetCount();;
		bufferList.AppendElement(buffer);		// send data
		bufferList.AppendElement(sepBuffer);	// send separator
		}

	// send all data blocks in one shot

	JNetworkProtocolBase<ACE_PEER_STREAM_2>::Send(bufferList.GetCArray(), bufferList.GetElementCount());
}

/******************************************************************************
 handle_input (virtual)

	This is called when we receive data.  It is also safe for anybody else
	to call it.

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
int
JMessageProtocol<ACE_PEER_STREAM_2>::handle_input
	(
	ACE_HANDLE
	)
{
	// protect against recursive calls

	if (itsInHandleInputFlag)
		{
		return 0;
		}
	itsInHandleInputFlag = kJTrue;

	// We flush the system buffer even if we have received a disconnect.

	const ssize_t count = (ACE_Svc_Handler<ACE_PEER_STREAM_2, ACE_SYNCH>::peer()).recv(itsBuffer + itsBufferOffset, itsBufferSize - itsBufferOffset);
	if (itsReceivedDisconnectFlag || count <= 0)
		{
		itsInHandleInputFlag = kJFalse;
		return 0;
		}

	JSize remainingCount = count;
	JSize validCount     = 0;
	JSize byteCount;
	while (JUtf8Character::IsCompleteCharacter(itsBuffer + validCount, remainingCount, &byteCount))
		{
		validCount     += byteCount;
		remainingCount -= byteCount;
		}

	itsRecvData.Append(itsBuffer, validCount);

	memmove(itsBuffer, itsBuffer + validCount, remainingCount);
	itsBufferOffset = remainingCount;

	JStringIterator iter(&itsRecvData);
	iter.BeginMatch();
	while (iter.Next(itsTokenPattern))
		{
		JString* msg = itsMessageList.LastElement();

		if (!itsDisconnectStr.IsEmpty())
			{
			const JStringMatch& m = iter.GetLastMatch();
			if (m.GetString() == itsDisconnectStr)
				{
				itsReceivedDisconnectFlag = kJTrue;

				const JStringMatch& m = iter.FinishMatch();
				*msg += m.GetString();
				if (!msg->IsEmpty())
					{
					NewMessage();
					Broadcast(JMessageProtocolT::MessageReady(*msg));
					}

				itsRecvData.Clear();
				Broadcast(JMessageProtocolT::ReceivedDisconnect());
				// we might be deleted and itsInHandleInputFlag is now irrelevant
				return 0;
				}
			}

		const JStringMatch& m = iter.FinishMatch();
		*msg += m.GetString();
		NewMessage();
		Broadcast(JMessageProtocolT::MessageReady(*msg));

		iter.RemoveAllPrev();
		iter.BeginMatch();
		}

	// leave remaining characters in itsRecvData

	itsInHandleInputFlag = kJFalse;
	return 0;
}

/******************************************************************************
 NewMessage (private)

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
JString*
JMessageProtocol<ACE_PEER_STREAM_2>::NewMessage()
{
	JString* msg = jnew JString;
	assert( msg != NULL );
	itsMessageList.Append(msg);
	return msg;
}

/******************************************************************************
 UpdateTokenPattern (private)

 ******************************************************************************/

template <ACE_PEER_STREAM_1>
void
JMessageProtocol<ACE_PEER_STREAM_2>::UpdateTokenPattern()
{
	JString pattern = JRegex::BackslashForLiteral(itsSeparatorStr);
	pattern        += "|";
	pattern        += JRegex::BackslashForLiteral(itsDisconnectStr);
	itsTokenPattern.SetPatternOrDie(pattern);
}

#endif
