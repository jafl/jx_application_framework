#ifndef _T_JArray
#define _T_JArray

/******************************************************************************
 JArray.tmpl

							The JArray Template Class

	Template for a dynamically sized array.  The data is stored contiguously.

	*** Since memcpy and memmove are used for large scale rearrangement of
		the array elements, this can -only- be used for structs.
		To store objects, use the JPtrArray template class.

	We do not override ToString():  Since this function is virtual, it is
	always instantiated.  Thus, we cannot print the values, because they
	might not have operator<<

	BASE CLASS = JList

	Copyright (C) 1994-97 by John Lindal.

 ******************************************************************************/

#include "JArray.h"
#include "JMinMax.h"
#include <string.h>		// for memcpy,memmove
#include <stdlib.h>		// for qsort
#include "jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JArray<T>::JArray
	(
	const JSize blockSize
	)
	:
	JList<T>()
{
	assert( blockSize > 0 );

	itsElements = jnew T [ blockSize ];
	assert( itsElements != nullptr );

	itsSlotCount = blockSize;
	itsBlockSize = blockSize;
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JArray<T>::JArray
	(
	const JArray<T>& source
	)
	:
	JList<T>(source)
{
	itsElements = nullptr;		// makes delete [] safe inside CopyArray

	CopyArray(source);
}

/******************************************************************************
 Move constructor

 ******************************************************************************/

template <class T>
JArray<T>::JArray
	(
	JArray<T>&& dyingSource
	)
	:
	JList<T>(dyingSource),
	itsElements(dyingSource.itsElements),
	itsSlotCount(dyingSource.itsSlotCount),
	itsBlockSize(dyingSource.itsBlockSize)
{
	dyingSource.itsElements = nullptr;
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JArray<T>::~JArray()
{
	jdelete [] itsElements;
}

/******************************************************************************
 Assignment operator

 ******************************************************************************/

template <class T>
const JArray<T>&
JArray<T>::operator=
	(
	const JArray<T>& source
	)
{
	if (this == &source)
		{
		return *this;
		}

	JCollection::operator=(source);		// JList::operator= is private

	CopyArray(source);
	JArray<T>::ListAssigned(source);

	return *this;
}

/******************************************************************************
 CopyArray (private)

	Copies everything from source.

 ******************************************************************************/

template <class T>
void
JArray<T>::CopyArray
	(
	const JArray<T>& source
	)
{
	itsSlotCount = source.itsSlotCount;
	itsBlockSize = source.itsBlockSize;

	jdelete [] itsElements;
	itsElements = jnew T [ itsSlotCount ];
	assert( itsElements != nullptr );

	memcpy(itsElements, source.itsElements, itsSlotCount * sizeof(T));
}

/******************************************************************************
 Cast to T*

 ******************************************************************************/

template <class T>
JArray<T>::operator const T*()
	const
{
	return itsElements;
}

/******************************************************************************
 GetCArray

 ******************************************************************************/

template <class T>
const T*
JArray<T>::GetCArray()
	const
{
	return itsElements;
}

/******************************************************************************
 AllocateCArray

 ******************************************************************************/

template <class T>
T*
JArray<T>::AllocateCArray()
	const
{
	const JSize count = this->GetElementCount();

	T* data = jnew T [ count ];
	assert( data != nullptr );

	memcpy(data, itsElements, count * sizeof(T));

	return data;
}

/******************************************************************************
 PrependElement

 ******************************************************************************/

template <class T>
void
JArray<T>::PrependElement
	(
	const T& data
	)
{
	InsertElementAtIndex(1, data);
}

/******************************************************************************
 AppendElement

 ******************************************************************************/

template <class T>
void
JArray<T>::AppendElement
	(
	const T& data
	)
{
	InsertElementAtIndex(this->GetElementCount() + 1, data);
}

/******************************************************************************
 InsertElementAtIndex

	Insert an element into the array at the specified index. Any elements
	at or below index are moved down. If index is any value greater
	than the current size, then the element is appended to the end
	of the array.

 ******************************************************************************/

template <class T>
void
JArray<T>::InsertElementAtIndex
	(
	const JIndex	index,
	const T&		data
	)
{
	const JIndex trueIndex = CreateElement(index);
	StoreElement(trueIndex, data);

	JListT::ElementsInserted message(trueIndex, 1);
	JBroadcaster::Broadcast(message);
	JList<T>::NotifyIterators(message);
}

/******************************************************************************
 CreateElement (private)

	Insert space for an element into the array at the specified index.
	Any elements at or above index are moved down. If index is any value greater
	than the current size, then the element is appended to the end
	of the array.

	The correct index of the jnew element is returned.

 ******************************************************************************/

template <class T>
JIndex
JArray<T>::CreateElement
	(
	const JIndex index
	)
{
	assert( index > 0 );

	const JSize elementCount = this->GetElementCount();
	if (elementCount >= itsSlotCount)
		{
		AddSlots();
		}

	JIndex trueIndex = index;
	if (trueIndex <= elementCount)
		{
		memmove(GetElementPtr(trueIndex + 1), GetElementPtr(trueIndex),
				(elementCount - trueIndex + 1) * sizeof(T));
		}
	else
		{
		trueIndex = elementCount + 1;
		}

	this->ElementAdded();

	return trueIndex;
}

/******************************************************************************
 RemoveElement

 ******************************************************************************/

template <class T>
void
JArray<T>::RemoveElement
	(
	const JIndex index
	)
{
	RemoveNextElements(index, 1);
}

/******************************************************************************
 RemoveNextElements

 ******************************************************************************/

template <class T>
void
JArray<T>::RemoveNextElements
	(
	const JIndex	firstIndex,
	const JSize		origCount
	)
{
	if (firstIndex == 1 && origCount >= this->GetElementCount())
		{
		RemoveAll();
		return;
		}

	assert( this->IndexValid(firstIndex) );

	const JSize elementCount = this->GetElementCount(),
				lastIndex    = JMin(elementCount, firstIndex + origCount-1),
				count        = lastIndex - firstIndex + 1;

	this->SetElementCount(elementCount - count);

	if (lastIndex < elementCount)
		{
		memmove(GetElementPtr(firstIndex), GetElementPtr(lastIndex + 1),
				(elementCount - lastIndex) * sizeof(T));
		}

	while (itsSlotCount > this->GetElementCount() + itsBlockSize)
		{
		RemoveSlots();
		}

	JListT::ElementsRemoved message(firstIndex, count);
	JBroadcaster::Broadcast(message);
	JList<T>::NotifyIterators(message);
}

/******************************************************************************
 RemovePrevElements

 ******************************************************************************/

template <class T>
void
JArray<T>::RemovePrevElements
	(
	const JIndex	lastIndex,
	const JSize		origCount
	)
{
	const JSize firstIndex   = origCount <= lastIndex ? lastIndex-origCount+1 : 1,
				count        = lastIndex - firstIndex + 1;

	RemoveNextElements(firstIndex, count);
}

/******************************************************************************
 RemoveElements

 ******************************************************************************/

template <class T>
void
JArray<T>::RemoveElements
	(
	const JIndexRange& range
	)
{
	RemoveNextElements(range.first, range.GetCount());
}

/******************************************************************************
 RemoveElements

 ******************************************************************************/

template <class T>
void
JArray<T>::RemoveElements
	(
	const JListT::ElementsRemoved& info
	)
{
	RemoveNextElements(info.GetFirstIndex(), info.GetCount());
}

/******************************************************************************
 RemoveAll

 ******************************************************************************/

template <class T>
void
JArray<T>::RemoveAll()
{
	if (!this->IsEmpty())
		{
		JListT::ElementsRemoved message(1, this->GetElementCount());

		this->SetElementCount(0);
		ResizeMemoryAllocation(itsBlockSize);

		JBroadcaster::Broadcast(message);
		JList<T>::NotifyIterators(message);
		}
}

/******************************************************************************
 GetElement

 ******************************************************************************/

template <class T>
T
JArray<T>::GetElement
	(
	const JIndex index
	)
	const
{
	assert( this->IndexValid(index) );

	return ProtectedGetElement(index);
}

/******************************************************************************
 ProtectedGetElement (protected)

 ******************************************************************************/

template <class T>
const T&
JArray<T>::ProtectedGetElement
	(
	const JIndex index
	)
	const
{
	return itsElements[index - 1];
}

/******************************************************************************
 SetElement

 ******************************************************************************/

template <class T>
void
JArray<T>::SetElement
	(
	const JIndex	index,
	const T&		data
	)
{
	assert( this->IndexValid(index) );

	StoreElement(index, data);

	JBroadcaster::Broadcast(JListT::ElementChanged(index));
}

/******************************************************************************
 GetElementFromEnd

 ******************************************************************************/

template <class T>
T
JArray<T>::GetElementFromEnd
	(
	const JIndex index
	)
	const
{
	return GetElement(this->GetIndexFromEnd(index));
}

/******************************************************************************
 SetElementFromEnd

 ******************************************************************************/

template <class T>
void
JArray<T>::SetElementFromEnd
	(
	const JIndex	index,
	const T&		data
	)
{
	SetElement(this->GetIndexFromEnd(index), data);
}

/******************************************************************************
 GetFirstElement

 ******************************************************************************/

template <class T>
T
JArray<T>::GetFirstElement()
	const
{
	return GetElement(1);
}

/******************************************************************************
 GetLastElement

 ******************************************************************************/

template <class T>
T
JArray<T>::GetLastElement()
	const
{
	return GetElement(this->GetElementCount());
}

/******************************************************************************
 MoveElementToIndex

 ******************************************************************************/

template <class T>
void
JArray<T>::MoveElementToIndex
	(
	const JIndex currentIndex,
	const JIndex newIndex
	)
{
	assert( this->IndexValid(currentIndex) );
	assert( this->IndexValid(newIndex) );

	if (currentIndex == newIndex)
		{
		return;
		}

	const T savedElement = ProtectedGetElement(currentIndex);

	if (currentIndex < newIndex)
		{
		memmove(GetElementPtr(currentIndex), GetElementPtr(currentIndex + 1),
				(newIndex - currentIndex) * sizeof(T));
		}
	else if (currentIndex > newIndex)
		{
		memmove(GetElementPtr(newIndex + 1), GetElementPtr(newIndex),
				(currentIndex - newIndex) * sizeof(T));
		}

	StoreElement(newIndex, savedElement);
	JBroadcaster::Broadcast(JListT::ElementMoved(currentIndex, newIndex));
}

/******************************************************************************
 MoveElementToIndex

 ******************************************************************************/

template <class T>
void
JArray<T>::MoveElementToIndex
	(
	const JListT::ElementMoved& info
	)
{
	MoveElementToIndex(info.GetOrigIndex(), info.GetNewIndex());
}

/******************************************************************************
 SwapElements

	Sends an ElementChanged message for each element.

 ******************************************************************************/

template <class T>
void
JArray<T>::SwapElements
	(
	const JIndex index1,
	const JIndex index2
	)
{
	assert( this->IndexValid(index1) );
	assert( this->IndexValid(index2) );

	if (index1 == index2)
		{
		return;
		}

	const T savedElement = ProtectedGetElement(index1);
	StoreElement(index1, ProtectedGetElement(index2));
	StoreElement(index2, savedElement);

	JBroadcaster::Broadcast(JListT::ElementsSwapped(index1, index2));
}

/******************************************************************************
 SwapElements

 ******************************************************************************/

template <class T>
void
JArray<T>::SwapElements
	(
	const JListT::ElementsSwapped& info
	)
{
	SwapElements(info.GetIndex1(), info.GetIndex2());
}

/******************************************************************************
 Sort (virtual)

	We minimize the number of moves (O(N)) because MoveElementToIndex()
	invokes JBroadcaster::Broadcast(), which can take arbitrary amounts of time.

	By using insertion sort to sort element k+1 into the already sorted
	list of k elements, we obtain O(N log N) comparisons.

	The number of moves is always O(N^2).

 ******************************************************************************/

template <class T>
void
JArray<T>::Sort()
{
	const JSize count = this->GetElementCount();
	if (count < 2)
		{
		return;
		}

	JBoolean isDuplicate;
	for (JIndex i=2; i<=count; i++)
		{
		const T& data = ProtectedGetElement(i);

		this->SetElementCount(i-1);		// safe because search doesn't modify data
		const JIndex j = GetInsertionSortIndex(data, &isDuplicate);
		this->SetElementCount(count);

		if (j != i)
			{
			MoveElementToIndex(i, j);
			}
		}
}

/******************************************************************************
 InsertSorted

	Returns kJTrue if the element was inserted.  Obviously, this is only
	useful if insertIfDuplicate==kJFalse.

	If index!=nullptr, it contains the index where the element was inserted.

 ******************************************************************************/

template <class T>
JBoolean
JArray<T>::InsertSorted
	(
	const T&		data,
	const JBoolean	insertIfDuplicate,
	JIndex*			index
	)
{
	JBoolean isDuplicate;
	const JIndex i = GetInsertionSortIndex(data, &isDuplicate);
	if (!isDuplicate || insertIfDuplicate)
		{
		InsertElementAtIndex(i, data);
		if (index != nullptr)
			{
			*index = i;
			}
		return kJTrue;
		}
	else
		{
		if (index != nullptr)
			{
			*index = 0;
			}
		return kJFalse;
		}
}

/******************************************************************************
 GetInsertionSortIndex

	Returns index where jnew element should be inserted in order to keep
	the list sorted.  If there is an element that matches the given one,
	*isDuplicate is set to kJTrue.

 ******************************************************************************/

template <class T>
JIndex
JArray<T>::GetInsertionSortIndex
	(
	const T&	data,
	JBoolean*	isDuplicate
	)
	const
{
	JBoolean found;
	JIndex index = SearchSorted1(data, JListT::kLastMatch, &found);
	if (found)
		{
		index++;
		}

	if (isDuplicate != nullptr)
		{
		*isDuplicate = found;
		}
	return index;
}

/******************************************************************************
 SearchSorted

	Returns kJTrue if the specified target is found.

	"which" specifies what to return if more than one element matches
	the given target.

 ******************************************************************************/

template <class T>
JBoolean
JArray<T>::SearchSorted
	(
	const T&							target,
	const JListT::SearchReturn	which,
	JIndex*								index
	)
	const
{
	JBoolean found;
	*index = SearchSorted1(target, which, &found);
	if (!found)
		{
		*index = 0;
		}
	return found;
}

/******************************************************************************
 SearchSorted1

	Returns index where the element is or where it should be inserted in
	order to keep the list sorted.  If there is an element that matches the
	given one, *found is set to kJTrue.

	Since lookup's in Arrays are O(1), we override this function to use a
	binary search, yielding O(log N) instead of the default O(N).

 ******************************************************************************/

template <class T>
JIndex
JArray<T>::SearchSorted1
	(
	const T&					target,
	const JListT::SearchReturn	which,
	JBoolean*					found
	)
	const
{
	const JElementComparison<T>* compareObj = nullptr;
	const JBoolean hasCompare = JList<T>::GetCompareObject(&compareObj);
	assert( hasCompare );

	const JListT::SortOrder sortOrder = JList<T>::GetSortOrder();
	*found = kJFalse;

	const JSize count = this->GetElementCount();
	if (count == 0)
		{
		return 1;
		}

	// check first element

	JListT::CompareResult r1;

	JIndex firstIndex = 1;
	{
	const T& element = ProtectedGetElement(firstIndex);
	r1 = compareObj->Compare(target, element);
	if (r1 == JListT::kFirstEqualSecond &&
		(count == 1 || which != JListT::kLastMatch))
		{
		*found = kJTrue;
		return 1;
		}
	else if ((sortOrder == JListT::kSortAscending &&
			  r1 == JListT::kFirstLessSecond) ||
			 (sortOrder == JListT::kSortDescending &&
			  r1 == JListT::kFirstGreaterSecond))
		{
		return 1;
		}
	else if (count == 1)
		{
		return 2;
		}
	}

	// check last element

	JListT::CompareResult r2;

	JIndex lastIndex = count;
	{
	const T& element = ProtectedGetElement(lastIndex);
	r2 = compareObj->Compare(target, element);
	if (r2 == JListT::kFirstEqualSecond &&
		(count == 2 || which != JListT::kFirstMatch))
		{
		*found = kJTrue;
		return count;
		}
	else if ((sortOrder == JListT::kSortAscending &&
			  r2 == JListT::kFirstGreaterSecond) ||
			 (sortOrder == JListT::kSortDescending &&
			  r2 == JListT::kFirstLessSecond))
		{
		return count+1;
		}
	}

	// assert for ascending:  first element <= data <= last element
	// assert for descending: first element >= data >= last element

	// squeeze out the appropriate position for data via binary search

	while (1)
		{
		// Thanks to Joshua Bloch at Google for pointing out that
		// (x+y)/2 doesn't work if x and y are larger than ULONG_MAX/2

		JIndex i         = (firstIndex >> 1) + (lastIndex >> 1) +
						   ((firstIndex & (JIndex) 1) + (lastIndex & (JIndex) 1))/2;
		const T& element = ProtectedGetElement(i);

		const JListT::CompareResult r = compareObj->Compare(target, element);
		if (r == JListT::kFirstEqualSecond)
			{
			if (which == JListT::kAnyMatch)
				{
				*found = kJTrue;
				return i;
				}
			else if (which == JListT::kFirstMatch)
				{
				lastIndex = i;
				r2        = r;
				}
			else	// which == JListT::kLastMatch
				{
				firstIndex = i;
				r1         = r;
				}
			}
		else if ((sortOrder == JListT::kSortAscending &&
				  r == JListT::kFirstLessSecond) ||
				 (sortOrder == JListT::kSortDescending &&
				  r == JListT::kFirstGreaterSecond))
			{
			lastIndex = i;
			r2        = r;
			}
		else	// the only other case
			{
			firstIndex = i;
			r1         = r;
			}

		assert( lastIndex >= firstIndex+1 );
		if (lastIndex == firstIndex+1)
			{
			if (which == JListT::kAnyMatch ||
				(r1 != JListT::kFirstEqualSecond &&
				 r2 != JListT::kFirstEqualSecond))
				{
				// Since we know that target is not equal to either of the
				// bounding elements, we can give up when there are no elements
				// between the bounds.

				return lastIndex;
				}

			// At this point, we know that we found a match.

			*found = kJTrue;
			if (which == JListT::kFirstMatch)
				{
				assert( r2 == JListT::kFirstEqualSecond );
				return lastIndex;
				}
			else	// which == JListT::kLastMatch
				{
				assert( which == JListT::kLastMatch &&
						r1 == JListT::kFirstEqualSecond );
				return firstIndex;
				}
			}
		}
}

/******************************************************************************
 QuickSort

	Calls qsort() and broadcasts JListT::Sorted afterwards.

	Since qsort() wants the sort order to be encoded in the comparison
	function, and since the comparison function prototype is different,
	we do -not- use the sorting information from JList.

	Do NOT use this for JPtrArrays:

	Downcasting or upcasting a pointer in C++ usually requires changing its
	value to include or exclude parts of the object data.  Casting from
	void* to a base class is therefore fatal because the compiler can't
	perform the adjustment.

 ******************************************************************************/

template <class T>
void
JArray<T>::QuickSort
	(
	int (*compare)(const void*, const void*)
	)
{
	::qsort(itsElements, this->GetElementCount(), sizeof(T), compare);
	JBroadcaster::Broadcast(JListT::Sorted());
}

/******************************************************************************
 GetElementPtr (private)

 ******************************************************************************/

template <class T>
T*
JArray<T>::GetElementPtr
	(
	const JIndex index
	)
{
	return &(itsElements[ index - 1 ]);
}

/******************************************************************************
 StoreElement (private)

	This is used by InsertElementAtIndex and SetElement.

 ******************************************************************************/

template <class T>
void
JArray<T>::StoreElement
	(
	const JIndex	index,
	const T&		data
	)
{
	itsElements[ index - 1 ] = data;
}

/******************************************************************************
 Block size

	itsBlockSize helps prevent constant reallocation of memory in a "noisy"
	environment.  Increase it if you need to add and remove a lot of elements
	without reallocating memory.  The larger it is, the more memory can
	potentially be wasted (allocated but not used).

 ******************************************************************************/

template <class T>
JSize
JArray<T>::GetBlockSize()
	const
{
	return itsBlockSize;
}

template <class T>
void
JArray<T>::SetBlockSize
	(
	const JSize newBlockSize
	)
{
	assert( newBlockSize > 0 );

	itsBlockSize = newBlockSize;
}

/******************************************************************************
 AddSlots (private)

	Grows the array by blockSize slots.

 ******************************************************************************/

template <class T>
void
JArray<T>::AddSlots()
{
	ResizeMemoryAllocation(itsSlotCount + itsBlockSize);
}

/******************************************************************************
 RemoveSlots (private)

	Shrinks the array by blockSize slots.

 ******************************************************************************/

template <class T>
void
JArray<T>::RemoveSlots()
{
	if (itsSlotCount > itsBlockSize)
		{
		ResizeMemoryAllocation(itsSlotCount - itsBlockSize);
		}
}

/******************************************************************************
 ResizeMemoryAllocation (private)

	Allocate the specified number of slots for itsElements.

******************************************************************************/

template <class T>
void
JArray<T>::ResizeMemoryAllocation
	(
	const JSize newSlotCount
	)
{
	assert( newSlotCount >= this->GetElementCount() );

	if (newSlotCount != itsSlotCount)
		{
		T* newElements = jnew T [newSlotCount];
		assert( newElements != nullptr );

		memcpy(newElements, itsElements, this->GetElementCount() * sizeof(T));

		jdelete [] itsElements;
		itsElements  = newElements;
		itsSlotCount = newSlotCount;
		}
}

/******************************************************************************
 NewIterator (virtual)

 ******************************************************************************/

template <class T>
JListIterator<T>*
JArray<T>::NewIterator
	(
	const JIteratorPosition	start,
	const JIndex			index
	)
{
	JArrayIterator<T>* iter = jnew JArrayIterator<T>(this, start, index);
	assert( iter != nullptr );
	return iter;
}

template <class T>
JListIterator<T>*
JArray<T>::NewIterator
	(
	const JIteratorPosition	start,
	const JIndex			index
	)
	const
{
	JArrayIterator<T>* iter = jnew JArrayIterator<T>(*this, start, index);
	assert( iter != nullptr );
	return iter;
}

/******************************************************************************
 Range-based for loop

 ******************************************************************************/

template <class T>
const T*
begin
	(
	const JArray<T>& a
	)
{
	return a.GetCArray();
}

template <class T>
const T*
end
	(
	const JArray<T>& a
	)
{
	return (a.GetCArray() + a.GetElementCount());
}

#endif
