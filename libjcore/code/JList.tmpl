#ifndef _T_JList
#define _T_JList

/******************************************************************************
 JList.tmpl

							The JList Template Class

	Abstract template for a dynamically sized list.

	This class provides the structure for the public interface of all
	objects that act like lists.

	BASE CLASS = JCollection

	Copyright (C) 1994-2018 by John Lindal.

 ******************************************************************************/

#include "jx-af/jcore/JList.h"
#include "jx-af/jcore/JListIterator.h"
#include "jx-af/jcore/jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JList<T>::JList()
	:
	JCollection()
{
	itsCompareFn     = nullptr;
	itsCompareObj    = nullptr;
	itsSortOrder     = JListT::kSortAscending;
	itsFirstIterator = nullptr;
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JList<T>::JList
	(
	const JList<T>& source
	)
	:
	JCollection(source)
{
	itsSortOrder  = source.itsSortOrder;
	itsCompareFn  = source.itsCompareFn;
	itsCompareObj = (source.itsCompareObj == nullptr ?
						(JElementComparison<T>*) nullptr :
						(source.itsCompareObj)->Copy());

	itsFirstIterator = nullptr;	// we don't copy the iterators
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JList<T>::~JList()
{
	NotifyIterators(JListT::GoingAway());
	jdelete itsCompareObj;
}

/******************************************************************************
 Assignment operator (private)

	*** Derived classes must call ListAssigned() -after- copying data

	operator= is private to force derived classes to override it

 ******************************************************************************/

template <class T>
const JList<T>&
JList<T>::operator=
	(
	const JList<T>& source
	)
{
	assert( 0 );
	return *this;
}

/******************************************************************************
 ListAssigned (protected)

 ******************************************************************************/

template <class T>
void
JList<T>::ListAssigned
	(
	const JList<T>& source
	)
{
	itsCompareFn  = source.itsCompareFn;
	itsCompareObj = (source.itsCompareObj == nullptr ? (JElementComparison<T>*) nullptr :
													(source.itsCompareObj)->Copy());
	itsSortOrder  = source.itsSortOrder;

	NotifyIterators(JListT::Copied());
}

/******************************************************************************
 NotifyIterators (protected)

 ******************************************************************************/

template <class T>
void
JList<T>::NotifyIterators
	(
	const JBroadcaster::Message& message
	)
{
	if (itsFirstIterator != nullptr)
	{
		itsFirstIterator->ListChanged(message);
	}
}

/******************************************************************************
 Compare function

 ******************************************************************************/

template <class T>
bool
JList<T>::GetCompareFunction
	(
	JListT::CompareResult (**compareFn)(const T&, const T&)
	)
	const
{
	*compareFn = itsCompareFn;
	return itsCompareFn != nullptr;
}

template <class T>
void
JList<T>::SetCompareFunction
	(
	JListT::CompareResult (*compareFn)(const T&, const T&)
	)
{
	itsCompareFn = compareFn;

	jdelete itsCompareObj;
	itsCompareObj = nullptr;

	if (itsCompareFn != nullptr)
	{
		itsCompareObj = jnew JCompareFnWrapper<T>(itsCompareFn);
		assert( itsCompareObj != nullptr );
	}
}

/******************************************************************************
 Compare object

 ******************************************************************************/

template <class T>
bool
JList<T>::GetCompareObject
	(
	const JElementComparison<T>** compareObj
	)
	const
{
	*compareObj = itsCompareObj;
	return itsCompareObj != nullptr;
}

template <class T>
void
JList<T>::SetCompareObject
	(
	const JElementComparison<T>& compareObj
	)
{
	itsCompareFn = nullptr;

	jdelete itsCompareObj;
	itsCompareObj = compareObj.Copy();
}

template <class T>
void
JList<T>::ClearCompareObject()
{
	itsCompareFn = nullptr;

	jdelete itsCompareObj;
	itsCompareObj = nullptr;
}

/******************************************************************************
 Sort order

 ******************************************************************************/

template <class T>
JListT::SortOrder
JList<T>::GetSortOrder()
	const
{
	return itsSortOrder;
}

template <class T>
void
JList<T>::SetSortOrder
	(
	const JListT::SortOrder order
	)
{
	itsSortOrder = order;
}

/******************************************************************************
 IsSorted

	Lookup's in LinkedLists and RunArrays are O(N).  We eliminate this
	by using an iterator.

 ******************************************************************************/

template <class T>
bool
JList<T>::IsSorted()
	const
{
	assert( itsCompareObj != nullptr );

	const JSize count = GetElementCount();
	if (count < 2)
	{
		return true;		// avoid constructing iterator
	}

	// check if the elements are sorted

	bool sorted = true;

	JListIterator<T>* iter = NewIterator();	// allows optimized iterator
	T obj1, obj2;

	bool ok = iter->Next(&obj1);
	assert( ok );

	while (iter->Next(&obj2))
	{
		const JListT::CompareResult r = itsCompareObj->Compare(obj1, obj2);
		if ((itsSortOrder == JListT::kSortAscending &&
			 r == JListT::kFirstGreaterSecond) ||
			(itsSortOrder == JListT::kSortDescending &&
			 r == JListT::kFirstLessSecond))
		{
			sorted = false;
			break;
		}
		obj1 = obj2;
	}

	jdelete iter;
	return sorted;
}

/******************************************************************************
 JElementComparison class

 ******************************************************************************/

template <class T>
JElementComparison<T>::~JElementComparison()
{
}

/******************************************************************************
 JCompareFnWrapper class

 ******************************************************************************/

template <class T>
JCompareFnWrapper<T>::JCompareFnWrapper
	(
	JListT::CompareResult (*compareFn)(const T&, const T&)
	)
	:
	itsCompareFn(compareFn)
{
}

template <class T>
JCompareFnWrapper<T>::~JCompareFnWrapper()
{
}

template <class T>
JListT::CompareResult
JCompareFnWrapper<T>::Compare
	(
	const T& t1,
	const T& t2
	)
	const
{
	return itsCompareFn(t1, t2);
}

template <class T>
JElementComparison<T>*
JCompareFnWrapper<T>::Copy()
	const
{
	JCompareFnWrapper<T>* copy = jnew JCompareFnWrapper<T>(itsCompareFn);
	assert( copy != nullptr );
	return copy;
}

#endif
