#ifndef _T_JPtrArrayIterator
#define _T_JPtrArrayIterator

/******************************************************************************
 JPtrArrayIterator.tmpl

						The Pointer Array Iterator Class

	Provides a consistent interface for iterating over a JPtrArray.

	Refer to JListIterator.tmpl for information about interators in general.

	Copyright (C) 1994-97 by John Lindal.

 ******************************************************************************/

#include <JPtrArray.h>
#include <jAssert.h>

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JPtrArrayIterator<T>::JPtrArrayIterator
	(
	const JPtrArray<T>&		theArray,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T*>(theArray, start, index)
{
}

template <class T>
JPtrArrayIterator<T>::JPtrArrayIterator
	(
	JPtrArray<T>*			theArray,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T*>(theArray, start, index)
{
}

/******************************************************************************
 SetPrev

	Returns kJTrue if we have a non-const JPtrArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JPtrArrayIterator<T>::SetPrev
	(
	T*									dataPtr,
	const JPtrArrayT::SetElementAction	action
	)
{
	JList<T*>* obj;
	if (!JPtrArrayIterator<T>::GetOrderedSet(&obj) || JListIterator<T*>::AtBeginning())
		{
		return kJFalse;
		}

	JPtrArray<T>* ptr = dynamic_cast<JPtrArray<T>*>(obj);
	assert( ptr != NULL );

	ptr->SetElement(JListIterator<T*>::GetCursor(), dataPtr, action);
	return kJTrue;
}

/******************************************************************************
 SetNext

	Returns kJTrue if we have a non-const JPtrArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JPtrArrayIterator<T>::SetNext
	(
	T*									dataPtr,
	const JPtrArrayT::SetElementAction	action
	)
{
	JList<T*>* obj;
	if (!JPtrArrayIterator<T>::GetOrderedSet(&obj) || JListIterator<T*>::AtEnd())
		{
		return kJFalse;
		}

	JPtrArray<T>* ptr = dynamic_cast<JPtrArray<T>*>(obj);
	assert( ptr != NULL );

	ptr->SetElement(JListIterator<T*>::GetCursor()+1, dataPtr, action);
	return kJTrue;
}

/******************************************************************************
 DeletePrev

	Returns kJTrue if we have a non-const JPtrArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JPtrArrayIterator<T>::DeletePrev()
{
	JList<T*>* obj;
	if (!JPtrArrayIterator<T>::GetOrderedSet(&obj) || JListIterator<T*>::AtBeginning())
		{
		return kJFalse;
		}

	JPtrArray<T>* ptr = dynamic_cast<JPtrArray<T>*>(obj);
	assert( ptr != NULL );

	ptr->DeleteElement(JListIterator<T*>::GetCursor());
	return kJTrue;
}

/******************************************************************************
 DeleteNext

	Returns kJTrue if we have a non-const JPtrArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JPtrArrayIterator<T>::DeleteNext()
{
	JList<T*>* obj;
	if (!JPtrArrayIterator<T>::GetOrderedSet(&obj) || JListIterator<T*>::AtEnd())
		{
		return kJFalse;
		}

	JPtrArray<T>* ptr = dynamic_cast<JPtrArray<T>*>(obj);
	assert( ptr != NULL );

	ptr->DeleteElement(JListIterator<T*>::GetCursor()+1);
	return kJTrue;
}

/******************************************************************************
 DeletePrevAsArray

	Returns kJTrue if we have a non-const JPtrArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JPtrArrayIterator<T>::DeletePrevAsArray()
{
	JList<T*>* obj;
	if (!JPtrArrayIterator<T>::GetOrderedSet(&obj) || JListIterator<T*>::AtBeginning())
		{
		return kJFalse;
		}

	JPtrArray<T>* ptr = dynamic_cast<JPtrArray<T>*>(obj);
	assert( ptr != NULL );

	ptr->DeleteElementAsArray(JListIterator<T*>::GetCursor());
	return kJTrue;
}

/******************************************************************************
 DeleteNextAsArray

	Returns kJTrue if we have a non-const JPtrArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JPtrArrayIterator<T>::DeleteNextAsArray()
{
	JList<T*>* obj;
	if (!JPtrArrayIterator<T>::GetOrderedSet(&obj) || JListIterator<T*>::AtEnd())
		{
		return kJFalse;
		}

	JPtrArray<T>* ptr = dynamic_cast<JPtrArray<T>*>(obj);
	assert( ptr != NULL );

	ptr->DeleteElementAsArray(JListIterator<T*>::GetCursor()+1);
	return kJTrue;
}

#endif
