#ifndef _T_JLinkedList
#define _T_JLinkedList

/******************************************************************************
 JLinkedList.tmpl

							The JLinkedList Template Class

	Template for a dynamically sized linked list.

	Since the actual data is stored, this is only good for structs.
	To store objects, use the JPtrArray template class.

	BASE CLASS = JList

	Copyright (C) 1994-2018 by John Lindal.

 ******************************************************************************/

#include "JLinkedList.h"
#include "JMinMax.h"
#include "jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JLinkedList<T>::JLinkedList()
	:
	JList<T>()
{
	itsFirstElement = nullptr;
	itsLastElement  = nullptr;
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JLinkedList<T>::JLinkedList
	(
	const JLinkedList<T>& source
	)
	:
	JList<T>(source)
{
	itsFirstElement = nullptr;
	itsLastElement  = nullptr;
	CopyList(source);
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JLinkedList<T>::~JLinkedList()
{
	DeleteAll();
}

/******************************************************************************
 Assignment operator

 ******************************************************************************/

template <class T>
JLinkedList<T>&
JLinkedList<T>::operator=
	(
	const JLinkedList<T>& source
	)
{
	if (this == &source)
	{
		return *this;
	}

	DeleteAll();

	JCollection::operator=(source);		// JList::operator= is private

	CopyList(source);
	JLinkedList<T>::ListAssigned(source);

	return *this;
}

/******************************************************************************
 CopyList (private)

	Copies the list data from source.

	*** Caller must make sure *this is empty.

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::CopyList
	(
	const JLinkedList<T>& source
	)
{
	assert( itsFirstElement == nullptr );
	assert( itsLastElement  == nullptr );

	JLinkedListElement<T>* sourceElement = source.itsFirstElement;
	JLinkedListElement<T>* prev = nullptr;
	JLinkedListElement<T>* newElement;

	while (sourceElement != nullptr)
	{
		newElement = jnew JLinkedListElement<T>(sourceElement->data);
		assert( newElement != nullptr );

		newElement->prev = prev;			// link to previous element
		newElement->next = nullptr;			// no initial link

		if (prev != nullptr)
		{
			prev->next = newElement;		// set up link from previous element
		}
		else
		{
			itsFirstElement = newElement;	// save link to first element
		}

		sourceElement = sourceElement->next;
		prev          = newElement;
	}

	itsLastElement = prev;					// save link to last element
}

/******************************************************************************
 GetFirstElement (virtual)

 ******************************************************************************/

template <class T>
T
JLinkedList<T>::GetFirstElement()
	const
{
	assert( itsFirstElement != nullptr );
	return itsFirstElement->data;
}

/******************************************************************************
 GetLastElement (virtual)

 ******************************************************************************/

template <class T>
T
JLinkedList<T>::GetLastElement()
	const
{
	assert( itsLastElement != nullptr );
	return itsLastElement->data;
}

/******************************************************************************
 PrependElement (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::PrependElement
	(
	const T& data
	)
{
	JLinkedListElement<T>* newElement = jnew JLinkedListElement<T>(data);
	assert( newElement != nullptr );

	newElement->prev = nullptr;
	newElement->next = itsFirstElement;

	if (itsFirstElement != nullptr)
	{
		itsFirstElement->prev = newElement;
	}
	else
	{
		itsLastElement = newElement;
	}
	itsFirstElement = newElement;

	this->ElementAdded();

	JListT::ElementsInserted message(1, 1);
	JBroadcaster::Broadcast(message);
	JList<T>::NotifyIterators(message);
}

/******************************************************************************
 AppendElement (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::AppendElement
	(
	const T& data
	)
{
	JLinkedListElement<T>* newElement = jnew JLinkedListElement<T>(data);
	assert( newElement != nullptr );

	newElement->prev = itsLastElement;
	newElement->next = nullptr;

	if (itsLastElement != nullptr)
	{
		itsLastElement->next = newElement;
	}
	else
	{
		itsFirstElement = newElement;
	}
	itsLastElement = newElement;

	this->ElementAdded();

	JListT::ElementsInserted message(this->GetElementCount(), 1);
	JBroadcaster::Broadcast(message);
	JList<T>::NotifyIterators(message);
}

/******************************************************************************
 RemoveAll (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::RemoveAll()
{
	if (!this->IsEmpty())
	{
		JListT::ElementsRemoved message(1, this->GetElementCount());

		DeleteAll();

		JBroadcaster::Broadcast(message);
		JList<T>::NotifyIterators(message);
	}
}

/******************************************************************************
 DeleteAll (private)

	Delete all the elements in the list.

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::DeleteAll()
{
	DeleteChain(itsFirstElement);

	itsFirstElement = nullptr;
	itsLastElement  = nullptr;
	this->SetElementCount(0);
}

/******************************************************************************
 DeleteChain (private)

	Delete the chain of elements that starts with the given element.

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::DeleteChain
	(
	JLinkedListElement<T>* firstElement
	)
{
	while (firstElement != nullptr)
	{
		JLinkedListElement<T>* next = firstElement->next;
		jdelete firstElement;
		firstElement = next;
	}
}

/******************************************************************************
 IteratorInsertElementAfter (private)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::IteratorInsertElementAfter
	(
	const JIndex			index,
	const T&				data,
	JLinkedListElement<T>*	prev
	)
{
	JLinkedListElement<T>* next = prev->next;

	JLinkedListElement<T>* newElement = jnew JLinkedListElement<T>(data);
	assert( newElement != nullptr );

	newElement->prev = prev;
	newElement->next = next;

	prev->next = newElement;
	if (next != nullptr)
	{
		next->prev = newElement;
	}
	else
	{
		itsLastElement = newElement;
	}

	this->ElementAdded();

	JListT::ElementsInserted message(index+1, 1);
	JBroadcaster::Broadcast(message);
	JList<T>::NotifyIterators(message);
}

/******************************************************************************
 IteratorRemovePrevElements (private)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::IteratorRemovePrevElements
	(
	const JIndex			lastIndex,
	const JSize				origCount,
	JLinkedListElement<T>*	origElement
	)
{
	const JSize totalCount = this->GetElementCount();
	if (lastIndex == totalCount && origCount >= totalCount)
	{
		RemoveAll();
	}
	else if (origCount > 0)
	{
		JIndex firstIndex = lastIndex;
		JSize count       = 1;
		while (origElement->prev != nullptr && count < origCount)
		{
			origElement = origElement->prev;
			firstIndex--;
			count++;
		}

		DeleteChain(UnlinkNextElements(firstIndex, count, origElement));

		JListT::ElementsRemoved message(firstIndex, count);
		JBroadcaster::Broadcast(message);
		JList<T>::NotifyIterators(message);
	}
}

/******************************************************************************
 IteratorRemoveNextElements (private)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::IteratorRemoveNextElements
	(
	const JIndex			firstIndex,
	const JSize				count,
	JLinkedListElement<T>*	origElement
	)
{
	if (firstIndex == 1 && count >= this->GetElementCount())
	{
		RemoveAll();
	}
	else if (count > 0)
	{
		DeleteChain(UnlinkNextElements(firstIndex, count, origElement));

		JListT::ElementsRemoved message(firstIndex, count);
		JBroadcaster::Broadcast(message);
		JList<T>::NotifyIterators(message);
	}
}

/******************************************************************************
 IteratorSetElement (private)

 ******************************************************************************/

template <class T>
void
JLinkedList<T>::IteratorSetElement
	(
	const JIndex			index,
	const T&				data,
	JLinkedListElement<T>*	listElement
	)
{
	listElement->data = data;
	JBroadcaster::Broadcast(JListT::ElementsChanged(index, 1));
}

/******************************************************************************
 UnlinkNextElements (private)

	Unlink the specified elements from the list and return the first one.

	If origElement != nullptr, it is assumed to be the first element to remove.

 ******************************************************************************/

template <class T>
JLinkedListElement<T>*
JLinkedList<T>::UnlinkNextElements
	(
	const JIndex			firstIndex,
	const JSize				origCount,
	JLinkedListElement<T>*	origElement
	)
{
	assert( this->IndexValid(firstIndex) );

	const JSize elementCount = this->GetElementCount(),
				lastIndex    = JMin(elementCount, firstIndex + origCount-1),
				count        = lastIndex - firstIndex + 1;

	JLinkedListElement<T>* result = nullptr;

	if (count == elementCount)
	{
		result          = itsFirstElement;
		itsFirstElement = nullptr;
		itsLastElement  = nullptr;
	}
	else if (firstIndex == 1)
	{
		result = itsFirstElement;
		for (JIndex i=1; i<=count; i++)
		{
			itsFirstElement = itsFirstElement->next;
		}
		itsFirstElement->prev->next = nullptr;
		itsFirstElement->prev       = nullptr;
	}
	else if (lastIndex == elementCount)
	{
		for (JIndex i=1; i<=count; i++)
		{
			itsLastElement = itsLastElement->prev;
		}
		result               = itsLastElement->next;
		result->prev         = nullptr;
		itsLastElement->next = nullptr;
	}
	else
	{
		JLinkedListElement<T>* prev       = origElement->prev;
		JLinkedListElement<T>* theElement = prev->next;

		result       = theElement;
		result->prev = nullptr;

		for (JIndex i=1; i<=count; i++)
		{
			theElement = theElement->next;
		}
		(theElement->prev)->next = nullptr;

		prev->next       = theElement;
		theElement->prev = prev;
	}

	this->SetElementCount(elementCount - count);

	return result;
}

/******************************************************************************
 IteratorFindElement (private)

 ******************************************************************************/

template <class T>
JLinkedListElement<T>*
JLinkedList<T>::IteratorFindElement
	(
	const JIndex index
	)
	const
{
	assert( this->IndexValid(index) );

	const JSize elementCount = this->GetElementCount();
	if (index < elementCount/2)
	{
		JLinkedListElement<T>* listElement = itsFirstElement;

		// traverse the list forward
		// when i == index, we have found the element

		for (JIndex i=1; i<index; i++)
		{
			listElement = listElement->next;
		}

		return listElement;
	}
	else
	{
		JLinkedListElement<T>* listElement = itsLastElement;

		// traverse the list backward
		// when i == index, we have found the element

		for (JIndex i=elementCount; i>index; i--)
		{
			listElement = listElement->prev;
		}

		return listElement;
	}
}

/******************************************************************************
 NewIterator (virtual)

 ******************************************************************************/

template <class T>
JListIterator<T>*
JLinkedList<T>::NewIterator
	(
	const JListT::Position	start,
	const JIndex			index
	)
{
	JLinkedListIterator<T>* iter = jnew JLinkedListIterator<T>(this, start, index);
	assert( iter != nullptr );
	return iter;
}

template <class T>
JListIterator<T>*
JLinkedList<T>::NewIterator
	(
	const JListT::Position	start,
	const JIndex			index
	)
	const
{
	JLinkedListIterator<T>* iter = jnew JLinkedListIterator<T>(*this, start, index);
	assert( iter != nullptr );
	return iter;
}

/******************************************************************************
 Range-based for loop

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>
begin
	(
	const JLinkedList<T>& list
	)
{
	return JLinkedListIterator<T>(list, JListT::kStartAtBeginning);
}

template <class T>
JLinkedListIterator<T>
end
	(
	const JLinkedList<T>& list
	)
{
	return JLinkedListIterator<T>(list, JListT::kStartAtEnd);
}

#endif
