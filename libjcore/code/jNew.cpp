/******************************************************************************
 jNew.cpp

	Defines the JCore operator new, JNew.  JNew provides many memory
	management features that the built-in allocator does not, principally
	for detection of memory leaks.

	Copyright (C) 1997 by Dustin Laurence.
	
	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include "JMemoryManager.h"

// Module header
#include "jNew.h"

/******************************************************************************
 operator new

 *****************************************************************************/

void*
operator new
	(
	size_t size
	)
{
	return operator new(size, JMemoryManager::kUnknownFile, 0, JMMRecord::kLibrary, false);
}

void*
operator new
	(
	size_t					size,
	const std::nothrow_t&	nothrow_value
	)
	noexcept
{
	return operator new(size, JMemoryManager::kUnknownFile, 0, JMMRecord::kLibrary, false);
}

/******************************************************************************
 placement operator new

 *****************************************************************************/

void*
operator new
	(
	size_t           size,
	const JUtf8Byte* file,
	const JUInt32    line,
	const int        type,
	const bool       assert
	)
	noexcept
{
	return JMemoryManager::New(size, file, line, type, false, assert);
}

/******************************************************************************
 operator new[]

 *****************************************************************************/

void*
operator new[]
	(
	size_t size
	)
{
	return operator new[](size, JMemoryManager::kUnknownFile, 0, JMMRecord::kLibrary, false);
}

void*
operator new[]
	(
	size_t					size,
	const std::nothrow_t&	nothrow_value
	)
	noexcept
{
	return operator new[](size, JMemoryManager::kUnknownFile, 0, JMMRecord::kLibrary, false);
}

/******************************************************************************
 placement operator new[]

 *****************************************************************************/

void*
operator new[]
	(
	size_t           size,
	const JUtf8Byte* file,
	const JUInt32    line,
	const int        type,
	const bool       assert
	)
	noexcept
{
	return JMemoryManager::New(size, file, line, type, true, assert);
}

/******************************************************************************
 operator delete

 *****************************************************************************/

void
operator delete
	(
	void* memory
	)
	noexcept
{
	JMemoryManager::Instance()->Delete(memory, false);
}

void
operator delete
	(
	void*		memory,
	std::size_t	size
	)
	noexcept
{
	JMemoryManager::Instance()->Delete(memory, false);
}

void
operator delete
	(
	void*					memory,
	const std::nothrow_t&	nothrow_value
	)
	noexcept
{
	JMemoryManager::Instance()->Delete(memory, false);
}

/******************************************************************************
 operator delete[]

 *****************************************************************************/

void
operator delete[]
	(
	void* memory
	)
	noexcept
{
	JMemoryManager::Instance()->Delete(memory, true);
}

void
operator delete[]
	(
	void*		memory,
	std::size_t	size
	)
	noexcept
{
	JMemoryManager::Instance()->Delete(memory, true);
}

void
operator delete[]
	(
	void*					memory,
	const std::nothrow_t&	nothrow_value
	)
	noexcept
{
	JMemoryManager::Instance()->Delete(memory, true);
}

/******************************************************************************
 JLocateDelete

 *****************************************************************************/

void
JLocateDelete
	(
	const JUtf8Byte* file,
	const JUInt32    line
	)
{
	JMemoryManager::LocateDelete(file, line);
}
