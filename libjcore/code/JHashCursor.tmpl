#ifndef _T_JHashCursor
#define _T_JHashCursor

/******************************************************************************
 JHashCursor.tmpl

	A hash table cursor which can modify its table.

	Set automatically resizes the table.

	BASE CLASS = JConstHashCursor

	Copyright © 1997 by Dustin Laurence.  All rights reserved.
	
	Base code generated by Codemill v0.1.0

 *****************************************************************************/

//Class Header
#include <JHashCursor.h>

#include <jAssert.h>

/******************************************************************************
 Constructor

	The version without a hash value or key parameter iterates through the
	entire table, obviously in no perceptible order.  The others iterate over
	all records containing the given hash value.

 *****************************************************************************/

template <class V>
JHashCursor<V>::JHashCursor
	(
	JHashTable<V>* table
	)
	:
	JConstHashCursor<V>(table)
{
	// JAFL 7/12/98: we check this here so JConstHashCursors are always allowed
	assert(JConstHashCursor<V>::GetTable()->itsAllowCursorFlag);
}

template <class V>
JHashCursor<V>::JHashCursor
	(
	JHashTable<V>* table,
	const JHashValue hash
	)
	:
	JConstHashCursor<V>(table, hash)
{
	// JAFL 7/12/98: we check this here so JConstHashCursors are always allowed
	assert(JConstHashCursor<V>::GetTable()->itsAllowCursorFlag);
}

#if 0
template <class V>
JHashCursor<V>::JHashCursor
	(
	JHashTable<V>* table,
	const K* const key
	)
	:
	JConstHashCursor<V>(table, key)
{
	// JAFL 7/12/98: we check this here so JConstHashCursors are always allowed
	assert(GetTable()->itsAllowCursorFlag);
}
#endif

/******************************************************************************
 Destructor

 *****************************************************************************/

template <class V>
JHashCursor<V>::~JHashCursor()
{
}

/******************************************************************************
 copy constructor and assignment operator (default versions)

	See notes in JConstHashCursor.

 *****************************************************************************/

/******************************************************************************
 ForceNextOpen

	Like NextOpen(), but if no open space is found it resets, grows the table,
	and then finds an open space.  Since it always finds an open space, it
	has no return value.  Because it can resize a table, it asserts that you
	haven't used it on a table with the resize flag off.

	It can safely be called on a cursor which has already been advanced with
	one of the Next... functions if you know what you're doing, but be careful.

 *****************************************************************************/

template <class V>
void
JHashCursor<V>::ForceNextOpen()
{
	assert(JConstHashCursor<V>::GetTable()->itsResizeFlag);

	if (!JConstHashCursor<V>::NextOpen())
		{
		GetMutableTable()->FitToLimits(1);
		JConstHashCursor<V>::Reset();
		const JBoolean foundOpen = JConstHashCursor<V>::NextOpen();
		assert(foundOpen); // Should *never* require more than one resize
		}
}

/******************************************************************************
 ForceNextMapInsertHash

	Like NextMapInsertHash(), but if no open space is found it resets, grows the
	table, and then tries again.  Because it can resize a table, it asserts that
	you haven't used it on a table with the resize flag off.

	It can safely be called on a cursor which has already been advanced with
	one of the Next... functions if you know what you're doing, but be careful.

 *****************************************************************************/

template <class V>
void
JHashCursor<V>::ForceNextMapInsertHash()
{
	assert( JConstHashCursor<V>::GetTable()->itsResizeFlag );

	if (!JConstHashCursor<V>::NextMapInsertHash())
		{
		GetMutableTable()->FitToLimits(1);
		JConstHashCursor<V>::Reset();
		const JBoolean foundOpen = JConstHashCursor<V>::NextMapInsertHash();
		assert(foundOpen); // Should *never* require more than one resize
		}
}

/******************************************************************************
 ForceNextMapInsertKey

	Like NextMapInsertKey(), but if no open space is found it resets, grows the
	table, and then tries again.  Because it can resize a table, it asserts that
	you haven't used it on a table with the resize flag off.

	It can safely be called on a cursor which has already been advanced with
	one of the Next... functions if you know what you're doing, but be careful.

 *****************************************************************************/

template <class V>
void
JHashCursor<V>::ForceNextMapInsertKey()
{
	assert( JConstHashCursor<V>::GetTable()->itsResizeFlag );

	if (!JConstHashCursor<V>::NextMapInsertKey())
		{
		GetMutableTable()->FitToLimits(1);
		JConstHashCursor<V>::Reset();
		const JBoolean foundOpen = JConstHashCursor<V>::NextMapInsertKey();
		assert(foundOpen); // Should *never* require more than one resize
		}
}

#endif

// Instantiate the template for the specified type.

#if defined JTemplateType && ! defined JOnlyWantTemplateDefinition
	#define JTemplateName JHashCursor
	#include <instantiate_template.h>
	#undef JTemplateName
#endif
