#ifndef _T_JLinkedListIterator
#define _T_JLinkedListIterator

/******************************************************************************
 JLinkedListIterator.tmpl

	Efficient interation for JLinkedList objects.

	Copyright (C) 1996-2018 by John Lindal.

 ******************************************************************************/

#include "JLinkedListIterator.h"
#include "JLinkedList.h"
#include "jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>::JLinkedListIterator
	(
	const JLinkedList<T>&	theLinkedList,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theLinkedList, start, index),
	itsIgnoreListChangedFlag(kJFalse)
{
	itsLinkedList  = const_cast<JLinkedList<T>*>(&theLinkedList);
	itsCurrElement = itsLinkedList->itsFirstElement;

	// initialize instance variables -- our override not called by base class

	PrivateMoveTo();
}

template <class T>
JLinkedListIterator<T>::JLinkedListIterator
	(
	JLinkedList<T>*			theLinkedList,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theLinkedList, start, index),
	itsIgnoreListChangedFlag(kJFalse)
{
	itsLinkedList  = theLinkedList;
	itsCurrElement = itsLinkedList->itsFirstElement;

	// initialize instance variables -- our override not called by base class

	PrivateMoveTo();
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>::JLinkedListIterator
	(
	const JLinkedListIterator<T>& source
	)
	:
	JListIterator<T>(source),
	itsIgnoreListChangedFlag(kJFalse)
{
	itsLinkedList  = source.itsLinkedList;
	itsCurrElement = source.itsCurrElement;
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>::~JLinkedListIterator()
{
}

/******************************************************************************
 Prev (virtual)

	Return kJTrue if there is a previous item, fetching the previous
	item in the list and decrementing the iterator position.
	Otherwise return kJFalse without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::Prev
	(
	T* item
	)
{
	if (itsLinkedList == nullptr || this->AtBeginning())
		{
		return kJFalse;
		}

	*item = itsCurrElement->data;

	const JCursorPosition cursorPos = this->GetCursor();
	if (cursorPos > 1)
		{
		itsCurrElement = itsCurrElement->prev;
		}

	this->SetCursor(cursorPos-1);
	return kJTrue;
}

/******************************************************************************
 Next (virtual)

	Return kJTrue if there is a next item, fetching the next
	item in the list and decrementing the iterator position.
	Otherwise return kJFalse without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::Next
	(
	T* item
	)
{
	if (itsLinkedList == nullptr || this->AtEnd())
		{
		return kJFalse;
		}

	const JCursorPosition cursorPos = this->GetCursor();
	if (cursorPos > 0)
		{
		itsCurrElement = itsCurrElement->next;
		}

	*item = itsCurrElement->data;
	this->SetCursor(cursorPos+1);
	return kJTrue;
}

/******************************************************************************
 SkipPrev (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::SkipPrev
	(
	const JSize count
	)
{
	if (itsLinkedList != nullptr && !this->AtBeginning())
		{
		JCursorPosition cursorPos = this->GetCursor();

		JSize remaining = count;
		while (remaining > 0 && cursorPos > 0)
			{
			if (cursorPos > 1)
				{
				itsCurrElement = itsCurrElement->prev;
				}
			cursorPos--;
			remaining--;
			}

		this->SetCursor(cursorPos);
		}
}

/******************************************************************************
 SkipNext (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::SkipNext
	(
	const JSize count
	)
{
	if (itsLinkedList != nullptr && !this->AtEnd())
		{
		JCursorPosition cursorPos = this->GetCursor();
		const JSize maxPos        = itsLinkedList->GetElementCount();

		JSize remaining = count;
		while (remaining > 0 && cursorPos < maxPos)
			{
			if (cursorPos > 0)
				{
				itsCurrElement = itsCurrElement->next;
				}
			cursorPos++;
			remaining--;
			}

		this->SetCursor(cursorPos);
		}
}

/******************************************************************************
 SetPrev (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::SetPrev
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	itsLinkedList->IteratorSetElement(this->GetCursor(), data, itsCurrElement);
	return kJTrue;
}

/******************************************************************************
 SetNext (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::SetNext
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtEnd())
		{
		return kJFalse;
		}

	assert( itsCurrElement->next != nullptr );

	itsLinkedList->IteratorSetElement(this->GetCursor()+1, data, itsCurrElement->next);
	return kJTrue;
}

/******************************************************************************
 RemovePrev (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is at least one previous item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::RemovePrev
	(
	const JSize count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	JLinkedListElement<T>* e = itsCurrElement->next;

	itsIgnoreListChangedFlag = kJTrue;
	itsLinkedList->IteratorRemovePrevElements(this->GetCursor(), count, itsCurrElement);
	itsIgnoreListChangedFlag = kJFalse;

	if (this->AtBeginning())
		{
		itsCurrElement = itsLinkedList->itsFirstElement;
		}
	else if (e == nullptr)
		{
		itsCurrElement = itsLinkedList->itsLastElement;
		}
	else
		{
		itsCurrElement = e->prev;
		}

	return kJTrue;
}

/******************************************************************************
 RemoveNext (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is at least one next item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::RemoveNext
	(
	const JSize count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtEnd())
		{
		return kJFalse;
		}

	itsIgnoreListChangedFlag = kJTrue;
	itsLinkedList->IteratorRemoveNextElements(this->GetCursor()+1, count,
											  itsCurrElement->next);
	itsIgnoreListChangedFlag = kJFalse;

	return kJTrue;
}

/******************************************************************************
 Insert (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>*.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::Insert
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj))
		{
		return kJFalse;
		}

	if (this->AtBeginning())
		{
		itsIgnoreListChangedFlag = kJTrue;
		itsLinkedList->PrependElement(data);
		itsIgnoreListChangedFlag = kJFalse;

		itsCurrElement = itsLinkedList->itsFirstElement;
		}
	else
		{
		itsIgnoreListChangedFlag = kJTrue;
		itsLinkedList->IteratorInsertElementAfter(this->GetCursor(), data, itsCurrElement);
		itsIgnoreListChangedFlag = kJFalse;
		}
	return kJTrue;
}

/******************************************************************************
 MoveTo (virtual)

	Reset the iterator position to one of:
		kJIteratorStartAtBeginning, kJIteratorStartAtEnd,
		kJIteratorStartBefore(index), or kJIteratorStartAfter(index)

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::MoveTo
	(
	const JIteratorPosition	newPosition,
	const JIndex			index
	)
{
	const JCursorPosition origPosition = this->GetCursor();

	JListIterator<T>::MoveTo(newPosition, index);

	const JCursorPosition cursorPosition = this->GetCursor();
	if (itsLinkedList != nullptr && cursorPosition != origPosition)
		{
		PrivateMoveTo();
		}
}

template <class T>
void
JLinkedListIterator<T>::PrivateMoveTo()
{
	if (this->AtBeginning())
		{
		itsCurrElement = itsLinkedList->itsFirstElement;
		}
	else if (this->AtEnd())
		{
		itsCurrElement = itsLinkedList->itsLastElement;
		}
	else
		{
		itsCurrElement = itsLinkedList->IteratorFindElement(this->GetCursor());
		}
}

/******************************************************************************
 ListChanged (virtual protected)

	Respond to changes in itsLinkedList.  In order to optimize, we would have
	to check if prev or next was invalid.

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::ListChanged
	(
	const JBroadcaster::Message& message
	)
{
	JListIterator<T>::ListChanged(message);

	if (!itsIgnoreListChangedFlag &&
		(message.Is(JListT::kElementsInserted) ||
		 message.Is(JListT::kElementsRemoved)))
		{
		PrivateMoveTo();
		}
	else if (message.Is(JListT::kCopied))
		{
		PrivateMoveTo();
		}
	else if (message.Is(JListT::kGoingAway))
		{
		itsLinkedList  = nullptr;
		itsCurrElement = nullptr;
		}
}

#endif
