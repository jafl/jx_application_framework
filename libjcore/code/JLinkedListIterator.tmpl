#ifndef _T_JLinkedListIterator
#define _T_JLinkedListIterator

/******************************************************************************
 JLinkedListIterator.tmpl

	Efficient interation for JLinkedList objects.

	To do:
		Optimize ListChanged() so it doesn't always call FindElement().

	Copyright (C) 1996-97 by John Lindal.

 ******************************************************************************/

#include <JLinkedListIterator.h>
#include <JLinkedList.h>
#include <jAssert.h>

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>::JLinkedListIterator
	(
	const JLinkedList<T>&	theLinkedList,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theLinkedList, start, index)
{
	itsLinkedList = const_cast<JLinkedList<T>*>(&theLinkedList);

	// initialize instance variables -- our override not called by base class

	MoveTo(start, index);
}

template <class T>
JLinkedListIterator<T>::JLinkedListIterator
	(
	JLinkedList<T>*			theLinkedList,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theLinkedList, start, index)
{
	itsLinkedList = theLinkedList;

	// initialize instance variables -- our override not called by base class

	MoveTo(start, index);
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>::JLinkedListIterator
	(
	const JLinkedListIterator<T>& source
	)
	:
	JListIterator<T>(source)
{
	itsLinkedList  = source.itsLinkedList;
	itsCurrElement = source.itsCurrElement;
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JLinkedListIterator<T>::~JLinkedListIterator()
{
}

/******************************************************************************
 Assignment operator (private)

	operator= is private because it is not allowed

 ******************************************************************************/

template <class T>
const JLinkedListIterator<T>&
JLinkedListIterator<T>::operator=
	(
	const JLinkedListIterator<T>& source
	)
{
	assert( 0 );
	return *this;
}

/******************************************************************************
 Prev (virtual)

	Return kJTrue if there is a previous item, fetching the previous
	item in the list and decrementing the iterator position.
	Otherwise return kJFalse without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::Prev
	(
	T* item
	)
{
	const JCursorPosition cursorPos = JListIterator<T>::GetCursor();
	if (itsLinkedList == nullptr || cursorPos == 0)
		{
		return kJFalse;
		}

	*item = itsCurrElement->data;

	if (cursorPos > 1)
		{
		itsCurrElement = itsCurrElement->prevElement;
		}

	JListIterator<T>::SetCursor(cursorPos-1);
	return kJTrue;
}

/******************************************************************************
 Next (virtual)

	Return kJTrue if there is a next item, fetching the next
	item in the list and decrementing the iterator position.
	Otherwise return kJFalse without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::Next
	(
	T* item
	)
{
	const JCursorPosition cursorPos = JListIterator<T>::GetCursor();
	if (itsLinkedList == nullptr || cursorPos >= itsLinkedList->GetElementCount())
		{
		return kJFalse;
		}

	if (cursorPos > 0)
		{
		itsCurrElement = itsCurrElement->nextElement;
		}

	*item = itsCurrElement->data;
	JListIterator<T>::SetCursor(cursorPos+1);
	return kJTrue;
}

/******************************************************************************
 SkipPrev (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::SkipPrev
	(
	const JSize count
	)
{
	JCursorPosition cursorPos = JListIterator<T>::GetCursor();
	if (itsLinkedList != nullptr)
		{
		JSize remaining = count;
		while (remaining > 0 && cursorPos > 0)
			{
			if (cursorPos > 1)
				{
				itsCurrElement = itsCurrElement->prevElement;
				}
			cursorPos--;
			remaining--;
			}

		JListIterator<T>::SetCursor(cursorPos);
		}
}

/******************************************************************************
 SkipNext (virtual)

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::SkipNext
	(
	const JSize count
	)
{
	JCursorPosition cursorPos = JListIterator<T>::GetCursor();
	if (itsLinkedList != nullptr)
		{
		const JSize maxPos = itsLinkedList->GetElementCount();

		JSize remaining = count;
		while (remaining > 0 && cursorPos < maxPos)
			{
			if (cursorPos > 0)
				{
				itsCurrElement = itsCurrElement->nextElement;
				}
			cursorPos++;
			remaining--;
			}

		JListIterator<T>::SetCursor(cursorPos);
		}
}

/******************************************************************************
 SetPrev (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::SetPrev
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!JLinkedListIterator<T>::GetList(&obj) || JListIterator<T>::AtBeginning())
		{
		return kJFalse;
		}

	itsLinkedList->IteratorSetElement(JListIterator<T>::GetCursor(), data, itsCurrElement);
	return kJTrue;
}

/******************************************************************************
 SetNext (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::SetNext
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!JLinkedListIterator<T>::GetList(&obj) || JListIterator<T>::AtEnd())
		{
		return kJFalse;
		}

	assert( itsCurrElement->nextElement != nullptr );

	itsLinkedList->IteratorSetElement(JListIterator<T>::GetCursor()+1, data, itsCurrElement->nextElement);
	return kJTrue;
}

/******************************************************************************
 RemovePrev (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::RemovePrev()
{
	JList<T>* obj;
	if (!JLinkedListIterator<T>::GetList(&obj) || JListIterator<T>::AtBeginning())
		{
		return kJFalse;
		}

	itsLinkedList->IteratorRemoveNextElements(JListIterator<T>::GetCursor(), 1, itsCurrElement);
	return kJTrue;
}

/******************************************************************************
 RemoveNext (virtual)

	Returns kJTrue if we have a non-const JLinkedList<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JLinkedListIterator<T>::RemoveNext()
{
	JList<T>* obj;
	if (!JLinkedListIterator<T>::GetList(&obj) || JListIterator<T>::AtEnd())
		{
		return kJFalse;
		}

	itsLinkedList->IteratorRemoveNextElements(JListIterator<T>::GetCursor()+1, 1,
											  itsCurrElement->nextElement);
	return kJTrue;
}

/******************************************************************************
 MoveTo (virtual)

	Reset the iterator position to one of:
		kJIteratorStartAtBeginning, kJIteratorStartAtEnd,
		kJIteratorStartBefore(index), or kJIteratorStartAfter(index)

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::MoveTo
	(
	const JIteratorPosition	newPosition,
	const JIndex			index
	)
{
	JListIterator<T>::MoveTo(newPosition, index);

	if (itsLinkedList == nullptr)
		{
		return;
		}

	if (newPosition == kJIteratorStartAtBeginning ||
		(newPosition == kJIteratorStartBefore && index == 1))
		{
		itsCurrElement = itsLinkedList->itsFirstElement;
		}
	else if (newPosition == kJIteratorStartAtEnd)
		{
		itsCurrElement = itsLinkedList->itsLastElement;
		}
	else
		{
		itsCurrElement = itsLinkedList->FindElement(JListIterator<T>::GetCursor());
		}
}

/******************************************************************************
 ListChanged (virtual protected)

	Respond to changes in itsLinkedList.  In order to optimize, we would have
	to check if prevElement or nextElement was invalid.

 ******************************************************************************/

template <class T>
void
JLinkedListIterator<T>::ListChanged
	(
	const JBroadcaster::Message& message
	)
{
	JListIterator<T>::ListChanged(message);

	if (message.Is(JListT::kElementsInserted) ||
		message.Is(JListT::kElementsRemoved) ||
		message.Is(JListT::kCopied))
		{
		const JCursorPosition cursorPos = JListIterator<T>::GetCursor();
		if (cursorPos == 0)
			{
			itsCurrElement = itsLinkedList->itsFirstElement;
			}
		else
			{
			itsCurrElement = itsLinkedList->FindElement(cursorPos);
			}
		}
	else if (message.Is(JListT::kGoingAway))
		{
		itsLinkedList  = nullptr;
		itsCurrElement = nullptr;
		}
}

#endif
