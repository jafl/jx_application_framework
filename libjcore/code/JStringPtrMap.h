#ifndef _H_JStringPtrMap
#define _H_JStringPtrMap

/******************************************************************************
 JStringPtrMap.h

	Interface for the JStringPtrMap template.

	Copyright (C) 1998 by Dustin Laurence.

	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include "jx-af/jcore/JStringMap.h"
#include "jx-af/jcore/JStringPtrMapCursor.h"

template <class V>
class JStringPtrMap : public JStringMap<V*>
{
	friend class JStringMapCursor<V*>;

public:

	JStringPtrMap(const JPtrArrayT::CleanUpAction action,
				  const JSize lgSize = kJDefaultLgMinTableSize);
	virtual ~JStringPtrMap();

	bool GetElement(const JString& key, V** ptr);
	bool GetElement(const JString& key, const V** ptr) const;

	bool SetElement(const JString& key, V* ptr,
					const JPtrArrayT::SetElementAction action,
					const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewElement(const JString& key, V* ptr);	// avoid shadowing
	bool SetOldElement(const JString& key, V* ptr,
					   const JPtrArrayT::SetElementAction action);
	bool SetContains(const JString& key, V* ptr,
					 const JPtrArrayT::SetElementAction action);

	bool GetElement(const JUtf8Byte* key, V** ptr);
	bool GetElement(const JUtf8Byte* key, const V** ptr) const;

	bool SetElement(const JUtf8Byte* key, V* ptr,
					const JPtrArrayT::SetElementAction action,
					const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewElement(const JUtf8Byte* key, V* ptr);	// avoid shadowing
	bool SetOldElement(const JUtf8Byte* key, V* ptr,
					   const JPtrArrayT::SetElementAction action);
	bool SetContains(const JUtf8Byte* key, V* ptr,
					 const JPtrArrayT::SetElementAction action);

	// these insert a *copy* of the object into the array

	bool SetElement(const JString& key, const V& data,
					const JPtrArrayT::SetElementAction action,
					const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewElement(const JString& key, const V& data);
	bool SetOldElement(const JString& key, const V& data,
					   const JPtrArrayT::SetElementAction action);
	bool SetContains(const JString& key, const V& data,
					 const JPtrArrayT::SetElementAction action);

	bool DeleteElement(const JString& key);
	bool DeleteElementAsArray(const JString& key);

	bool SetElement(const JUtf8Byte* key, const V& data,
					const JPtrArrayT::SetElementAction action,
					const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewElement(const JUtf8Byte* key, const V& data);
	bool SetOldElement(const JUtf8Byte* key, const V& data,
					   const JPtrArrayT::SetElementAction action);
	bool SetContains(const JUtf8Byte* key, const V& data,
					 const JPtrArrayT::SetElementAction action);

	bool DeleteElement(const JUtf8Byte* key);
	bool DeleteElementAsArray(const JUtf8Byte* key);

	void CleanOut();		// safest
	void DeleteAll();
	void DeleteAllAsArrays();

	JPtrArrayT::CleanUpAction	GetCleanUpAction() const;
	void						SetCleanUpAction(const JPtrArrayT::CleanUpAction action);

protected:

	virtual void PrepareForSet(const JPtrArrayT::SetElementAction action);

private:

	JPtrArrayT::CleanUpAction itsCleanUpAction;

private:

	// not allowed

	JStringPtrMap(const JStringPtrMap& source);
	const JStringPtrMap& operator=(const JStringPtrMap& source);
};


/******************************************************************************
 GetElement

	These override the version in JStringMap to preserve constness.

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::GetElement
	(
	const JUtf8Byte* key,
	V**              ptr
	)
{
	return JStringMap<V*>::GetElement(JString(key, JString::kNoCopy), ptr);
}

template <class V>
inline bool
JStringPtrMap<V>::GetElement
	(
	const JString& key,
	V**            ptr
	)
{
	return JStringMap<V*>::GetElement(key, ptr);
}

template <class V>
inline bool
JStringPtrMap<V>::GetElement
	(
	const JUtf8Byte* key,
	const V**        ptr
	)
	const
{
	return JStringMap<V*>::GetElement(JString(key, JString::kNoCopy), const_cast<V**>(ptr));
}

template <class V>
inline bool
JStringPtrMap<V>::GetElement
	(
	const JString& key,
	const V**      ptr
	)
	const
{
	return JStringMap<V*>::GetElement(key, const_cast<V**>(ptr));
}

/******************************************************************************
 Set...Element

	These override the versions in JStringMap to force you to consider the
	SetElementAction.

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::SetElement
	(
	const JUtf8Byte*                   key,
	V*                                 ptr,
	const JPtrArrayT::SetElementAction action,
	const JStringMapT::SetType         type // = kAlways
	)
{
	bool existed;
	return JStringMap<V*>::SetElement(JString(key, JString::kNoCopy), ptr, action, type, &existed);
}

template <class V>
inline bool
JStringPtrMap<V>::SetElement
	(
	const JString&                     key,
	V*                                 ptr,
	const JPtrArrayT::SetElementAction action,
	const JStringMapT::SetType         type // = kAlways
	)
{
	bool existed;
	return JStringMap<V*>::SetElement(key, ptr, action, type, &existed);
}

template <class V>
inline bool
JStringPtrMap<V>::SetNewElement
	(
	const JUtf8Byte* key,
	V*               ptr
	)
{
	return JStringMap<V*>::SetNewElement(JString(key, JString::kNoCopy), ptr);
}

template <class V>
inline bool
JStringPtrMap<V>::SetNewElement
	(
	const JString& key,
	V*             ptr
	)
{
	return JStringMap<V*>::SetNewElement(key, ptr);
}

template <class V>
inline bool
JStringPtrMap<V>::SetOldElement
	(
	const JUtf8Byte*                   key,
	V*                                 ptr,
	const JPtrArrayT::SetElementAction action
	)
{
	return SetElement(JString(key, JString::kNoCopy), ptr, action, JStringMapT::kIfOld);
}

template <class V>
inline bool
JStringPtrMap<V>::SetOldElement
	(
	const JString&                     key,
	V*                                 ptr,
	const JPtrArrayT::SetElementAction action
	)
{
	return SetElement(key, ptr, action, JStringMapT::kIfOld);
}

template <class V>
inline bool
JStringPtrMap<V>::SetContains
	(
	const JUtf8Byte*                   key,
	V*                                 ptr,
	const JPtrArrayT::SetElementAction action
	)
{
	bool existed;
	JStringMap<V*>::SetElement(JString(key, JString::kNoCopy), ptr, action, JStringMapT::kAlways, &existed);
	return existed;
}

template <class V>
inline bool
JStringPtrMap<V>::SetContains
	(
	const JString&                     key,
	V*                                 ptr,
	const JPtrArrayT::SetElementAction action
	)
{
	bool existed;
	JStringMap<V*>::SetElement(key, ptr, action, JStringMapT::kAlways, &existed);
	return existed;
}

/******************************************************************************
 DeleteElement

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::DeleteElement
	(
	const JUtf8Byte* key
	)
{
	return JStringMap<V*>::RemoveElement(JString(key, JString::kNoCopy), JPtrArrayT::kDelete);
}

template <class V>
inline bool
JStringPtrMap<V>::DeleteElement
	(
	const JString& key
	)
{
	return JStringMap<V*>::RemoveElement(key, JPtrArrayT::kDelete);
}

/******************************************************************************
 DeleteElementAsArray

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::DeleteElementAsArray
	(
	const JUtf8Byte* key
	)
{
	return JStringMap<V*>::RemoveElement(JString(key, JString::kNoCopy), JPtrArrayT::kDeleteAsArray);
}

template <class V>
inline bool
JStringPtrMap<V>::DeleteElementAsArray
	(
	const JString& key
	)
{
	return JStringMap<V*>::RemoveElement(key, JPtrArrayT::kDeleteAsArray);
}

/******************************************************************************
 DeleteAll

 *****************************************************************************/

template <class V>
inline void
JStringPtrMap<V>::DeleteAll()
{
	JStringMap<V*>::RemoveAll(JPtrArrayT::kDelete);
}

/******************************************************************************
 DeleteAllAsArrays

 *****************************************************************************/

template <class V>
inline void
JStringPtrMap<V>::DeleteAllAsArrays()
{
	JStringMap<V*>::RemoveAll(JPtrArrayT::kDeleteAsArray);
}

/******************************************************************************
 Clean up action

	What to do when the destructor is called.  This is especially useful
	for objects allocated on the stack, because one can set the appropriate
	action and then never have to worry about short-circuit returns.

 ******************************************************************************/

template <class V>
inline JPtrArrayT::CleanUpAction
JStringPtrMap<V>::GetCleanUpAction()
	const
{
	return itsCleanUpAction;
}

template <class V>
inline void
JStringPtrMap<V>::SetCleanUpAction
	(
	const JPtrArrayT::CleanUpAction action
	)
{
	itsCleanUpAction = action;
}

#include "JStringPtrMap.tmpl"
#include "JStringPtrMapCursor.tmpl"

#endif
