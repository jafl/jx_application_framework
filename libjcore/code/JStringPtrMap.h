#ifndef _H_JStringPtrMap
#define _H_JStringPtrMap

/******************************************************************************
 JStringPtrMap.h

	Interface for the JStringPtrMap template.

	Copyright (C) 1998 by Dustin Laurence.

	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include "JStringMap.h"
#include "JStringPtrMapCursor.h"

template <class V>
class JStringPtrMap : public JStringMap<V*>
{
	friend class JStringMapCursor<V*>;

public:

	JStringPtrMap(const JPtrArrayT::CleanUpAction action,
				  const JSize lgSize = kJDefaultLgMinTableSize);
	~JStringPtrMap() override;

	bool GetItem(const JString& key, V** ptr);
	bool GetItem(const JString& key, const V** ptr) const;

	using JStringMap<V*>::SetNewItem;

	bool SetItem(const JString& key, V* ptr,
				 const JPtrArrayT::SetAction action,
				 const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetOldItem(const JString& key, V* ptr,
					const JPtrArrayT::SetAction action);
	bool SetContains(const JString& key, V* ptr,
					 const JPtrArrayT::SetAction action);

	bool GetItem(const JUtf8Byte* key, V** ptr);
	bool GetItem(const JUtf8Byte* key, const V** ptr) const;

	bool SetItem(const JUtf8Byte* key, V* ptr,
				 const JPtrArrayT::SetAction action,
				 const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetOldItem(const JUtf8Byte* key, V* ptr,
					   const JPtrArrayT::SetAction action);
	bool SetContains(const JUtf8Byte* key, V* ptr,
					 const JPtrArrayT::SetAction action);

	// these insert a *copy* of the object into the array

	bool SetItem(const JString& key, const V& data,
				 const JPtrArrayT::SetAction action,
				 const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewItem(const JString& key, const V& data);
	bool SetOldItem(const JString& key, const V& data,
					const JPtrArrayT::SetAction action);
	bool SetContains(const JString& key, const V& data,
					 const JPtrArrayT::SetAction action);

	bool DeleteItem(const JString& key);
	bool DeleteItemAsArray(const JString& key);

	bool SetItem(const JUtf8Byte* key, const V& data,
				 const JPtrArrayT::SetAction action,
				 const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewItem(const JUtf8Byte* key, const V& data);
	bool SetOldItem(const JUtf8Byte* key, const V& data,
					const JPtrArrayT::SetAction action);
	bool SetContains(const JUtf8Byte* key, const V& data,
					 const JPtrArrayT::SetAction action);

	bool DeleteItem(const JUtf8Byte* key);
	bool DeleteItemAsArray(const JUtf8Byte* key);

	void CleanOut();		// safest
	void DeleteAll();
	void DeleteAllAsArrays();

	JPtrArrayT::CleanUpAction	GetCleanUpAction() const;
	void						SetCleanUpAction(const JPtrArrayT::CleanUpAction action);

protected:

	void PrepareForSet(const JPtrArrayT::SetAction action) override;

private:

	JPtrArrayT::CleanUpAction itsCleanUpAction;
};


/******************************************************************************
 GetItem

	These override the version in JStringMap to preserve constness.

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::GetItem
	(
	const JUtf8Byte* key,
	V**              ptr
	)
{
	return JStringMap<V*>::GetItem(JString(key, JString::kNoCopy), ptr);
}

template <class V>
inline bool
JStringPtrMap<V>::GetItem
	(
	const JString& key,
	V**            ptr
	)
{
	return JStringMap<V*>::GetItem(key, ptr);
}

template <class V>
inline bool
JStringPtrMap<V>::GetItem
	(
	const JUtf8Byte* key,
	const V**        ptr
	)
	const
{
	return JStringMap<V*>::GetItem(JString(key, JString::kNoCopy), const_cast<V**>(ptr));
}

template <class V>
inline bool
JStringPtrMap<V>::GetItem
	(
	const JString& key,
	const V**      ptr
	)
	const
{
	return JStringMap<V*>::GetItem(key, const_cast<V**>(ptr));
}

/******************************************************************************
 Set...Item

	These override the versions in JStringMap to force you to consider the
	SetAction.

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::SetItem
	(
	const JUtf8Byte*            key,
	V*                          ptr,
	const JPtrArrayT::SetAction action,
	const JStringMapT::SetType  type // = kAlways
	)
{
	bool existed;
	return JStringMap<V*>::SetItem(JString(key, JString::kNoCopy), ptr, action, type, &existed);
}

template <class V>
inline bool
JStringPtrMap<V>::SetItem
	(
	const JString&              key,
	V*                          ptr,
	const JPtrArrayT::SetAction action,
	const JStringMapT::SetType  type // = kAlways
	)
{
	bool existed;
	return JStringMap<V*>::SetItem(key, ptr, action, type, &existed);
}

template <class V>
inline bool
JStringPtrMap<V>::SetOldItem
	(
	const JUtf8Byte*            key,
	V*                          ptr,
	const JPtrArrayT::SetAction action
	)
{
	return SetItem(JString(key, JString::kNoCopy), ptr, action, JStringMapT::kIfOld);
}

template <class V>
inline bool
JStringPtrMap<V>::SetOldItem
	(
	const JString&              key,
	V*                          ptr,
	const JPtrArrayT::SetAction action
	)
{
	return SetItem(key, ptr, action, JStringMapT::kIfOld);
}

template <class V>
inline bool
JStringPtrMap<V>::SetContains
	(
	const JUtf8Byte*            key,
	V*                          ptr,
	const JPtrArrayT::SetAction action
	)
{
	bool existed;
	JStringMap<V*>::SetItem(JString(key, JString::kNoCopy), ptr, action, JStringMapT::kAlways, &existed);
	return existed;
}

template <class V>
inline bool
JStringPtrMap<V>::SetContains
	(
	const JString&              key,
	V*                          ptr,
	const JPtrArrayT::SetAction action
	)
{
	bool existed;
	JStringMap<V*>::SetItem(key, ptr, action, JStringMapT::kAlways, &existed);
	return existed;
}

/******************************************************************************
 DeleteItem

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::DeleteItem
	(
	const JUtf8Byte* key
	)
{
	return JStringMap<V*>::RemoveItem(JString(key, JString::kNoCopy), JPtrArrayT::kDelete);
}

template <class V>
inline bool
JStringPtrMap<V>::DeleteItem
	(
	const JString& key
	)
{
	return JStringMap<V*>::RemoveItem(key, JPtrArrayT::kDelete);
}

/******************************************************************************
 DeleteItemAsArray

 *****************************************************************************/

template <class V>
inline bool
JStringPtrMap<V>::DeleteItemAsArray
	(
	const JUtf8Byte* key
	)
{
	return JStringMap<V*>::RemoveItem(JString(key, JString::kNoCopy), JPtrArrayT::kDeleteAsArray);
}

template <class V>
inline bool
JStringPtrMap<V>::DeleteItemAsArray
	(
	const JString& key
	)
{
	return JStringMap<V*>::RemoveItem(key, JPtrArrayT::kDeleteAsArray);
}

/******************************************************************************
 DeleteAll

 *****************************************************************************/

template <class V>
inline void
JStringPtrMap<V>::DeleteAll()
{
	JStringMap<V*>::RemoveAll(JPtrArrayT::kDelete);
}

/******************************************************************************
 DeleteAllAsArrays

 *****************************************************************************/

template <class V>
inline void
JStringPtrMap<V>::DeleteAllAsArrays()
{
	JStringMap<V*>::RemoveAll(JPtrArrayT::kDeleteAsArray);
}

/******************************************************************************
 Clean up action

	What to do when the destructor is called.  This is especially useful
	for objects allocated on the stack, because one can set the appropriate
	action and then never have to worry about short-circuit returns.

 ******************************************************************************/

template <class V>
inline JPtrArrayT::CleanUpAction
JStringPtrMap<V>::GetCleanUpAction()
	const
{
	return itsCleanUpAction;
}

template <class V>
inline void
JStringPtrMap<V>::SetCleanUpAction
	(
	const JPtrArrayT::CleanUpAction action
	)
{
	itsCleanUpAction = action;
}

#include "JStringPtrMap.tmpl"
#include "JStringPtrMapCursor.tmpl"

#endif
