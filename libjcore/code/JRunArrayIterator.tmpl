#ifndef _T_JRunArrayIterator
#define _T_JRunArrayIterator

/******************************************************************************
 JRunArrayIterator.tmpl

	Efficient interation for JRunArray objects.

				+-----+-----+-----+*****+*****+-----+-----+
		index	|  1  |  2  |  3  |  4  |  5  |  6  |  7  |
				+-----+-----+-----+*****+*****+-----+-----+
		run	    1     1     1     2     2     3     3     4
		inRun	0     1     2     0     1     0     1     0

	Copyright (C) 1996-2018 by John Lindal.

 ******************************************************************************/

#include "JRunArrayIterator.h"
#include "JRunArray.h"
#include "jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>::JRunArrayIterator
	(
	const JRunArray<T>&		theRunArray,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theRunArray, start, index)
{
	itsRunArray = const_cast<JRunArray<T>*>(&theRunArray);

	// initialize instance variables -- our override not called by base class

	MoveTo(start, index);
}

template <class T>
JRunArrayIterator<T>::JRunArrayIterator
	(
	JRunArray<T>*			theRunArray,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theRunArray, start, index)
{
	itsRunArray = const_cast<JRunArray<T>*>(theRunArray);

	// initialize instance variables -- our override not called by base class

	MoveTo(start, index);
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>::JRunArrayIterator
	(
	const JRunArrayIterator<T>& source
	)
	:
	JListIterator<T>(source)
{
	itsRunArray    = source.itsRunArray;
	itsRunIndex    = source.itsRunIndex;
	itsOffsetInRun = source.itsOffsetInRun;
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>::~JRunArrayIterator()
{
}

/******************************************************************************
 AtFirstRun

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::AtFirstRun()
	const
{
	return JI2B( itsRunIndex == 1 );
}

/******************************************************************************
 AtLastRun

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::AtLastRun()
	const
{
	return JI2B( itsRunIndex == itsRunArray->GetRunCount() );
}

/******************************************************************************
 PrevRun

	If there is a previous run, moves the iterator position to the start of
	that run and returns TRUE.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::PrevRun()
{
	if (itsRunArray == nullptr || itsRunIndex <= 1)
		{
		return kJFalse;
		}

	MoveTo(kJIteratorStartBefore,
		this->GetCursor() - itsOffsetInRun - itsRunArray->GetRunLength(itsRunIndex-1));

	return kJTrue;
}

/******************************************************************************
 NextRun

	If there is a next run, moves the iterator position to the start of
	that run and returns TRUE.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::NextRun()
{
	if (itsRunArray == nullptr || itsRunIndex >= itsRunArray->GetRunCount())
		{
		return kJFalse;
		}

	MoveTo(kJIteratorStartBefore,
		this->GetCursor() - itsOffsetInRun + itsRunArray->GetRunLength(itsRunIndex));

	return kJTrue;
}

/******************************************************************************
 GetRunStart

 ******************************************************************************/

template <class T>
JIndex
JRunArrayIterator<T>::GetRunStart()
	const
{
	return this->GetCursor() + 1 - itsOffsetInRun;
}

/******************************************************************************
 GetRunEnd

 ******************************************************************************/

template <class T>
JIndex
JRunArrayIterator<T>::GetRunEnd()
	const
{
	return this->GetCursor() - itsOffsetInRun + itsRunArray->GetRunLength(itsRunIndex);
}

/******************************************************************************
 GetRunLength

 ******************************************************************************/

template <class T>
JSize
JRunArrayIterator<T>::GetRunLength()
	const
{
	return itsRunArray->GetRunLength(itsRunIndex);
}

/******************************************************************************
 GetRemainingInRun

 ******************************************************************************/

template <class T>
JSize
JRunArrayIterator<T>::GetRemainingInRun()
	const
{
	return itsRunArray->GetRunLength(itsRunIndex) - itsOffsetInRun;
}

/******************************************************************************
 GetRunData

 ******************************************************************************/

template <class T>
T
JRunArrayIterator<T>::GetRunData()
	const
{
	return itsRunArray->GetRunData(itsRunIndex);
}

/******************************************************************************
 Prev (virtual)

	Return TRUE if there is a previous item, fetching the previous
	item in the list and decrementing the iterator position.
	Otherwise return FALSE without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::Prev
	(
	T* item
	)
{
	if (itsRunArray == nullptr || this->AtBeginning())
		{
		return kJFalse;
		}

	if (itsOffsetInRun == 0)
		{
		itsRunIndex--;
		itsOffsetInRun = itsRunArray->GetRunLength(itsRunIndex) - 1;
		}
	else
		{
		itsOffsetInRun--;
		}

	*item = itsRunArray->GetRunData(itsRunIndex);
	this->SetCursor(this->GetCursor()-1);
	return kJTrue;
}

/******************************************************************************
 Next (virtual)

	Return TRUE if there is a next item, fetching the next
	item in the list and decrementing the iterator position.
	Otherwise return FALSE without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::Next
	(
	T* item
	)
{
	if (itsRunArray == nullptr || this->AtEnd())
		{
		return kJFalse;
		}

	*item = itsRunArray->GetRunData(itsRunIndex);

	if (itsOffsetInRun >= itsRunArray->GetRunLength(itsRunIndex)-1)
		{
		itsRunIndex++;
		itsOffsetInRun = 0;
		}
	else
		{
		itsOffsetInRun++;
		}

	this->SetCursor(this->GetCursor()+1);
	return kJTrue;
}

/******************************************************************************
 SkipPrev (virtual)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::SkipPrev
	(
	const JSize count
	)
{
	JCursorPosition cursorPos = this->GetCursor();
	if (itsRunArray != nullptr)
		{
		JSize remaining = count;
		while (remaining > 0 && cursorPos > 0)
			{
			if (itsOffsetInRun == 0)
				{
				itsRunIndex--;
				itsOffsetInRun = itsRunArray->GetRunLength(itsRunIndex);
				}

			if (itsOffsetInRun >= remaining)
				{
				itsOffsetInRun -= remaining;
				cursorPos      -= remaining;
				break;
				}
			else
				{
				remaining     -= itsOffsetInRun;
				cursorPos     -= itsOffsetInRun;
				itsOffsetInRun = 0;
				}
			}

		this->SetCursor(cursorPos);
		}
}

/******************************************************************************
 SkipNext (virtual)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::SkipNext
	(
	const JSize count
	)
{
	JCursorPosition cursorPos = this->GetCursor();
	if (itsRunArray != nullptr)
		{
		const JSize maxPos = itsRunArray->GetElementCount();

		JSize remaining = count;
		while (remaining > 0 && cursorPos < maxPos)
			{
			const JSize rightCount =
				itsRunArray->GetRunLength(itsRunIndex) - itsOffsetInRun;

			if (remaining < rightCount)
				{
				itsOffsetInRun += remaining;
				cursorPos      += remaining;
				break;
				}
			else
				{
				remaining -= rightCount;
				cursorPos += rightCount;
				itsRunIndex++;
				itsOffsetInRun = 0;
				}
			}

		this->SetCursor(cursorPos);
		}
}

/******************************************************************************
 SetPrev (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::SetPrev
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	JIndex runIndex, firstInRun;
	CalcPrevRunInfo(&runIndex, &firstInRun);

	itsRunArray->IteratorSetElement(this->GetCursor(), data, runIndex, firstInRun);
	return kJTrue;
}

/******************************************************************************
 SetNext (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::SetNext
	(
	const T& data
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtEnd())
		{
		return kJFalse;
		}

	JIndex runIndex, firstInRun;
	CalcNextRunInfo(&runIndex, &firstInRun);

	itsRunArray->IteratorSetElement(this->GetCursor()+1, data, runIndex, firstInRun);
	return kJTrue;
}

/******************************************************************************
 RemovePrev (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::RemovePrev
	(
	const JSize count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	const JSize lastIndex = this->GetCursor();
	SkipPrev(count);
	RemoveNext(lastIndex - this->GetCursor());
	return kJTrue;
}

/******************************************************************************
 RemoveNext (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::RemoveNext
	(
	const JSize count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	JIndex runIndex, firstInRun;
	CalcNextRunInfo(&runIndex, &firstInRun);

	itsRunArray->IteratorRemoveElements(this->GetCursor()+1, count, runIndex, firstInRun);
	return kJTrue;
}

/******************************************************************************
 Insert

	Returns kJTrue if we have a non-const JRunArray<T>*.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::Insert
	(
	const T& data
	)
{
	return Insert(data, 1);
}

template <class T>
JBoolean
JRunArrayIterator<T>::Insert
	(
	const T&	data,
	const JSize	count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj))
		{
		return kJFalse;
		}

	if (this->AtBeginning())
		{
		itsRunArray->PrependElements(data, count);
		}
	else
		{
		JIndex runIndex, firstInRun;
		CalcNextRunInfo(&runIndex, &firstInRun);

		itsRunArray->IteratorInsertElementsAtIndex(this->GetCursor()+1, data, count, runIndex, firstInRun);
		}
	return kJTrue;
}

/******************************************************************************
 InsertSlice

	Returns kJTrue if we have a non-const JRunArray<T>*.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::InsertSlice
	(
	const JRunArray<T>&	source,
	const JIndexRange&	range
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj))
		{
		return kJFalse;
		}

	if (this->AtBeginning())
		{
		itsRunArray->IteratorInsertSlice(1, source, range, 1, 1);
		}
	else
		{
		JIndex runIndex, firstInRun;
		CalcNextRunInfo(&runIndex, &firstInRun);

		itsRunArray->IteratorInsertSlice(this->GetCursor()+1, source, range, runIndex, firstInRun);
		}
	return kJTrue;
}

/******************************************************************************
 CalcPrevRunInfo (private)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::CalcPrevRunInfo
	(
	JIndex* runIndex,
	JIndex* firstInRun
	)
	const
{
	*runIndex          = itsRunIndex;
	JIndex offsetInRun = itsOffsetInRun;
	if (offsetInRun == 0)
		{
		(*runIndex)--;
		offsetInRun = itsRunArray->GetRunLength(*runIndex);
		}

	*firstInRun = this->GetCursor() - offsetInRun + 1;
}

/******************************************************************************
 CalcNextRunInfo (private)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::CalcNextRunInfo
	(
	JIndex* runIndex,
	JIndex* firstInRun
	)
	const
{
	*runIndex   = itsRunIndex;
	*firstInRun = this->GetCursor() - itsOffsetInRun + 1;
}

/******************************************************************************
 MoveTo (virtual)

	Reset the iterator position to one of:
		kJIteratorStartAtBeginning, kJIteratorStartAtEnd,
		IteratorStartBefore(index), or IteratorStartAfter(index)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::MoveTo
	(
	const JIteratorPosition	newPosition,
	const JIndex			index
	)
{
	const JCursorPosition origPosition = this->GetCursor();
	const JBoolean wasAtLimit          = JI2B( this->AtBeginning() || this->AtEnd() );

	JListIterator<T>::MoveTo(newPosition, index);

	const JCursorPosition cursorPosition = this->GetCursor();
	if (itsRunArray == nullptr || cursorPosition == origPosition)
		{
		return;
		}

	if (newPosition == kJIteratorStartAtBeginning ||
		(newPosition == kJIteratorStartBefore && index == 1))
		{
		itsRunIndex    = 1;
		itsOffsetInRun = 0;
		}
	else if (newPosition == kJIteratorStartAtEnd ||
			 (newPosition == kJIteratorStartAfter &&
			  index == itsRunArray->GetElementCount()))
		{
		itsRunIndex    = itsRunArray->GetRunCount()+1;
		itsOffsetInRun = 0;
		}
	else
		{
		JIndex firstIndexInRun;
		JBoolean found;
		if (wasAtLimit)
			{
			found = itsRunArray->FindRun(cursorPosition, &itsRunIndex, &firstIndexInRun);
			}
		else	// incremental
			{
			firstIndexInRun = origPosition - itsOffsetInRun + 1;
			found = itsRunArray->IncrementalFindRun(origPosition, cursorPosition, &itsRunIndex, &firstIndexInRun);
			}
		assert( found );

		itsOffsetInRun = cursorPosition - firstIndexInRun + 1;

		if (itsOffsetInRun >= itsRunArray->GetRunLength(itsRunIndex))
			{
			itsRunIndex++;
			itsOffsetInRun = 0;
			}
		}
}

/******************************************************************************
 ListChanged (virtual protected)

	Respond to changes in itsRunArray.  We can't optimize anything because
	inserting and removing elements can merge runs or split a run.  We have
	to ask our JRunArray what happened.

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::ListChanged
	(
	const JBroadcaster::Message& message
	)
{
	JListIterator<T>::ListChanged(message);

	if (message.Is(JListT::kGoingAway))
		{
		itsRunArray    = nullptr;
		itsRunIndex    = 0;
		itsOffsetInRun = 0;
		}
	else
		{
		const JCursorPosition p = this->GetCursor();
		if (p == 0)
			{
			MoveTo(kJIteratorStartAtBeginning, 0);
			}
		else if (p >= itsRunArray->GetElementCount())
			{
			MoveTo(kJIteratorStartAtEnd, 0);
			}
		else
			{
			MoveTo(kJIteratorStartAfter, p);
			}
		}
}

#endif
