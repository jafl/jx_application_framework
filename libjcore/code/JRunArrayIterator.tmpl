#ifndef _T_JRunArrayIterator
#define _T_JRunArrayIterator

/******************************************************************************
 JRunArrayIterator.tmpl

	Efficient interation for JRunArray objects.

				+-----+-----+-----+*****+*****+-----+-----+
		index	|  1  |  2  |  3  |  4  |  5  |  6  |  7  |
				+-----+-----+-----+*****+*****+-----+-----+
		run	    1     1     1     2     2     3     3     4
		inRun	0     1     2     0     1     0     1     0

	Copyright (C) 1996-2018 by John Lindal.

 ******************************************************************************/

#include "JRunArrayIterator.h"
#include "JRunArray.h"
#include "jAssert.h"

/******************************************************************************
 Constructor

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>::JRunArrayIterator
	(
	const JRunArray<T>&		theRunArray,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theRunArray, start, index),
	itsIgnoreListChangedFlag(kJFalse)
{
	itsRunArray    = const_cast<JRunArray<T>*>(&theRunArray);
	itsRunIndex    = 1;
	itsOffsetInRun = 0;

	// initialize instance variables -- our override not called by base class

	PrivateMoveTo(0, start, index, kJTrue);
}

template <class T>
JRunArrayIterator<T>::JRunArrayIterator
	(
	JRunArray<T>*			theRunArray,
	const JIteratorPosition	start,
	const JIndex			index
	)
	:
	JListIterator<T>(theRunArray, start, index),
	itsIgnoreListChangedFlag(kJFalse)
{
	itsRunArray    = const_cast<JRunArray<T>*>(theRunArray);
	itsRunIndex    = 1;
	itsOffsetInRun = 0;

	// initialize instance variables -- our override not called by base class

	PrivateMoveTo(0, start, index, kJTrue);
}

/******************************************************************************
 Copy constructor

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>::JRunArrayIterator
	(
	const JRunArrayIterator<T>& source
	)
	:
	JListIterator<T>(source),
	itsIgnoreListChangedFlag(kJFalse)
{
	itsRunArray    = source.itsRunArray;
	itsRunIndex    = source.itsRunIndex;
	itsOffsetInRun = source.itsOffsetInRun;
}

/******************************************************************************
 Destructor

 ******************************************************************************/

template <class T>
JRunArrayIterator<T>::~JRunArrayIterator()
{
}

/******************************************************************************
 AtFirstRun

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::AtFirstRun()
	const
{
	return JI2B( itsRunIndex == 1 );
}

/******************************************************************************
 AtLastRun

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::AtLastRun()
	const
{
	return JI2B( itsRunIndex >= itsRunArray->GetRunCount() );
}

/******************************************************************************
 PrevRun

	If there is a previous run, moves the iterator position to the start of
	that run and returns TRUE.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::PrevRun()
{
	if (itsRunArray == nullptr)
		{
		return kJFalse;
		}
	else if (itsRunIndex <= 2)
		{
		MoveTo(kJIteratorStartAtBeginning, 0);
		return kJFalse;
		}
	else
		{
		MoveTo(kJIteratorStartAfter,
			this->GetCursor() - itsOffsetInRun - itsRunArray->GetRunLength(itsRunIndex-1));

		return kJTrue;
		}
}

/******************************************************************************
 NextRun

	If there is a next run, moves the iterator position to the start of
	that run and returns TRUE.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::NextRun()
{
	if (itsRunArray == nullptr)
		{
		return kJFalse;
		}
	else if (itsRunIndex >= itsRunArray->GetRunCount())
		{
		MoveTo(kJIteratorStartAtEnd, 0);
		return kJFalse;
		}
	else
		{
		MoveTo(kJIteratorStartAfter,
			this->GetCursor() - itsOffsetInRun + itsRunArray->GetRunLength(itsRunIndex));

		return kJTrue;
		}
}

/******************************************************************************
 GetRunStart

 ******************************************************************************/

template <class T>
JIndex
JRunArrayIterator<T>::GetRunStart()
	const
{
	return this->GetCursor() + 1 - itsOffsetInRun;
}

/******************************************************************************
 GetRunEnd

 ******************************************************************************/

template <class T>
JIndex
JRunArrayIterator<T>::GetRunEnd()
	const
{
	return this->GetCursor() - itsOffsetInRun + itsRunArray->GetRunLength(itsRunIndex);
}

/******************************************************************************
 GetRunLength

 ******************************************************************************/

template <class T>
JSize
JRunArrayIterator<T>::GetRunLength()
	const
{
	return itsRunArray->GetRunLength(itsRunIndex);
}

/******************************************************************************
 GetRemainingInRun

 ******************************************************************************/

template <class T>
JSize
JRunArrayIterator<T>::GetRemainingInRun()
	const
{
	return itsRunArray->GetRunLength(itsRunIndex) - itsOffsetInRun;
}

/******************************************************************************
 GetRunData

 ******************************************************************************/

template <class T>
T
JRunArrayIterator<T>::GetRunData()
	const
{
	return itsRunArray->GetRunData(itsRunIndex);
}

/******************************************************************************
 Prev (virtual)

	Return TRUE if there is a previous item, fetching the previous
	item in the list and decrementing the iterator position.
	Otherwise return FALSE without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::Prev
	(
	T*				item,
	const JBoolean	move
	)
{
	if (itsRunArray == nullptr || this->AtBeginning())
		{
		return kJFalse;
		}

	JIndex runIndex = itsRunIndex,
		   offset   = itsOffsetInRun;

	if (offset == 0)
		{
		runIndex--;
		offset = itsRunArray->GetRunLength(runIndex) - 1;
		}
	else
		{
		offset--;
		}

	*item = itsRunArray->GetRunData(runIndex);

	if (move)
		{
		itsRunIndex    = runIndex;
		itsOffsetInRun = offset;
		this->SetCursor(this->GetCursor()-1);
		}
	return kJTrue;
}

/******************************************************************************
 Next (virtual)

	Return TRUE if there is a next item, fetching the next
	item in the list and decrementing the iterator position.
	Otherwise return FALSE without fetching or decrementing.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::Next
	(
	T*				item,
	const JBoolean	move
	)
{
	if (itsRunArray == nullptr || this->AtEnd())
		{
		return kJFalse;
		}

	*item = itsRunArray->GetRunData(itsRunIndex);

	if (move)
		{
		if (itsOffsetInRun >= itsRunArray->GetRunLength(itsRunIndex)-1)
			{
			itsRunIndex++;
			itsOffsetInRun = 0;
			}
		else
			{
			itsOffsetInRun++;
			}

		this->SetCursor(this->GetCursor()+1);
		}
	return kJTrue;
}

/******************************************************************************
 SkipPrev (virtual)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::SkipPrev
	(
	const JSize count
	)
{
	JCursorPosition cursorPos = this->GetCursor();
	if (itsRunArray != nullptr)
		{
		JSize remaining = count;
		while (remaining > 0 && cursorPos > 0)
			{
			if (itsOffsetInRun == 0)
				{
				itsRunIndex--;
				itsOffsetInRun = itsRunArray->GetRunLength(itsRunIndex);
				}

			if (itsOffsetInRun >= remaining)
				{
				itsOffsetInRun -= remaining;
				cursorPos      -= remaining;
				break;
				}
			else
				{
				remaining     -= itsOffsetInRun;
				cursorPos     -= itsOffsetInRun;
				itsOffsetInRun = 0;
				}
			}

		this->SetCursor(cursorPos);
		}
}

/******************************************************************************
 SkipNext (virtual)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::SkipNext
	(
	const JSize count
	)
{
	JCursorPosition cursorPos = this->GetCursor();
	if (itsRunArray != nullptr)
		{
		const JSize maxPos = itsRunArray->GetElementCount();

		JSize remaining = count;
		while (remaining > 0 && cursorPos < maxPos)
			{
			const JSize rightCount =
				itsRunArray->GetRunLength(itsRunIndex) - itsOffsetInRun;

			if (remaining < rightCount)
				{
				itsOffsetInRun += remaining;
				cursorPos      += remaining;
				break;
				}
			else
				{
				remaining -= rightCount;
				cursorPos += rightCount;
				itsRunIndex++;
				itsOffsetInRun = 0;
				}
			}

		this->SetCursor(cursorPos);
		}
}

/******************************************************************************
 SetPrev (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::SetPrev
	(
	const T&		data,
	const JBoolean	move
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	SkipPrev();
	SetNext(data, !move);
	return kJTrue;
}

/******************************************************************************
 SetNext (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::SetNext
	(
	const T&		data,
	const JBoolean	move
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtEnd())
		{
		return kJFalse;
		}

	const JIndex itemIndex = this->GetCursor() + 1;
	JIndex firstInRun      = itemIndex - itsOffsetInRun;

	itsIgnoreListChangedFlag = kJTrue;
	itsRunArray->IteratorSetElements(itemIndex, data, 1, &itsRunIndex, &firstInRun);
	itsIgnoreListChangedFlag = kJFalse;

	itsOffsetInRun = itemIndex - firstInRun;

	if (move)
		{
		SkipNext();
		}
	return kJTrue;
}

/******************************************************************************
 SetPrev

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there are previous items.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::SetPrev
	(
	const T&		data,
	const JSize		count,
	const JBoolean	move
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->GetCursor() < count)
		{
		return kJFalse;
		}

	SkipPrev(count);
	SetNext(data, count, !move);
	return kJTrue;
}

/******************************************************************************
 SetNext

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there are next items.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::SetNext
	(
	const T&		data,
	const JSize		count,
	const JBoolean	move
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || itsRunArray->GetElementCount() - this->GetCursor() < count)
		{
		return kJFalse;
		}

	const JIndex itemIndex = this->GetCursor() + 1;
	JIndex runIndex        = itsRunIndex;
	JIndex firstInRun      = itemIndex - itsOffsetInRun;

	const JBoolean wasAtBeginning = this->AtBeginning();
	if (!wasAtBeginning)
		{
		SkipPrev();
		}

	itsIgnoreListChangedFlag = kJTrue;
	itsRunArray->IteratorSetElements(itemIndex, data, count, &runIndex, &firstInRun);
	itsIgnoreListChangedFlag = kJFalse;

	if (!wasAtBeginning)
		{
		SkipNext();
		}

	if (move)
		{
		SkipNext(count);
		}
	return kJTrue;
}

/******************************************************************************
 RemovePrev (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a previous item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::RemovePrev
	(
	const JSize count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtBeginning())
		{
		return kJFalse;
		}

	const JSize lastIndex = this->GetCursor();
	SkipPrev(count);
	RemoveNext(lastIndex - this->GetCursor());
	return kJTrue;
}

/******************************************************************************
 RemoveNext (virtual)

	Returns kJTrue if we have a non-const JRunArray<T>* and
	there is a next item.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::RemoveNext
	(
	const JSize count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj) || this->AtEnd())
		{
		return kJFalse;
		}

	const JIndex itemIndex = this->GetCursor() + 1;
	JIndex firstInRun      = itemIndex - itsOffsetInRun;

	itsIgnoreListChangedFlag = kJTrue;
	itsRunArray->IteratorRemoveElements(itemIndex, count, &itsRunIndex, &firstInRun);
	itsIgnoreListChangedFlag = kJFalse;

	itsOffsetInRun = itemIndex - firstInRun;
	return kJTrue;
}

/******************************************************************************
 Insert

	Returns kJTrue if we have a non-const JRunArray<T>*.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::Insert
	(
	const T& data
	)
{
	return Insert(data, 1);
}

template <class T>
JBoolean
JRunArrayIterator<T>::Insert
	(
	const T&	data,
	const JSize	count
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj))
		{
		return kJFalse;
		}

	if (this->AtBeginning())
		{
		itsRunArray->PrependElements(data, count);
		}
	else
		{
		const JIndex itemIndex = this->GetCursor() + 1;
		JIndex runIndex        = itsRunIndex;
		JIndex firstInRun      = itemIndex - itsOffsetInRun;

		const JBoolean wasAtBeginning = this->AtBeginning();
		SkipPrev();

		itsIgnoreListChangedFlag = kJTrue;
		itsRunArray->IteratorInsertElementsAtIndex(itemIndex, data, count, &runIndex, &firstInRun);
		itsIgnoreListChangedFlag = kJFalse;

		if (!wasAtBeginning)
			{
			SkipNext();
			}
		}
	return kJTrue;
}

/******************************************************************************
 InsertSlice

	Returns kJTrue if we have a non-const JRunArray<T>*.

 ******************************************************************************/

template <class T>
JBoolean
JRunArrayIterator<T>::InsertSlice
	(
	const JRunArray<T>&	source,
	const JIndexRange&	range
	)
{
	JList<T>* obj;
	if (!this->GetList(&obj))
		{
		return kJFalse;
		}

	if (this->AtBeginning())
		{
		JIndex runIndex = 1, firstInRun = 1;

		itsIgnoreListChangedFlag = kJTrue;
		itsRunArray->IteratorInsertSlice(1, source, range, &runIndex, &firstInRun);
		itsIgnoreListChangedFlag = kJFalse;
		}
	else
		{
		const JIndex itemIndex = this->GetCursor() + 1;
		JIndex runIndex        = itsRunIndex;
		JIndex firstInRun      = itemIndex - itsOffsetInRun;

		const JBoolean wasAtBeginning = this->AtBeginning();
		SkipPrev();

		itsIgnoreListChangedFlag = kJTrue;
		itsRunArray->IteratorInsertSlice(itemIndex, source, range, &runIndex, &firstInRun);
		itsIgnoreListChangedFlag = kJFalse;

		if (!wasAtBeginning)
			{
			SkipNext();
			}
		}

	return kJTrue;
}

/******************************************************************************
 MoveTo (virtual)

	Reset the iterator position to one of:
		kJIteratorStartAtBeginning, kJIteratorStartAtEnd,
		IteratorStartBefore(index), or IteratorStartAfter(index)

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::MoveTo
	(
	const JIteratorPosition	newPosition,
	const JIndex			index
	)
{
	const JCursorPosition origPosition = this->GetCursor();
	const JBoolean wasAtLimit          = JI2B( this->AtBeginning() || this->AtEnd() );

	JListIterator<T>::MoveTo(newPosition, index);

	const JCursorPosition cursorPosition = this->GetCursor();
	if (itsRunArray != nullptr && cursorPosition != origPosition)
		{
		PrivateMoveTo(origPosition, newPosition, index, wasAtLimit);
		}
}

template <class T>
void
JRunArrayIterator<T>::PrivateMoveTo
	(
	const JCursorPosition	origPosition,
	const JIteratorPosition	newPosition,
	const JIndex			index,
	const JBoolean			wasAtLimit
	)
{
	if (this->AtBeginning())
		{
		itsRunIndex    = 1;
		itsOffsetInRun = 0;
		}
	else if (this->AtEnd())
		{
		itsRunIndex    = itsRunArray->GetRunCount()+1;
		itsOffsetInRun = 0;
		}
	else
		{
		const JCursorPosition cursorPosition = this->GetCursor();

		JIndex firstIndexInRun;
		JBoolean found;
		if (wasAtLimit)
			{
			found = itsRunArray->FindRun(cursorPosition+1, &itsRunIndex, &firstIndexInRun);
			}
		else	// incremental
			{
			firstIndexInRun = origPosition - itsOffsetInRun + 1;
			found           = itsRunArray->IncrementalFindRun(
									origPosition+1, cursorPosition+1,
									&itsRunIndex, &firstIndexInRun);
			}
		assert( found );

		itsOffsetInRun = cursorPosition - firstIndexInRun + 1;

		if (itsOffsetInRun >= itsRunArray->GetRunLength(itsRunIndex))
			{
			itsRunIndex++;
			itsOffsetInRun = 0;
			}
		}
}

/******************************************************************************
 ListChanged (virtual protected)

	Respond to changes in itsRunArray.  We can't optimize anything because
	inserting and removing elements can merge runs or split a run.  We have
	to ask our JRunArray what happened.

 ******************************************************************************/

template <class T>
void
JRunArrayIterator<T>::ListChanged
	(
	const JBroadcaster::Message& message
	)
{
	JListIterator<T>::ListChanged(message);

	if (message.Is(JListT::kGoingAway))
		{
		itsRunArray    = nullptr;
		itsRunIndex    = 0;
		itsOffsetInRun = 0;
		}
	else if (!itsIgnoreListChangedFlag)
		{
		const JCursorPosition p = this->GetCursor();

		if (p == 0)
			{
			itsRunIndex    = 1;
			itsOffsetInRun = 0;
			}
		else if (p >= itsRunArray->GetElementCount())
			{
			itsRunIndex    = itsRunArray->GetRunCount()+1;
			itsOffsetInRun = 0;
			}
		else
			{
			JIndex firstIndexInRun;
			const JBoolean found = itsRunArray->FindRun(p+1, &itsRunIndex, &firstIndexInRun);
			assert( found );

			itsOffsetInRun = p - firstIndexInRun + 1;

			if (itsOffsetInRun >= itsRunArray->GetRunLength(itsRunIndex))
				{
				itsRunIndex++;
				itsOffsetInRun = 0;
				}
			}
		}
}

#endif
