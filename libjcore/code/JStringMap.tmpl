#ifndef _T_JStringMap
#define _T_JStringMap

/******************************************************************************
 JStringMap.tmpl

	BASE CLASS = JHashTable< JStrValue<V> >

	Copyright © 1997 by Dustin Laurence.  All rights reserved.
	
	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include <JStringMap.h>
#include <string.h>
#include <jAssert.h>

/******************************************************************************
 Constructor

 *****************************************************************************/

template <class V>
JStringMap<V>::JStringMap
	(
	const JBoolean copyKeys
	)
	:
	JHashTable< JStrValue<V> >(),
	itsCopyKeysFlag(copyKeys)
{
	JStringMapX();
}

template <class V>
JStringMap<V>::JStringMap
	(
	const JSize    lgSize,  // = kJDefaultLgMinTableSize
	const JBoolean copyKeys // = kJTrue
	)
	:
	JHashTable< JStrValue<V> >(lgSize),
	itsCopyKeysFlag(copyKeys)
{
	JStringMapX();
}

// private

template <class V>
void
JStringMap<V>::JStringMapX()
{
	JHashTable< JStrValue<V> >::DisallowCursors();
	SetKeyComparison(Compare);
	SetHashFunction(Hash);
}

/******************************************************************************
 Destructor

 *****************************************************************************/

template <class V>
JStringMap<V>::~JStringMap()
{
	RemoveAll();
}

/******************************************************************************
 Contains

	*** This code is also used to position the cursor for use by other
		functions in both this class and derived classes!

 *****************************************************************************/

template <class V>
JBoolean
JStringMap<V>::Contains
	(
	const JCharacter* const key
	)
	const
{
	JConstHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
	// We know the hash value does not depend on V, so this is safe
	JStrValue<V> hashEntry;
	hashEntry.key = key;
	cursor->ResetKey(hashEntry);
	return cursor->NextKey();
}

/******************************************************************************
 GetElement

	If the element is found, sets value to it and returns kJTrue; otherwise,
	leaves value unmodified and returns kJFalse.

 *****************************************************************************/

template <class V>
JBoolean
JStringMap<V>::GetElement
	(
	const JCharacter* const key,
	V*                      value
	)
	const
{
	if (Contains(key))
		{
		*value = JHashTable< JStrValue<V> >::GetCursor()->GetValue().value;
		return kJTrue;
		}
	else
		{
		return kJFalse;
		}
}

/******************************************************************************
 SetElement (protected)

	The element is set if it already existed and 'type' is kIfOld or kAlways
	(the default) or if it did not exist and 'type' is kIfNew or kAlways.

	Returns kJTrue if the element was set, kJFalse otherwise.
	*existed is set to kJTrue if there was something already there.

 *****************************************************************************/

template <class V>
JBoolean
JStringMap<V>::SetElement
	(
	const JCharacter* const            key,
	const V&                           value,
	const JPtrArrayT::SetElementAction action,
	const JStringMapT::SetType         type,
	JBoolean*                          existed
	)
{
	JHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
	JStrValue<V> hashEntry(key, value);

	cursor->ResetKey(hashEntry);
	cursor->ForceNextMapInsertKey();

	if ( cursor->IsFull() )
		{
		*existed = kJTrue;
		if (type == JStringMapT::kIfNew)
			{
			return kJFalse;
			}

		PrepareForSet(action);

		// Otherwise we'd pass in the client's key!
		hashEntry.key = cursor->GetValue().key;
		cursor->Set(hashEntry);
		return kJTrue;
		}
	else
		{
		*existed = kJFalse;
		if (type == JStringMapT::kIfOld)
			{
			return kJFalse;
			}

		if (itsCopyKeysFlag)
			{
			JCharacter* myKey = new JCharacter[strlen(key)+1];
			assert(myKey != NULL);
			strcpy(myKey, key);
			hashEntry.key = myKey;
			cursor->Set(cursor->GetCursorHashValue(), hashEntry);
			}
		else
			{
			cursor->Set(cursor->GetCursorHashValue(), hashEntry);
			}
		return kJTrue;
		}
}

/******************************************************************************
 PrepareForSet (protected)

	Operates on the cursor's element.

 *****************************************************************************/

template <class V>
void
JStringMap<V>::PrepareForSet
	(
	const JPtrArrayT::SetElementAction action
	)
{
#ifdef JStringMapDelete

	if (action == JPtrArrayT::kDelete)
		{
		delete JHashTable< JStrValue<V> >::GetCursor()->GetValue().value;
		}
	else if (action == JPtrArrayT::kDeleteAsArray)
		{
		delete [] JHashTable< JStrValue<V> >::GetCursor()->GetValue().value;
		}
	else
		{
		assert( action == JPtrArrayT::kForget );
		}

#else

	assert( action == JPtrArrayT::kForget );

#endif
}

/******************************************************************************
 RemoveElement (protected)

 *****************************************************************************/

template <class V>
JBoolean
JStringMap<V>::RemoveElement
	(
	const JCharacter* const            key,
	const JPtrArrayT::SetElementAction action
	)
{
	if (Contains(key))
		{
		PrepareForSet(action);

		JHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
		if (itsCopyKeysFlag)
			{
			delete[] const_cast<JCharacter*>(cursor->GetValue().key);
			}
		cursor->Remove();
		return kJTrue;
		}
	else
		{
		return kJFalse;
		}
}

/******************************************************************************
 RemoveAll (protected)

 *****************************************************************************/

template <class V>
void
JStringMap<V>::RemoveAll
	(
	const JPtrArrayT::SetElementAction action
	)
{
	if (!JHashTable< JStrValue<V> >::IsEmpty() &&
		(itsCopyKeysFlag || action != JPtrArrayT::kForget))
		{
		JHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
		cursor->Reset();
		while ( cursor->NextFull() )
			{
			PrepareForSet(action);
			if (itsCopyKeysFlag)
				{
				// delete, but don't mark empty to avoid multiple resizing
				delete[] const_cast<JCharacter*>(cursor->GetValue().key);
				}
			}
		}

	// Mark all at once and possibly resize; we want to call even if the
	// hash table is already empty to zero out the load count
	JHashTable< JStrValue<V> >::MarkAllEmpty();
}

/******************************************************************************
 Compare (static private)

	Too bad this can't be a member function, but JHashTable can't know anything
	about it.

 *****************************************************************************/

template <class V>
JBoolean
JStringMap<V>::Compare
	(
	const JStrValue<V>& lhs,
	const JStrValue<V>& rhs
	)
{
	return JConvertToBoolean(strcmp(lhs.key, rhs.key) == 0);
}

/******************************************************************************
 Hash (static private)

	Too bad this can't be a member function, but JHashTable can't know anything
	about it.

 *****************************************************************************/

template <class V>
JHashValue
JStringMap<V>::Hash
	(
	const JStrValue<V>& value
	)
{
	return JHash7Bit(value.key);
}

#endif

// Instantiate the template for the specified type.

#if defined JTemplateType && !defined JOnlyWantTemplateDefinition
	#define JTemplateName JStringMap
	#include <instantiate_template.h>
	#undef JTemplateName
#endif
