#ifndef _T_JStringMap
#define _T_JStringMap

/******************************************************************************
 JStringMap.tmpl

	BASE CLASS = JHashTable< JStrValue<V> >

	Copyright (C) 1997 by Dustin Laurence.
	
	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include "JStringMap.h"
#include <string.h>
#include "jAssert.h"

/******************************************************************************
 Constructor

 *****************************************************************************/

template <class V>
JStringMap<V>::JStringMap
	(
	const JSize lgSize // = kJDefaultLgMinTableSize
	)
	:
	JHashTable< JStrValue<V> >(lgSize)
{
	JStringMapX();
}

// private

template <class V>
void
JStringMap<V>::JStringMapX()
{
	JHashTable< JStrValue<V> >::DisallowCursors();
	JStringMap<V>::SetKeyComparison(Compare);
	JStringMap<V>::SetHashFunction(Hash);
}

/******************************************************************************
 Destructor

 *****************************************************************************/

template <class V>
JStringMap<V>::~JStringMap()
{
	RemoveAll();
}

/******************************************************************************
 Contains

	*** This code is also used to position the cursor for use by other
		functions in both this class and derived classes!

 *****************************************************************************/

template <class V>
bool
JStringMap<V>::Contains
	(
	const JString& key
	)
	const
{
	JConstHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
	// We know the hash value does not depend on V, so this is safe
	JStrValue<V> hashEntry;
	hashEntry.key = &key;
	cursor->ResetKey(hashEntry);
	return cursor->NextKey();
}

/******************************************************************************
 GetElement

	If the element is found, sets value to it and returns true; otherwise,
	leaves value unmodified and returns false.

 *****************************************************************************/

template <class V>
bool
JStringMap<V>::GetElement
	(
	const JString& key,
	V*             value
	)
	const
{
	if (Contains(key))
		{
		*value = JHashTable< JStrValue<V> >::GetCursor()->GetValue().value;
		return true;
		}
	else
		{
		return false;
		}
}

/******************************************************************************
 SetElement (protected)

	The element is set if it already existed and 'type' is kIfOld or kAlways
	(the default) or if it did not exist and 'type' is kIfNew or kAlways.

	Returns true if the element was set, false otherwise.
	*existed is set to true if there was something already there.

 *****************************************************************************/

template <class V>
bool
JStringMap<V>::SetElement
	(
	const JString&                     key,
	const V&                           value,
	const JPtrArrayT::SetElementAction action,
	const JStringMapT::SetType         type,
	bool*                          existed
	)
{
	JHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
	JStrValue<V> hashEntry(&key, value);

	cursor->ResetKey(hashEntry);
	cursor->ForceNextMapInsertKey();

	if ( cursor->IsFull() )
		{
		*existed = true;
		if (type == JStringMapT::kIfNew)
			{
			return false;
			}

		PrepareForSet(action);

		// Otherwise we'd pass in the client's key!
		hashEntry.key = cursor->GetValue().key;
		cursor->Set(hashEntry);
		return true;
		}
	else
		{
		*existed = false;
		if (type == JStringMapT::kIfOld)
			{
			return false;
			}

		hashEntry.key = jnew JString(key);
		assert( hashEntry.key != nullptr );
		cursor->Set(cursor->GetCursorHashValue(), hashEntry);

		return true;
		}
}

/******************************************************************************
 PrepareForSet (virtual protected)

	Operates on the cursor's element.

 *****************************************************************************/

template <class V>
void
JStringMap<V>::PrepareForSet
	(
	const JPtrArrayT::SetElementAction action
	)
{
	assert( action == JPtrArrayT::kForget );
}

/******************************************************************************
 RemoveElement (protected)

 *****************************************************************************/

template <class V>
bool
JStringMap<V>::RemoveElement
	(
	const JString&                     key,
	const JPtrArrayT::SetElementAction action
	)
{
	if (Contains(key))
		{
		PrepareForSet(action);

		JHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
		jdelete const_cast<JString*>(cursor->GetValue().key);

		cursor->Remove();
		return true;
		}
	else
		{
		return false;
		}
}

/******************************************************************************
 RemoveAll (protected)

 *****************************************************************************/

template <class V>
void
JStringMap<V>::RemoveAll
	(
	const JPtrArrayT::SetElementAction action
	)
{
	if (!JHashTable< JStrValue<V> >::IsEmpty() && action != JPtrArrayT::kForget)
		{
		JHashCursor< JStrValue<V> >* cursor = JHashTable< JStrValue<V> >::GetCursor();
		cursor->Reset();
		while ( cursor->NextFull() )
			{
			PrepareForSet(action);

			// delete, but don't mark empty to avoid multiple resizing
			jdelete const_cast<JString*>(cursor->GetValue().key);
			}
		}

	// Mark all at once and possibly resize; we want to call even if the
	// hash table is already empty to zero out the load count
	JHashTable< JStrValue<V> >::MarkAllEmpty();
}

/******************************************************************************
 Compare (static private)

	Too bad this can't be a member function, but JHashTable can't know anything
	about it.

 *****************************************************************************/

template <class V>
bool
JStringMap<V>::Compare
	(
	const JStrValue<V>& lhs,
	const JStrValue<V>& rhs
	)
{
	return *(lhs.key) == *(rhs.key);
}

/******************************************************************************
 Hash (static private)

	Too bad this can't be a member function, but JHashTable can't know anything
	about it.

 *****************************************************************************/

template <class V>
JHashValue
JStringMap<V>::Hash
	(
	const JStrValue<V>& value
	)
{
	return JHash7Bit(value.key->GetBytes());
}

#endif
