#ifndef _H_JStringMap
#define _H_JStringMap

/******************************************************************************
 JStringMap.h

	Interface for the JStringMap template.

	Copyright (C) 1997 by Dustin Laurence.

	Base code generated by Codemill v0.1.0

 *****************************************************************************/

#include "JHashTable.h"
#include "JStringMapCursor.h"
#include "JStrValue.h"
#include "JString.h"
#include "JPtrArrayT.h"

struct JStringMapT
{
	enum SetType
	{
		kIfNew, // Only set if the element already exists
		kIfOld, // Only set if the element does not already exist
		kAlways // Always set the element
	};
};

template <class V>
class JStringMap : public JHashTable< JStrValue<V> >
{
	friend class JStringMapCursor<V>;

public:

	JStringMap(const JSize lgSize = kJDefaultLgMinTableSize);
	~JStringMap() override;

	bool Contains(const JString& key) const;
	bool GetItem(const JString& key, V* value) const;

	bool SetItem(const JString& key, const V& value,
				 const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewItem(const JString& key, const V& value);
	bool SetOldItem(const JString& key, const V& value);
	bool SetContains(const JString& key, const V& value);

	bool RemoveItem(const JString& key);
	void RemoveAll();

	bool Contains(const JUtf8Byte* key) const;
	bool GetItem(const JUtf8Byte* key, V* value) const;

	bool SetItem(const JUtf8Byte* key, const V& value,
				 const JStringMapT::SetType type = JStringMapT::kAlways);
	bool SetNewItem(const JUtf8Byte* key, const V& value);
	bool SetOldItem(const JUtf8Byte* key, const V& value);
	bool SetContains(const JUtf8Byte* key, const V& value);

	bool RemoveItem(const JUtf8Byte* key);

protected:

	bool         SetItem(const JString& key, const V& value,
						 const JPtrArrayT::SetAction action,
						 const JStringMapT::SetType type,
						 bool* existed);
	virtual void PrepareForSet(const JPtrArrayT::SetAction action);

	bool RemoveItem(const JString& key,
					const JPtrArrayT::SetAction action);
	void RemoveAll(const JPtrArrayT::SetAction action);
};


/******************************************************************************
 Contains

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::Contains
	(
	const JUtf8Byte* key
	)
	const
{
	return Contains(JString(key, JString::kNoCopy));
}

/******************************************************************************
 GetItem

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::GetItem
	(
	const JUtf8Byte* key,
	V*               value
	)
	const
{
	return GetItem(JString(key, JString::kNoCopy), value);
}

/******************************************************************************
 Set...Element

	The basic idea of setting a map element is simple.  However, it is
	common to write code which will set a value depending on whether it
	already exists.  Several forms of Set...Element support this notion
	more efficiently than calling Contains() and then SetItem().  In
	particular, the hash calculation and internal search will only happen
	once.

 *****************************************************************************/

/******************************************************************************
 SetItem

	The element is set if it already existed and 'type' is kIfOld or kAlways
	(the default) or if it did not exist and 'type' is kIfNew or kAlways.

	Returns true if the element was set, false otherwise.

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::SetItem
	(
	const JUtf8Byte*           key,
	const V&                   value,
	const JStringMapT::SetType type // = kAlways
	)
{
	bool existed;
	return SetItem(JString(key, JString::kNoCopy), value, JPtrArrayT::kForget, type, &existed);
}

template <class V>
inline bool
JStringMap<V>::SetItem
	(
	const JString&             key,
	const V&                   value,
	const JStringMapT::SetType type // = kAlways
	)
{
	bool existed;
	return SetItem(key, value, JPtrArrayT::kForget, type, &existed);
}

/******************************************************************************
 SetNewItem

	Only sets the value if it does not already exist.  Returns true if the
	value was set.

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::SetNewItem
	(
	const JUtf8Byte* key,
	const V&         value
	)
{
	return SetItem(JString(key, JString::kNoCopy), value, JStringMapT::kIfNew);
}

template <class V>
inline bool
JStringMap<V>::SetNewItem
	(
	const JString& key,
	const V&       value
	)
{
	return SetItem(key, value, JStringMapT::kIfNew);
}

/******************************************************************************
 SetOldItem

	Only sets the value if it already exists.  Returns true if the value was
	set.

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::SetOldItem
	(
	const JUtf8Byte* key,
	const V&         value
	)
{
	return SetItem(JString(key, JString::kNoCopy), value, JStringMapT::kIfOld);
}

template <class V>
inline bool
JStringMap<V>::SetOldItem
	(
	const JString& key,
	const V&       value
	)
{
	return SetItem(key, value, JStringMapT::kIfOld);
}

/******************************************************************************
 SetContains

	A sometimes useful hybrid form; always sets the element, and returns true
	if the element already existed, false otherwise.

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::SetContains
	(
	const JUtf8Byte* key,
	const V&         value
	)
{
	bool existed;
	SetItem(JString(key, JString::kNoCopy), value, JPtrArrayT::kForget, JStringMapT::kAlways, &existed);
	return existed;
}

template <class V>
inline bool
JStringMap<V>::SetContains
	(
	const JString& key,
	const V&       value
	)
{
	bool existed;
	SetItem(key, value, JPtrArrayT::kForget, JStringMapT::kAlways, &existed);
	return existed;
}

/******************************************************************************
 RemoveItem

 *****************************************************************************/

template <class V>
inline bool
JStringMap<V>::RemoveItem
	(
	const JUtf8Byte* key
	)
{
	return RemoveItem(JString(key, JString::kNoCopy), JPtrArrayT::kForget);
}

template <class V>
inline bool
JStringMap<V>::RemoveItem
	(
	const JString& key
	)
{
	return RemoveItem(key, JPtrArrayT::kForget);
}

/******************************************************************************
 RemoveAll

 *****************************************************************************/

template <class V>
inline void
JStringMap<V>::RemoveAll()
{
	RemoveAll(JPtrArrayT::kForget);
}

#include "JStringMap.tmpl"
#include "JStringMapCursor.tmpl"

#endif
